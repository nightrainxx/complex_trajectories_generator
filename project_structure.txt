# 项目结构报告
生成时间: 2025-03-28 23:13:29

## 项目结构树
```
├── README.md
├── collect_project_info.py
├── complex_trajectories_generator.egg-info
    ├── SOURCES.txt
    ├── dependency_links.txt
    ├── entry_points.txt
    ├── requires.txt
    ├── top_level.txt
├── config.py
├── create_test_data.py
├── docs
    ├── validation_log.md
├── examples
    ├── evaluate_trajectories.py
    ├── generate_trajectory.py
├── main.py
├── plot_style.py
├── plot_test.py
├── project_structure.txt
├── readme.md
├── requirements.txt
├── scripts
    ├── analyze_simulation_results.py
    ├── create_test_data.py
    ├── generate_environment_maps.py
    ├── generate_slope.py
    ├── select_points.py
    ├── test_evaluator.py
    ├── test_path_planner.py
    ├── test_trajectory_generator.py
    ├── train_motion_patterns.py
    ├── validate_motion_simulation.py
    ├── visualize_trajectory.py
├── setup.py
├── src
    ├── __init__.py
    ├── analysis
        ├── __init__.py
        ├── environment_analyzer.py
    ├── config.py
    ├── core
        ├── batch_generator.py
        ├── environment
            ├── __init__.py
        ├── evaluator.py
        ├── learning
            ├── motion_pattern_learner.py
        ├── motion
            ├── __init__.py
            ├── simulator.py
        ├── path
            ├── planner.py
        ├── point_selector.py
        ├── terrain
            ├── __init__.py
            ├── analyzer.py
            ├── loader.py
        ├── trajectory
            ├── __init__.py
            ├── environment_based.py
            ├── generator.py
        ├── validation
            ├── validator.py
    ├── data_processing
        ├── __init__.py
        ├── data_loader.py
        ├── environment_mapper.py
        ├── motion_pattern_learner.py
        ├── oord_processor.py
        ├── terrain_analyzer.py
        ├── terrain_loader.py
        ├── trajectory_loader.py
    ├── evaluation
        ├── __init__.py
        ├── evaluator.py
    ├── generation
        ├── __init__.py
    ├── generator
        ├── __init__.py
        ├── batch_generator.py
        ├── config.py
        ├── data_loader.py
        ├── environment_mapper.py
        ├── evaluator.py
        ├── motion_simulator.py
        ├── oord_analyzer.py
        ├── path_planner.py
        ├── point_selector.py
        ├── terrain_analyzer.py
        ├── trajectory_generator.py
    ├── learning
        ├── __init__.py
    ├── trajectory_generation
        ├── environment_based_generator.py
        ├── path_planner.py
        ├── point_selector.py
        ├── trajectory_generator.py
    ├── utils
        ├── __init__.py
        ├── config.py
        ├── logging_utils.py
        ├── visualization.py
├── test_plot_style.py
├── tests
    ├── __init__.py
    ├── conftest.py
    ├── core
            ├── test_analyzer.py
            ├── test_loader.py
        ├── test_batch_generator.py
        ├── test_evaluator.py
        ├── test_point_selector.py
        ├── trajectory
            ├── test_environment_based.py
            ├── test_generator.py
    ├── data_processing
        ├── test_oord_processor.py
        ├── test_terrain_analyzer.py
        ├── test_terrain_loader.py
    ├── trajectory_generation
        ├── test_environment_based_generator.py
    ├── unit
        ├── __init__.py
        ├── test_data_loader.py
        ├── test_environment_analyzer.py
        ├── test_environment_mapper.py
        ├── test_motion_simulator.py
        ├── test_oord_analyzer.py
        ├── test_path_planner.py
        ├── test_point_selector.py
        ├── test_terrain_analyzer.py
        ├── test_trajectory_generator.py
        ├── test_trajectory_loader.py
├── 作图规范.md
```

## 文件内容

### README.md
```
# 复杂轨迹生成器

基于地形和环境特征的复杂轨迹生成系统。

## 项目结构

```
complex_trajectories_generator/
├── data/
│   ├── input/
│   │   ├── gis/              # GIS数据
│   │   │   ├── dem_30m_100km.tif
│   │   │   └── landcover_30m_100km.tif
│   │   └── oord/             # OORD数据
│   └── output/
│       ├── intermediate/      # 中间结果
│       ├── trajectory_generation/  # 生成的轨迹
│       └── evaluation/        # 评估结果
├── src/
│   ├── core/
│   │   ├── terrain/          # 地形模块
│   │   │   ├── analyzer.py   # 地形分析
│   │   │   └── loader.py     # 地形数据加载
│   │   └── trajectory/       # 轨迹模块
│   │       ├── generator.py  # 轨迹生成器基类
│   │       └── environment_based.py  # 基于环境的生成器
│   └── utils/
│       ├── config.py         # 配置管理
│       └── logging_utils.py  # 日志工具
├── tests/                    # 单元测试
├── examples/                 # 使用示例
└── requirements.txt          # 项目依赖
```

## 功能特性

1. 地形分析
   - 加载和处理DEM数据
   - 计算坡度和坡向
   - 分析土地覆盖类型
   - 评估地形可通行性

2. 轨迹生成
   - 基于环境特征的路径规划
   - 考虑地形影响的速度规划
   - 平滑的轨迹插值
   - 合理的朝向计算

3. 配置管理
   - 统一的配置接口
   - 可定制的参数设置
   - 环境变量支持

4. 可视化
   - 轨迹可视化
   - 速度分析
   - 地形叠加显示

## 安装

1. 创建conda环境：
```bash
conda create -n wargame python=3.8
conda activate wargame
```

2. 安装依赖：
```bash
pip install -r requirements.txt
```

## 使用示例

1. 准备数据
   - 将DEM数据放在 `data/input/gis/dem_30m_100km.tif`
   - 将土地覆盖数据放在 `data/input/gis/landcover_30m_100km.tif`

2. 运行示例脚本：
```bash
python examples/generate_trajectory.py
```

3. 查看结果
   - 轨迹数据：`data/output/trajectory_generation/example_trajectory.json`
   - 轨迹图形：`data/output/trajectory_generation/example_trajectory.png`

## 开发指南

1. 代码规范
   - 使用类型注解
   - 编写详细的文档字符串
   - 遵循PEP 8规范

2. 测试
   - 运行单元测试：`python -m unittest discover tests`
   - 测试覆盖率：`coverage run -m unittest discover tests`
   - 生成覆盖率报告：`coverage report`

3. 日志
   - 使用 `logging` 模块记录日志
   - 配置日志级别和格式

## 配置说明

1. 路径配置
   - 输入数据路径
   - 输出数据路径
   - 中间文件路径

2. 地形配置
   - 坡度分级
   - 地物编码
   - 不可通行条件

3. 运动配置
   - 时间步长
   - 速度约束
   - 加速度约束
   - 转向约束

4. 生成配置
   - 轨迹数量
   - 距离约束
   - 环境组标签

## 注意事项

1. 数据要求
   - DEM数据分辨率：30米
   - 土地覆盖数据分辨率：30米
   - 坐标系统：EPSG:4326

2. 性能考虑
   - 大规模数据处理时注意内存使用
   - 轨迹生成过程可能需要较长时间
   - 可以通过调整参数优化性能

3. 限制条件
   - 最大坡度限制
   - 不可通行地物类型
   - 轨迹平滑度要求

## 维护者

- 作者：[Your Name]
- 邮箱：[your.email@example.com]

## 许可证

本项目采用 MIT 许可证。详见 [LICENSE](LICENSE) 文件。 
```

### collect_project_info.py
```python
"""
项目信息收集脚本
收集项目根目录下的所有代码文件，并生成项目结构图
"""
import os
from pathlib import Path
import datetime

def get_file_content(file_path):
    """读取文件内容"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"无法读取文件内容: {str(e)}"

def collect_project_info(root_dir='.', output_file='project_structure.txt'):
    """收集项目信息并生成结构图"""
    # 要忽略的目录和文件
    ignore_dirs = {'.git', '__pycache__', '.pytest_cache', '.vscode', '.idea'}
    ignore_files = {'.gitignore', '.DS_Store'}
    
    # 获取所有Python文件和Markdown文件
    code_files = []
    for root, dirs, files in os.walk(root_dir):
        # 忽略特定目录
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        
        for file in files:
            if file in ignore_files:
                continue
                
            if file.endswith(('.py', '.md', '.txt')):
                code_files.append(os.path.join(root, file))
    
    # 生成输出内容
    output = []
    output.append("# 项目结构报告")
    output.append(f"生成时间: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
    
    # 生成目录树
    output.append("## 项目结构树")
    output.append("```")
    current_level = 0
    last_dirs = []
    
    for file_path in sorted(code_files):
        rel_path = os.path.relpath(file_path, root_dir)
        parts = rel_path.split(os.sep)
        
        # 处理目录结构
        for i, part in enumerate(parts[:-1]):
            if i >= len(last_dirs) or part != last_dirs[i]:
                output.append("    " * i + "├── " + part)
                last_dirs = parts[:-1]
        
        # 添加文件
        output.append("    " * (len(parts) - 1) + "├── " + parts[-1])
    
    output.append("```\n")
    
    # 添加文件内容
    output.append("## 文件内容")
    for file_path in sorted(code_files):
        rel_path = os.path.relpath(file_path, root_dir)
        output.append(f"\n### {rel_path}")
        output.append("```" + ("python" if file_path.endswith('.py') else ""))
        output.append(get_file_content(file_path))
        output.append("```")
    
    # 写入文件
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(output))
    
    print(f"项目结构和代码已保存到 {output_file}")

if __name__ == "__main__":
    collect_project_info() 
```

### complex_trajectories_generator.egg-info/SOURCES.txt
```
README.md
setup.py
complex_trajectories_generator.egg-info/PKG-INFO
complex_trajectories_generator.egg-info/SOURCES.txt
complex_trajectories_generator.egg-info/dependency_links.txt
complex_trajectories_generator.egg-info/entry_points.txt
complex_trajectories_generator.egg-info/requires.txt
complex_trajectories_generator.egg-info/top_level.txt
src/__init__.py
src/config.py
src/analysis/__init__.py
src/analysis/environment_analyzer.py
src/data_processing/__init__.py
src/data_processing/data_loader.py
src/data_processing/environment_mapper.py
src/data_processing/motion_pattern_learner.py
src/data_processing/oord_processor.py
src/data_processing/terrain_analyzer.py
src/data_processing/terrain_loader.py
src/data_processing/trajectory_loader.py
src/evaluation/__init__.py
src/evaluation/evaluator.py
src/generator/__init__.py
src/generator/batch_generator.py
src/generator/config.py
src/generator/data_loader.py
src/generator/environment_mapper.py
src/generator/evaluator.py
src/generator/motion_simulator.py
src/generator/oord_analyzer.py
src/generator/path_planner.py
src/generator/point_selector.py
src/generator/terrain_analyzer.py
src/generator/trajectory_generator.py
src/utils/__init__.py
src/utils/logging_utils.py
tests/__init__.py
tests/conftest.py
tests/unit/__init__.py
tests/unit/test_data_loader.py
tests/unit/test_environment_analyzer.py
tests/unit/test_environment_mapper.py
tests/unit/test_motion_simulator.py
tests/unit/test_oord_analyzer.py
tests/unit/test_path_planner.py
tests/unit/test_point_selector.py
tests/unit/test_terrain_analyzer.py
tests/unit/test_trajectory_generator.py
tests/unit/test_trajectory_loader.py
```

### complex_trajectories_generator.egg-info/dependency_links.txt
```


```

### complex_trajectories_generator.egg-info/entry_points.txt
```
[console_scripts]
generate_trajectories = src.main:main

```

### complex_trajectories_generator.egg-info/requires.txt
```
numpy
pandas
scipy
matplotlib
seaborn
rasterio
geopandas
scikit-learn
pathfinding
scikit-image
richdem

```

### complex_trajectories_generator.egg-info/top_level.txt
```
src
tests

```

### config.py
```python
"""配置文件

包含项目所需的所有配置参数和路径设置。

定义环境地图生成器所需的常量和参数。
"""

import os
from pathlib import Path

# 基础路径配置
BASE_DIR = Path(__file__).parent
DATA_DIR = BASE_DIR / 'data'
INPUT_DIR = DATA_DIR / 'input'
OUTPUT_DIR = DATA_DIR / 'output'
INTERMEDIATE_DIR = OUTPUT_DIR / 'intermediate'

# 确保目录存在
for dir_path in [DATA_DIR, INPUT_DIR, OUTPUT_DIR, INTERMEDIATE_DIR]:
    dir_path.mkdir(parents=True, exist_ok=True)

# 输入数据路径
GIS_DIR = INPUT_DIR / 'gis'
OORD_DIR = INPUT_DIR / 'oord'

# GIS数据文件
DEM_PATH = GIS_DIR / 'dem_30m_100km.tif'
LANDCOVER_PATH = GIS_DIR / 'landcover_30m_100km.tif'

# 生成的地形属性文件
SLOPE_MAGNITUDE_PATH = INTERMEDIATE_DIR / 'slope_magnitude_30m_100km.tif'
SLOPE_ASPECT_PATH = INTERMEDIATE_DIR / 'slope_aspect_30m_100km.tif'
DZDX_PATH = INTERMEDIATE_DIR / 'dzdx_30m_100km.tif'
DZDY_PATH = INTERMEDIATE_DIR / 'dzdy_30m_100km.tif'

# 环境地图文件
MAX_SPEED_MAP_PATH = INTERMEDIATE_DIR / 'max_speed_map.tif'
TYPICAL_SPEED_MAP_PATH = INTERMEDIATE_DIR / 'typical_speed_map.tif'
SPEED_STDDEV_MAP_PATH = INTERMEDIATE_DIR / 'speed_stddev_map.tif'
COST_MAP_PATH = INTERMEDIATE_DIR / 'cost_map.tif'

# 轨迹生成参数
NUM_TRAJECTORIES_TO_GENERATE = 500  # 要生成的轨迹总数
NUM_END_POINTS = 3                  # 要选择的固定终点数量
NUM_TRAJECTORIES_PER_END = NUM_TRAJECTORIES_TO_GENERATE // NUM_END_POINTS
MIN_START_END_DISTANCE_METERS = 80000  # 起终点最小直线距离（米）

# 地物编码
URBAN_LANDCOVER_CODES = [1, 10]     # 代表城市/建成区的地物编码
IMPASSABLE_LANDCOVER_CODES = [11]   # 代表绝对不可通行的地物编码（如水体）

# 坡度分组
SLOPE_BINS = [0, 5, 10, 15, 20, 25, 30, 35]  # 坡度分组边界（度）

# 坡度相关参数
MAX_SLOPE_THRESHOLD = 45.0  # 最大可通行坡度（度）
SLOPE_SPEED_FACTOR = 0.05   # 坡度对速度的影响因子
BASE_MAX_SPEED = 5.0        # 基础最大速度（m/s）

# 速度相关参数
TYPICAL_SPEED_FACTOR = 0.7  # 典型速度与最大速度的比例
BASE_SPEED_STDDEV_FACTOR = 0.2  # 基础速度标准差因子

# 坡向相关参数
PREFERRED_DIRECTION = 90.0  # 偏好移动方向（度，东向为90度）
ASPECT_INFLUENCE = 0.2      # 坡向对速度的影响程度

# 坡度对标准差的影响
SLOPE_STDDEV_THRESHOLD = 30.0  # 坡度标准差阈值（度）
SLOPE_STDDEV_FACTOR = 0.5      # 坡度对标准差的影响因子

# 地形复杂度相关
COMPLEX_TERRAIN_CODES = [41, 42, 43]  # 复杂地形的土地覆盖代码
COMPLEX_TERRAIN_STDDEV_FACTOR = 1.5   # 复杂地形对标准差的影响因子

# 土地覆盖类型对速度的影响因子
LANDCOVER_SPEED_FACTORS = {
    11: 1.0,  # 城市建成区
    21: 0.9,  # 农田
    31: 0.8,  # 草地
    41: 0.7,  # 灌木林
    42: 0.6,  # 疏林
    43: 0.5,  # 密林
    51: 0.4,  # 湿地
    61: 0.3,  # 裸地
    71: 0.2   # 沙地
}

# 土地覆盖类型对成本的额外影响因子
LANDCOVER_COST_FACTORS = {
    11: 1.0,  # 城市建成区
    21: 1.2,  # 农田
    31: 1.3,  # 草地
    41: 1.5,  # 灌木林
    42: 1.7,  # 疏林
    43: 2.0,  # 密林
    51: 2.5,  # 湿地
    61: 1.8,  # 裸地
    71: 2.2   # 沙地
}

# 不可通行的土地覆盖类型代码
IMPASSABLE_LANDCOVER_CODES = [81, 82, 83]  # 水体、冰川、建筑物等

# 运动约束参数
MOTION_CONSTRAINTS = {
    'max_acceleration': 2.0,     # 最大加速度 (m/s^2)
    'max_deceleration': 4.0,     # 最大减速度 (m/s^2)
    'max_turn_rate': 45.0,       # 最大转向率 (度/秒)
    'min_speed': 0.0,           # 最小速度 (m/s)
    'time_step': 1.0,           # 模拟时间步长 (秒)
    'max_iterations': 10000,     # 最大迭代次数
    'position_threshold': 0.1    # 位置判断阈值 (m)
}

# 地形约束参数
TERRAIN_CONSTRAINTS = {
    'max_uphill_slope': 30.0,    # 最大上坡坡度 (度)
    'max_downhill_slope': 35.0,  # 最大下坡坡度 (度)
    'max_cross_slope': 25.0,     # 最大横坡坡度 (度)
    'k_uphill': 0.1,            # 上坡减速系数
    'k_downhill': 0.05,         # 下坡加速系数
    'k_cross': 0.2,             # 横坡减速系数
    'min_speed_steep_slope': 0.5 # 陡坡最小速度 (m/s)
}

# 基础运动参数
BASE_SPEED = 10.0               # 基准速度 (m/s)
MAX_SLOPE = 35.0               # 最大可通行坡度 (度)

# 评估参数
EVALUATION_METRICS = {
    'speed_distribution': True,
    'acceleration_distribution': True,
    'turn_rate_distribution': True,
    'slope_speed_relationship': True
} 
```

### create_test_data.py
```python
import numpy as np
import rasterio
from rasterio.transform import from_origin

# 设置地图范围和分辨率
lon_min = 116.0
lat_min = 39.0
resolution_deg = 0.0001  # 约10米
size = 100

# 创建DEM数据
dem = np.zeros((size, size), dtype=np.float32)
for i in range(size):
    for j in range(size):
        dem[i,j] = 100 + i*2 + j  # 简单的坡度

# 创建土地覆盖数据
landcover = np.ones((size, size), dtype=np.int32)
landcover[40:60, 40:60] = 2  # 中间区域为山地

# 设置地理变换矩阵
transform = from_origin(lon_min, lat_min + size * resolution_deg, resolution_deg, resolution_deg)

# 保存DEM
with rasterio.open('data/terrain/dem.tif', 'w',
                  driver='GTiff',
                  height=size,
                  width=size,
                  count=1,
                  dtype=np.float32,
                  crs='EPSG:4326',
                  transform=transform) as dst:
    dst.write(dem, 1)

# 保存土地覆盖
with rasterio.open('data/terrain/landcover.tif', 'w',
                  driver='GTiff',
                  height=size,
                  width=size,
                  count=1,
                  dtype=np.int32,
                  crs='EPSG:4326',
                  transform=transform) as dst:
    dst.write(landcover, 1) 
```

### docs/validation_log.md
```
# 轨迹验证工作日志

## 2025-03-28 验证方式一：给定真实路径骨架进行模拟

### 实现思路

1. 从真实轨迹中提取路径骨架
2. 使用路径骨架作为输入,让模拟器生成轨迹
3. 对比模拟轨迹和真实轨迹的动态行为

### 代码实现

1. 修改了`MotionPatternLearner`类:
   - 添加了`learn_from_single_trajectory`方法,支持从单条轨迹学习
   - 简化了初始化参数,移除了对config的依赖
   - 添加了`EnvironmentMaps`数据类来组织环境地图
   - 实现了`generate_environment_maps`方法生成环境地图

2. 修改了`MotionSimulator`类:
   - 添加了经纬度坐标支持
   - 改进了速度控制逻辑
   - 添加了加速度和转向率的计算
   - 实现了基于路径的运动控制

3. 创建了验证脚本`validate_motion_simulation.py`:
   - 实现了轨迹加载和路径骨架提取
   - 实现了从单条轨迹学习运动模式
   - 实现了轨迹模拟和验证过程

### 问题诊断

#### 1. 速度控制完全失控

1. 速度值异常:
   - 模拟速度远超真实速度(RMSE: 163.15 m/s ≈ 600 km/h)
   - 速度变化趋势与真实情况相反(相关系数: -0.99)
   - 总距离差异超过10km

2. 可能的原因:
   - 环境地图中的速度值可能不合理
   - 坡度/坡向影响因子计算或应用可能有误
   - 速度更新逻辑可能跳过了加减速过程
   - 缺乏合理的速度上限约束

#### 2. 转向行为异常

1. 转向控制问题:
   - 转向率RMSE高达187.47°/s
   - 转弯过于剧烈或时机不当
   - 可能缺乏速度与转向的协调

2. 可能的原因:
   - 转向率限制可能未生效
   - 目标朝向计算可能不准确
   - 未考虑速度对转向能力的影响
   - 路径跟随时缺乏预见性减速

#### 3. 动态特征计算问题

1. 数值计算异常:
   - 加速度和转向率出现NaN值
   - 可能存在除零问题
   - 时间步长(dt)可能过小或无效

### 改进方案

#### 1. 速度控制修复(优先级最高)

1. 环境速度图检查:
   ```python
   # 在MotionPatternLearner中添加验证
   def validate_speed_maps(self):
       """验证生成的速度图是否合理"""
       for group in self.env_groups.values():
           if group.typical_speed > 15.0:  # ~54 km/h
               logger.warning(f"组{group.group_label}的典型速度过高: {group.typical_speed:.2f} m/s")
           if group.max_speed > 20.0:      # ~72 km/h
               logger.warning(f"组{group.group_label}的最大速度过高: {group.max_speed:.2f} m/s")
   ```

2. 严格的速度限制:
   ```python
   class MotionSimulator:
       def _calculate_target_speed(self, env_params, slope_effects):
           # 基础目标速度
           target_speed = min(
               env_params['typical_speed'],
               env_params['max_speed']
           )
           
           # 应用坡度影响
           slope_factor = max(0.5, 1.0 - self.config['SLOPE_SPEED_FACTOR'] * 
                            abs(slope_effects['along_path']))
           cross_slope_factor = max(0.5, 1.0 - self.config['CROSS_SLOPE_FACTOR'] * 
                                  abs(slope_effects['cross']))
           
           # 应用地形影响
           target_speed *= slope_factor * cross_slope_factor
           
           # 强制应用绝对速度限制
           return np.clip(target_speed, self.config['MIN_SPEED'], self.config['MAX_SPEED'])
   ```

3. 改进加速度控制:
   ```python
   def _update_speed(self, current_speed, target_speed, dt):
       """更新速度,确保平滑加减速"""
       speed_diff = target_speed - current_speed
       
       # 根据当前速度调整加减速限制
       if speed_diff > 0:
           max_change = min(
               self.config['MAX_ACCELERATION'] * dt,
               0.2 * current_speed  # 限制单次加速不超过当前速度的20%
           )
       else:
           max_change = max(
               -self.config['MAX_DECELERATION'] * dt,
               -0.3 * current_speed  # 限制单次减速不超过当前速度的30%
           )
       
       speed_change = np.clip(speed_diff, -max_change, max_change)
       return current_speed + speed_change
   ```

#### 2. 转向控制改进

1. 速度感知的转向限制:
   ```python
   def _calculate_max_turn_rate(self, speed):
       """根据速度计算最大转向率"""
       # 速度越高,允许的转向率越小
       base_rate = self.config['MAX_TURN_RATE']  # 基础转向率(度/秒)
       speed_factor = 1.0 / (1.0 + speed * 0.2)  # 速度影响因子
       return base_rate * speed_factor
   ```

2. 预见性转弯控制:
   ```python
   def _look_ahead_path_curvature(self, current_pos, path_points, look_ahead=3):
       """计算前方路径的曲率"""
       if len(path_points) < look_ahead + 1:
           return 0.0
           
       points = path_points[:look_ahead+1]
       angles = []
       for i in range(len(points)-2):
           v1 = points[i+1] - points[i]
           v2 = points[i+2] - points[i+1]
           angle = np.arccos(np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2)))
           angles.append(abs(angle))
           
       return max(angles) if angles else 0.0
   ```

#### 3. 调试和验证改进

1. 详细的状态日志:
   ```python
   def _log_simulation_state(self, agent, target, env_params):
       """记录模拟状态"""
       logger.debug(
           f"T={agent.timestamp:.1f} "
           f"Pos=({agent.position[0]:.1f},{agent.position[1]:.1f}) "
           f"Speed={agent.speed:.2f} "
           f"Heading={np.degrees(agent.heading):.1f}° "
           f"Target=({target[0]:.1f},{target[1]:.1f}) "
           f"TypicalSpeed={env_params['typical_speed']:.2f} "
           f"MaxSpeed={env_params['max_speed']:.2f}"
       )
   ```

2. 可视化工具增强:
   ```python
   def plot_trajectory_comparison(real_traj, sim_traj, output_path):
       """绘制轨迹对比图"""
       fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 15))
       
       # 速度对比
       ax1.plot(real_traj['timestamp'], real_traj['speed_mps'], 'b-', label='真实')
       ax1.plot(sim_traj['timestamp'], sim_traj['speed_mps'], 'r--', label='模拟')
       ax1.set_ylabel('速度 (m/s)')
       ax1.legend()
       
       # 加速度对比
       ax2.plot(real_traj['timestamp'], real_traj['acceleration_mps2'], 'b-')
       ax2.plot(sim_traj['timestamp'], sim_traj['acceleration_mps2'], 'r--')
       ax2.set_ylabel('加速度 (m/s²)')
       
       # 转向率对比
       ax3.plot(real_traj['timestamp'], real_traj['turn_rate_dps'], 'b-')
       ax3.plot(sim_traj['timestamp'], sim_traj['turn_rate_dps'], 'r--')
       ax3.set_ylabel('转向率 (°/s)')
       
       plt.savefig(output_path)
   ```

### 下一步工作计划

1. 速度控制修复(第一阶段):
   - 实现并测试速度地图验证功能
   - 添加严格的速度限制逻辑
   - 改进加速度控制机制
   - 验证基本的速度控制效果

2. 转向控制改进(第二阶段):
   - 实现速度感知的转向限制
   - 添加路径预测和曲率计算
   - 完善转弯减速机制
   - 测试各种转向场景

3. 验证系统完善(持续进行):
   - 实现详细的状态日志记录
   - 开发可视化对比工具
   - 建立完整的验证测试集
   - 收集和分析验证数据

### 参考数值

1. 速度相关:
   - 典型速度范围: 2-10 m/s
   - 最大速度: 10-15 m/s
   - 最小速度: 2 m/s
   - 最大加速度: 2.0 m/s²
   - 最大减速度: 3.0 m/s²

2. 转向相关:
   - 最大转向率: 20-30 °/s
   - 转弯减速起始距离: 20m
   - 最小转弯速度: 2 m/s

3. 地形影响:
   - 坡度影响因子: 0.05
   - 横向坡度因子: 0.1
   - 最大允许坡度: 30° 
```

### examples/evaluate_trajectories.py
```python
"""
轨迹评估示例脚本
演示如何使用评估器评估生成轨迹的质量
"""

import logging
from pathlib import Path

from src.utils.config import config
from src.core.evaluator import Evaluator

# 设置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def main():
    """主函数"""
    logger.info("开始轨迹评估示例")
    
    # 创建评估器
    evaluator = Evaluator()
    
    # 加载数据
    logger.info("加载数据...")
    oord_file = config.paths.PROCESSED_OORD_FILE
    synthetic_dir = config.paths.TRAJECTORY_DIR
    
    try:
        evaluator.load_data(oord_file, synthetic_dir)
    except FileNotFoundError as e:
        logger.error(f"找不到数据文件: {e}")
        return
    except ValueError as e:
        logger.error(f"数据加载错误: {e}")
        return
        
    # 执行评估
    logger.info("执行评估...")
    try:
        metrics = evaluator.evaluate()
    except Exception as e:
        logger.error(f"评估过程出错: {e}")
        return
        
    # 输出主要指标
    logger.info("\n主要评估指标:")
    logger.info("-" * 30)
    
    # 速度分布
    logger.info("速度分布:")
    logger.info(f"- KS检验P值: {metrics['speed_ks_p_value']:.4f}")
    logger.info(f"- 平均值差异: {metrics['speed_mean_diff']:.4f} m/s")
    
    # 加速度分布
    logger.info("\n加速度分布:")
    logger.info(f"- KS检验P值: {metrics['acceleration_ks_p_value']:.4f}")
    logger.info(f"- 平均值差异: {metrics['acceleration_mean_diff']:.4f} m/s²")
    
    # 转向率分布
    logger.info("\n转向率分布:")
    logger.info(f"- KS检验P值: {metrics['turn_rate_ks_p_value']:.4f}")
    logger.info(f"- 平均值差异: {metrics['turn_rate_mean_diff']:.4f} 度/秒")
    
    # 环境交互
    if 'mean_group_speed_diff' in metrics:
        logger.info("\n环境交互:")
        logger.info(
            f"- 环境组平均速度差异: {metrics['mean_group_speed_diff']:.4f} m/s"
        )
        
    # 输出文件位置
    logger.info("\n输出文件:")
    logger.info(f"- 评估报告: {evaluator.output_dir}/evaluation_report.txt")
    logger.info(f"- 分布图表: {evaluator.output_dir}/*.png")
    
    logger.info("\n示例完成")

if __name__ == '__main__':
    main() 
```

### examples/generate_trajectory.py
```python
"""
轨迹生成示例脚本
演示如何使用轨迹生成器生成轨迹
"""

import logging
import json
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

from src.utils.config import config
from src.core.terrain import TerrainLoader
from src.core.trajectory import EnvironmentBasedGenerator

# 设置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def plot_trajectory(
        trajectory: dict,
        terrain_loader: TerrainLoader,
        save_path: Path
    ) -> None:
    """
    绘制轨迹
    
    Args:
        trajectory: 轨迹数据
        terrain_loader: 地形加载器
        save_path: 保存路径
    """
    # 创建图形
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 12))
    
    # 绘制轨迹
    x = trajectory['x']
    y = trajectory['y']
    speeds = trajectory['speed']
    
    # 轨迹和速度颜色映射
    points = ax1.scatter(
        x, y,
        c=speeds,
        cmap='viridis',
        s=10
    )
    ax1.plot(x, y, 'k-', alpha=0.3)
    ax1.set_title('轨迹（颜色表示速度）')
    ax1.set_xlabel('X坐标（米）')
    ax1.set_ylabel('Y坐标（米）')
    fig.colorbar(points, ax=ax1, label='速度（米/秒）')
    
    # 绘制速度-时间曲线
    timestamps = np.array(trajectory['timestamp'])
    timestamps = timestamps - timestamps[0]  # 从0开始
    ax2.plot(timestamps, speeds)
    ax2.set_title('速度-时间曲线')
    ax2.set_xlabel('时间（秒）')
    ax2.set_ylabel('速度（米/秒）')
    ax2.grid(True)
    
    # 保存图形
    plt.tight_layout()
    plt.savefig(save_path)
    plt.close()

def main():
    """主函数"""
    logger.info("开始轨迹生成示例")
    
    # 创建地形加载器
    terrain_loader = TerrainLoader()
    
    # 加载地形数据
    logger.info("加载地形数据...")
    terrain_loader.load_dem(config.paths.DEM_FILE)
    terrain_loader.load_landcover(config.paths.LANDCOVER_FILE)
    terrain_loader.load_slope(config.paths.SLOPE_FILE)
    terrain_loader.load_aspect(config.paths.ASPECT_FILE)
    
    # 创建轨迹生成器
    generator = EnvironmentBasedGenerator(
        terrain_loader=terrain_loader,
        dt=config.motion.DT,
        max_waypoints=10,
        min_waypoint_dist=1000.0,
        max_waypoint_dist=5000.0
    )
    
    # 设置起点和终点
    start_point = (0.0, 0.0)
    end_point = (50000.0, 50000.0)
    
    # 生成轨迹
    logger.info("生成轨迹...")
    trajectory = generator.generate_trajectory(
        start_point,
        end_point
    )
    
    # 保存轨迹数据
    output_dir = config.paths.TRAJECTORY_DIR
    output_dir.mkdir(parents=True, exist_ok=True)
    
    trajectory_file = output_dir / "example_trajectory.json"
    with open(trajectory_file, 'w') as f:
        json.dump(trajectory, f, indent=2)
    logger.info(f"轨迹数据已保存至: {trajectory_file}")
    
    # 绘制轨迹
    plot_file = output_dir / "example_trajectory.png"
    plot_trajectory(trajectory, terrain_loader, plot_file)
    logger.info(f"轨迹图形已保存至: {plot_file}")
    
    logger.info("示例完成")

if __name__ == '__main__':
    main() 
```

### main.py
```python
"""主程序入口

用于启动轨迹生成流程，包括参数解析和日志配置。
"""

import argparse
import logging
from pathlib import Path
import json
import sys

from src.generator.batch_generator import BatchGenerator
from config import *

def setup_logging(log_file: str = None):
    """配置日志系统

    Args:
        log_file: 日志文件路径，如果为None则只输出到控制台
    """
    handlers = [logging.StreamHandler()]
    if log_file:
        handlers.append(logging.FileHandler(log_file))

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=handlers
    )

def create_config_json():
    """创建用于批处理的配置JSON文件"""
    config = {
        'output_dir': str(OUTPUT_DIR),
        'dem_path': str(DEM_PATH),
        'landcover_path': str(LANDCOVER_PATH),
        'slope_magnitude_path': str(SLOPE_MAGNITUDE_PATH),
        'slope_aspect_path': str(SLOPE_ASPECT_PATH),
        'NUM_TRAJECTORIES_TO_GENERATE': NUM_TRAJECTORIES_TO_GENERATE,
        'NUM_END_POINTS': NUM_END_POINTS,
        'NUM_TRAJECTORIES_PER_END': NUM_TRAJECTORIES_PER_END,
        'MIN_START_END_DISTANCE_METERS': MIN_START_END_DISTANCE_METERS,
        'URBAN_LANDCOVER_CODES': URBAN_LANDCOVER_CODES,
        'IMPASSABLE_LANDCOVER_CODES': IMPASSABLE_LANDCOVER_CODES,
        'SLOPE_BINS': SLOPE_BINS,
        'LANDCOVER_SPEED_FACTORS': LANDCOVER_SPEED_FACTORS,
        'MOTION_CONSTRAINTS': MOTION_CONSTRAINTS,
        'TERRAIN_CONSTRAINTS': TERRAIN_CONSTRAINTS,
        'BASE_SPEED': BASE_SPEED,
        'MAX_SLOPE': MAX_SLOPE,
        'EVALUATION_METRICS': EVALUATION_METRICS
    }

    config_path = OUTPUT_DIR / 'batch_config.json'
    with open(config_path, 'w') as f:
        json.dump(config, f, indent=4)
    
    return config_path

def main():
    """主函数"""
    parser = argparse.ArgumentParser(description='复杂轨迹生成器')
    parser.add_argument('--log-file', help='日志文件路径')
    args = parser.parse_args()

    # 设置日志
    setup_logging(args.log_file)
    logger = logging.getLogger(__name__)

    try:
        # 检查必要的输入文件
        if not DEM_PATH.exists():
            logger.error(f"DEM文件不存在: {DEM_PATH}")
            sys.exit(1)
        if not LANDCOVER_PATH.exists():
            logger.error(f"土地覆盖文件不存在: {LANDCOVER_PATH}")
            sys.exit(1)

        # 创建配置文件
        config_path = create_config_json()
        logger.info(f"配置文件已创建: {config_path}")

        # 初始化并运行批处理生成器
        generator = BatchGenerator(str(config_path))
        generator.generate_batch()

        logger.info("轨迹生成完成")

    except Exception as e:
        logger.error(f"执行过程中出错: {str(e)}")
        raise

if __name__ == '__main__':
    main() 
```

### plot_style.py
```python
"""
matplotlib作图样式配置文件
将此文件放在项目根目录下，在绘图时导入即可使用统一的样式
"""
import matplotlib.pyplot as plt
import matplotlib as mpl
from pathlib import Path

def setup_style():
    """设置matplotlib的默认样式"""
    # 设置字体路径
    FONT_PATHS = {
        'times': '/usr/share/fonts/truetype/custom/times.ttf',
        'simsun': '/usr/share/fonts/truetype/custom/simsun.ttc'
    }
    
    # 添加字体文件
    for font_path in FONT_PATHS.values():
        if Path(font_path).exists():
            mpl.font_manager.fontManager.addfont(font_path)
    
    # 设置默认参数
    plt.rcParams.update({
        'font.family': ['sans-serif'],
        'font.sans-serif': ['SimSun'],  # 中文默认使用宋体
        'font.serif': ['Times New Roman'],  # 英文默认使用Times New Roman
        'axes.unicode_minus': False,  # 解决负号显示问题
        'font.size': 16,  # 默认字体大小
        'axes.titlesize': 16,
        'axes.labelsize': 16,
        'xtick.labelsize': 16,
        'ytick.labelsize': 16,
        'legend.fontsize': 16,
        'figure.figsize': [8, 6],  # 默认图像大小
        'figure.dpi': 100,  # 默认分辨率
        'savefig.dpi': 300,  # 保存图片的分辨率
        'axes.grid': True,  # 默认显示网格
        'grid.alpha': 0.3,  # 网格透明度
        'grid.linestyle': '--',  # 网格线型
        # 设置数学公式字体
        'mathtext.fontset': 'custom',
        'mathtext.rm': 'Times New Roman',
        'mathtext.it': 'Times New Roman:italic',
        'mathtext.bf': 'Times New Roman:bold',
        'mathtext.sf': 'Times New Roman',
        'mathtext.tt': 'Times New Roman',
        'mathtext.cal': 'Times New Roman',
        'mathtext.default': 'regular'
    })

# 在导入模块时自动设置样式
setup_style() 
```

### plot_test.py
```python
import matplotlib.pyplot as plt
import numpy as np
import sys
from matplotlib.font_manager import FontProperties

def setup_plot_style():
    """设置绘图全局样式"""
    try:
        # 设置字体
        plt.rcParams['font.family'] = ['sans-serif']
        plt.rcParams['font.sans-serif'] = ['Noto Sans CJK SC', 'Noto Serif CJK SC']  # 中文使用Noto字体
        plt.rcParams['axes.unicode_minus'] = False
        plt.rcParams['font.size'] = 16
        print("成功设置字体样式")
    except Exception as e:
        print(f"设置样式时出错: {str(e)}")
        sys.exit(1)

def test_plot():
    """测试绘图函数"""
    try:
        # 设置绘图样式
        setup_plot_style()
        
        # 创建测试数据
        x = np.linspace(0, 10, 100)
        y1 = 1e3 * np.sin(x)
        y2 = 1e-3 * np.cos(x)
        
        print("成功创建测试数据")
        
        # 创建图形
        fig, ax = plt.subplots(figsize=(10, 6))
        
        # 绘制曲线
        ax.plot(x, y1, 'b-', label='正弦曲线')
        ax.plot(x, y2, 'r--', label='余弦曲线')
        
        print("成功绘制曲线")
        
        # 设置标题和标签
        ax.set_title('三角函数测试图', fontsize=16)
        ax.set_xlabel('时间 (s)', fontsize=16)
        ax.set_ylabel('幅值 ($\\times 10^{-3}$)', fontsize=16)
        
        # 设置图例
        ax.legend(fontsize=16)
        
        # 添加网格
        ax.grid(True, linestyle='--', alpha=0.7)
        
        print("正在保存图片...")
        # 保存图片
        plt.savefig('test_figure.png', dpi=300, bbox_inches='tight')
        plt.close()
        print("图片已保存为 test_figure.png")
        
    except Exception as e:
        print(f"绘图过程中出错: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    test_plot() 
```

### project_structure.txt
```
# 项目结构报告
生成时间: 2025-03-28 14:59:38

## 项目结构树
```
├── README.md
├── collect_project_info.py
├── complex_trajectories_generator.egg-info
    ├── SOURCES.txt
    ├── dependency_links.txt
    ├── entry_points.txt
    ├── requires.txt
    ├── top_level.txt
├── config.py
├── main.py
├── plot_style.py
├── plot_test.py
├── readme.md
├── requirements.txt
├── scripts
    ├── create_test_data.py
    ├── generate_environment_maps.py
    ├── select_points.py
    ├── test_evaluator.py
    ├── test_path_planner.py
    ├── test_trajectory_generator.py
    ├── train_motion_patterns.py
├── setup.py
├── src
    ├── __init__.py
    ├── analysis
        ├── __init__.py
        ├── environment_analyzer.py
    ├── config.py
    ├── data_processing
        ├── __init__.py
        ├── data_loader.py
        ├── environment_mapper.py
        ├── motion_pattern_learner.py
        ├── oord_processor.py
        ├── terrain_analyzer.py
        ├── terrain_loader.py
        ├── trajectory_loader.py
    ├── evaluation
        ├── __init__.py
        ├── evaluator.py
    ├── generator
        ├── __init__.py
        ├── batch_generator.py
        ├── config.py
        ├── data_loader.py
        ├── environment_mapper.py
        ├── evaluator.py
        ├── motion_simulator.py
        ├── oord_analyzer.py
        ├── path_planner.py
        ├── point_selector.py
        ├── terrain_analyzer.py
        ├── trajectory_generator.py
    ├── trajectory_generation
        ├── environment_based_generator.py
        ├── path_planner.py
        ├── point_selector.py
        ├── trajectory_generator.py
    ├── utils
        ├── __init__.py
        ├── logging_utils.py
├── test_plot_style.py
├── tests
    ├── __init__.py
    ├── conftest.py
    ├── data_processing
        ├── test_oord_processor.py
        ├── test_terrain_analyzer.py
        ├── test_terrain_loader.py
    ├── trajectory_generation
        ├── test_environment_based_generator.py
    ├── unit
        ├── __init__.py
        ├── test_data_loader.py
        ├── test_environment_analyzer.py
        ├── test_environment_mapper.py
        ├── test_motion_simulator.py
        ├── test_oord_analyzer.py
        ├── test_path_planner.py
        ├── test_point_selector.py
        ├── test_terrain_analyzer.py
        ├── test_trajectory_generator.py
        ├── test_trajectory_loader.py
├── 作图规范.md
```

## 文件内容

### README.md
```
# 复杂轨迹生成器

基于地形和环境约束的复杂轨迹生成系统。

## 功能特点

- 考虑地形（坡度、坡向）影响的轨迹生成
- 支持多种地物类型的速度约束
- 智能的起终点选择
- 基于A*算法的路径规划
- 真实的运动模拟
- 与OORD数据的对比评估

## 系统要求

- Python 3.8+
- GDAL 3.0+
- NumPy
- Pandas
- Matplotlib
- Seaborn
- richdem
- rasterio

## 安装步骤

1. 创建并激活conda环境：

```bash
conda create -n wargame python=3.8
conda activate wargame
```

2. 安装依赖：

```bash
conda install -c conda-forge gdal
conda install -c conda-forge rasterio
conda install numpy pandas matplotlib seaborn
conda install -c conda-forge richdem
```

3. 克隆代码仓库：

```bash
git clone [repository_url]
cd complex_trajectories_generator
```

## 数据准备

在运行系统之前，请准备以下数据：

1. DEM数据（GeoTIFF格式）
   - 分辨率：30m
   - 覆盖范围：100km x 100km
   - 保存路径：`data/input/gis/dem_30m_100km.tif`

2. 土地覆盖数据（GeoTIFF格式）
   - 分辨率：与DEM相同
   - 覆盖范围：与DEM相同
   - 保存路径：`data/input/gis/landcover_30m_100km.tif`
   - 编码说明：
     - 1: 城市
     - 2: 农田
     - 3: 林地
     - 4: 草地
     - 5: 灌木
     - 10: 建成区
     - 11: 水体

## 配置说明

系统的主要配置参数在 `config.py` 文件中：

- 路径配置：输入/输出文件路径
- 轨迹生成参数：数量、距离约束等
- 地物编码和速度因子
- 运动约束参数
- 地形约束参数
- 评估指标设置

## 使用方法

1. 激活conda环境：

```bash
conda activate wargame
```

2. 运行轨迹生成：

```bash
python main.py --log-file logs/generation.log
```

## 输出说明

系统会在 `data/output` 目录下生成以下内容：

1. 中间结果（`intermediate/`）：
   - 坡度图
   - 坡向图
   - 速度图
   - 成本图

2. 生成的轨迹（`synthetic_batch_[timestamp]/`）：
   - 轨迹CSV文件
   - 配置文件副本
   - 评估报告和图表

## 评估报告

评估报告包含以下内容：

1. 全局统计比较：
   - 速度分布
   - 加速度分布
   - 转向率分布

2. 环境交互分析：
   - 不同坡度下的速度分布
   - 不同地物类型的速度分布

## 注意事项

1. 确保输入数据的坐标系统、分辨率和覆盖范围一致
2. 检查磁盘空间是否足够（建议预留10GB）
3. 对于大规模生成，建议调整配置文件中的参数

## 开发团队

- 作者：[作者名]
- 联系方式：[邮箱]

## 许可证

[许可证类型] 
```

### collect_project_info.py
```python
"""
项目信息收集脚本
收集项目根目录下的所有代码文件，并生成项目结构图
"""
import os
from pathlib import Path
import datetime

def get_file_content(file_path):
    """读取文件内容"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"无法读取文件内容: {str(e)}"

def collect_project_info(root_dir='.', output_file='project_structure.txt'):
    """收集项目信息并生成结构图"""
    # 要忽略的目录和文件
    ignore_dirs = {'.git', '__pycache__', '.pytest_cache', '.vscode', '.idea'}
    ignore_files = {'.gitignore', '.DS_Store'}
    
    # 获取所有Python文件和Markdown文件
    code_files = []
    for root, dirs, files in os.walk(root_dir):
        # 忽略特定目录
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        
        for file in files:
            if file in ignore_files:
                continue
                
            if file.endswith(('.py', '.md', '.txt')):
                code_files.append(os.path.join(root, file))
    
    # 生成输出内容
    output = []
    output.append("# 项目结构报告")
    output.append(f"生成时间: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
    
    # 生成目录树
    output.append("## 项目结构树")
    output.append("```")
    current_level = 0
    last_dirs = []
    
    for file_path in sorted(code_files):
        rel_path = os.path.relpath(file_path, root_dir)
        parts = rel_path.split(os.sep)
        
        # 处理目录结构
        for i, part in enumerate(parts[:-1]):
            if i >= len(last_dirs) or part != last_dirs[i]:
                output.append("    " * i + "├── " + part)
                last_dirs = parts[:-1]
        
        # 添加文件
        output.append("    " * (len(parts) - 1) + "├── " + parts[-1])
    
    output.append("```\n")
    
    # 添加文件内容
    output.append("## 文件内容")
    for file_path in sorted(code_files):
        rel_path = os.path.relpath(file_path, root_dir)
        output.append(f"\n### {rel_path}")
        output.append("```" + ("python" if file_path.endswith('.py') else ""))
        output.append(get_file_content(file_path))
        output.append("```")
    
    # 写入文件
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(output))
    
    print(f"项目结构和代码已保存到 {output_file}")

if __name__ == "__main__":
    collect_project_info() 
```

### complex_trajectories_generator.egg-info/SOURCES.txt
```
README.md
setup.py
complex_trajectories_generator.egg-info/PKG-INFO
complex_trajectories_generator.egg-info/SOURCES.txt
complex_trajectories_generator.egg-info/dependency_links.txt
complex_trajectories_generator.egg-info/entry_points.txt
complex_trajectories_generator.egg-info/requires.txt
complex_trajectories_generator.egg-info/top_level.txt
src/__init__.py
src/config.py
src/analysis/__init__.py
src/analysis/environment_analyzer.py
src/data_processing/__init__.py
src/data_processing/data_loader.py
src/data_processing/environment_mapper.py
src/data_processing/motion_pattern_learner.py
src/data_processing/oord_processor.py
src/data_processing/terrain_analyzer.py
src/data_processing/terrain_loader.py
src/data_processing/trajectory_loader.py
src/evaluation/__init__.py
src/evaluation/evaluator.py
src/generator/__init__.py
src/generator/batch_generator.py
src/generator/config.py
src/generator/data_loader.py
src/generator/environment_mapper.py
src/generator/evaluator.py
src/generator/motion_simulator.py
src/generator/oord_analyzer.py
src/generator/path_planner.py
src/generator/point_selector.py
src/generator/terrain_analyzer.py
src/generator/trajectory_generator.py
src/utils/__init__.py
src/utils/logging_utils.py
tests/__init__.py
tests/conftest.py
tests/unit/__init__.py
tests/unit/test_data_loader.py
tests/unit/test_environment_analyzer.py
tests/unit/test_environment_mapper.py
tests/unit/test_motion_simulator.py
tests/unit/test_oord_analyzer.py
tests/unit/test_path_planner.py
tests/unit/test_point_selector.py
tests/unit/test_terrain_analyzer.py
tests/unit/test_trajectory_generator.py
tests/unit/test_trajectory_loader.py
```

### complex_trajectories_generator.egg-info/dependency_links.txt
```


```

### complex_trajectories_generator.egg-info/entry_points.txt
```
[console_scripts]
generate_trajectories = src.main:main

```

### complex_trajectories_generator.egg-info/requires.txt
```
numpy
pandas
scipy
matplotlib
seaborn
rasterio
geopandas
scikit-learn
pathfinding
scikit-image
richdem

```

### complex_trajectories_generator.egg-info/top_level.txt
```
src
tests

```

### config.py
```python
"""配置文件

包含项目所需的所有配置参数和路径设置。

定义环境地图生成器所需的常量和参数。
"""

import os
from pathlib import Path

# 基础路径配置
BASE_DIR = Path(__file__).parent
DATA_DIR = BASE_DIR / 'data'
INPUT_DIR = DATA_DIR / 'input'
OUTPUT_DIR = DATA_DIR / 'output'
INTERMEDIATE_DIR = OUTPUT_DIR / 'intermediate'

# 确保目录存在
for dir_path in [DATA_DIR, INPUT_DIR, OUTPUT_DIR, INTERMEDIATE_DIR]:
    dir_path.mkdir(parents=True, exist_ok=True)

# 输入数据路径
GIS_DIR = INPUT_DIR / 'gis'
OORD_DIR = INPUT_DIR / 'oord'

# GIS数据文件
DEM_PATH = GIS_DIR / 'dem_30m_100km.tif'
LANDCOVER_PATH = GIS_DIR / 'landcover_30m_100km.tif'

# 生成的地形属性文件
SLOPE_MAGNITUDE_PATH = INTERMEDIATE_DIR / 'slope_magnitude_30m_100km.tif'
SLOPE_ASPECT_PATH = INTERMEDIATE_DIR / 'slope_aspect_30m_100km.tif'
DZDX_PATH = INTERMEDIATE_DIR / 'dzdx_30m_100km.tif'
DZDY_PATH = INTERMEDIATE_DIR / 'dzdy_30m_100km.tif'

# 环境地图文件
MAX_SPEED_MAP_PATH = INTERMEDIATE_DIR / 'max_speed_map.tif'
TYPICAL_SPEED_MAP_PATH = INTERMEDIATE_DIR / 'typical_speed_map.tif'
SPEED_STDDEV_MAP_PATH = INTERMEDIATE_DIR / 'speed_stddev_map.tif'
COST_MAP_PATH = INTERMEDIATE_DIR / 'cost_map.tif'

# 轨迹生成参数
NUM_TRAJECTORIES_TO_GENERATE = 500  # 要生成的轨迹总数
NUM_END_POINTS = 3                  # 要选择的固定终点数量
NUM_TRAJECTORIES_PER_END = NUM_TRAJECTORIES_TO_GENERATE // NUM_END_POINTS
MIN_START_END_DISTANCE_METERS = 80000  # 起终点最小直线距离（米）

# 地物编码
URBAN_LANDCOVER_CODES = [1, 10]     # 代表城市/建成区的地物编码
IMPASSABLE_LANDCOVER_CODES = [11]   # 代表绝对不可通行的地物编码（如水体）

# 坡度分组
SLOPE_BINS = [0, 5, 10, 15, 20, 25, 30, 35]  # 坡度分组边界（度）

# 坡度相关参数
MAX_SLOPE_THRESHOLD = 45.0  # 最大可通行坡度（度）
SLOPE_SPEED_FACTOR = 0.05   # 坡度对速度的影响因子
BASE_MAX_SPEED = 5.0        # 基础最大速度（m/s）

# 速度相关参数
TYPICAL_SPEED_FACTOR = 0.7  # 典型速度与最大速度的比例
BASE_SPEED_STDDEV_FACTOR = 0.2  # 基础速度标准差因子

# 坡向相关参数
PREFERRED_DIRECTION = 90.0  # 偏好移动方向（度，东向为90度）
ASPECT_INFLUENCE = 0.2      # 坡向对速度的影响程度

# 坡度对标准差的影响
SLOPE_STDDEV_THRESHOLD = 30.0  # 坡度标准差阈值（度）
SLOPE_STDDEV_FACTOR = 0.5      # 坡度对标准差的影响因子

# 地形复杂度相关
COMPLEX_TERRAIN_CODES = [41, 42, 43]  # 复杂地形的土地覆盖代码
COMPLEX_TERRAIN_STDDEV_FACTOR = 1.5   # 复杂地形对标准差的影响因子

# 土地覆盖类型对速度的影响因子
LANDCOVER_SPEED_FACTORS = {
    11: 1.0,  # 城市建成区
    21: 0.9,  # 农田
    31: 0.8,  # 草地
    41: 0.7,  # 灌木林
    42: 0.6,  # 疏林
    43: 0.5,  # 密林
    51: 0.4,  # 湿地
    61: 0.3,  # 裸地
    71: 0.2   # 沙地
}

# 土地覆盖类型对成本的额外影响因子
LANDCOVER_COST_FACTORS = {
    11: 1.0,  # 城市建成区
    21: 1.2,  # 农田
    31: 1.3,  # 草地
    41: 1.5,  # 灌木林
    42: 1.7,  # 疏林
    43: 2.0,  # 密林
    51: 2.5,  # 湿地
    61: 1.8,  # 裸地
    71: 2.2   # 沙地
}

# 不可通行的土地覆盖类型代码
IMPASSABLE_LANDCOVER_CODES = [81, 82, 83]  # 水体、冰川、建筑物等

# 运动约束参数
MOTION_CONSTRAINTS = {
    'max_acceleration': 2.0,     # 最大加速度 (m/s^2)
    'max_deceleration': 4.0,     # 最大减速度 (m/s^2)
    'max_turn_rate': 45.0,       # 最大转向率 (度/秒)
    'min_speed': 0.0,           # 最小速度 (m/s)
    'time_step': 1.0,           # 模拟时间步长 (秒)
    'max_iterations': 10000,     # 最大迭代次数
    'position_threshold': 0.1    # 位置判断阈值 (m)
}

# 地形约束参数
TERRAIN_CONSTRAINTS = {
    'max_uphill_slope': 30.0,    # 最大上坡坡度 (度)
    'max_downhill_slope': 35.0,  # 最大下坡坡度 (度)
    'max_cross_slope': 25.0,     # 最大横坡坡度 (度)
    'k_uphill': 0.1,            # 上坡减速系数
    'k_downhill': 0.05,         # 下坡加速系数
    'k_cross': 0.2,             # 横坡减速系数
    'min_speed_steep_slope': 0.5 # 陡坡最小速度 (m/s)
}

# 基础运动参数
BASE_SPEED = 10.0               # 基准速度 (m/s)
MAX_SLOPE = 35.0               # 最大可通行坡度 (度)

# 评估参数
EVALUATION_METRICS = {
    'speed_distribution': True,
    'acceleration_distribution': True,
    'turn_rate_distribution': True,
    'slope_speed_relationship': True
} 
```

### main.py
```python
"""主程序入口

用于启动轨迹生成流程，包括参数解析和日志配置。
"""

import argparse
import logging
from pathlib import Path
import json
import sys

from src.generator.batch_generator import BatchGenerator
from config import *

def setup_logging(log_file: str = None):
    """配置日志系统

    Args:
        log_file: 日志文件路径，如果为None则只输出到控制台
    """
    handlers = [logging.StreamHandler()]
    if log_file:
        handlers.append(logging.FileHandler(log_file))

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=handlers
    )

def create_config_json():
    """创建用于批处理的配置JSON文件"""
    config = {
        'output_dir': str(OUTPUT_DIR),
        'dem_path': str(DEM_PATH),
        'landcover_path': str(LANDCOVER_PATH),
        'slope_magnitude_path': str(SLOPE_MAGNITUDE_PATH),
        'slope_aspect_path': str(SLOPE_ASPECT_PATH),
        'NUM_TRAJECTORIES_TO_GENERATE': NUM_TRAJECTORIES_TO_GENERATE,
        'NUM_END_POINTS': NUM_END_POINTS,
        'NUM_TRAJECTORIES_PER_END': NUM_TRAJECTORIES_PER_END,
        'MIN_START_END_DISTANCE_METERS': MIN_START_END_DISTANCE_METERS,
        'URBAN_LANDCOVER_CODES': URBAN_LANDCOVER_CODES,
        'IMPASSABLE_LANDCOVER_CODES': IMPASSABLE_LANDCOVER_CODES,
        'SLOPE_BINS': SLOPE_BINS,
        'LANDCOVER_SPEED_FACTORS': LANDCOVER_SPEED_FACTORS,
        'MOTION_CONSTRAINTS': MOTION_CONSTRAINTS,
        'TERRAIN_CONSTRAINTS': TERRAIN_CONSTRAINTS,
        'BASE_SPEED': BASE_SPEED,
        'MAX_SLOPE': MAX_SLOPE,
        'EVALUATION_METRICS': EVALUATION_METRICS
    }

    config_path = OUTPUT_DIR / 'batch_config.json'
    with open(config_path, 'w') as f:
        json.dump(config, f, indent=4)
    
    return config_path

def main():
    """主函数"""
    parser = argparse.ArgumentParser(description='复杂轨迹生成器')
    parser.add_argument('--log-file', help='日志文件路径')
    args = parser.parse_args()

    # 设置日志
    setup_logging(args.log_file)
    logger = logging.getLogger(__name__)

    try:
        # 检查必要的输入文件
        if not DEM_PATH.exists():
            logger.error(f"DEM文件不存在: {DEM_PATH}")
            sys.exit(1)
        if not LANDCOVER_PATH.exists():
            logger.error(f"土地覆盖文件不存在: {LANDCOVER_PATH}")
            sys.exit(1)

        # 创建配置文件
        config_path = create_config_json()
        logger.info(f"配置文件已创建: {config_path}")

        # 初始化并运行批处理生成器
        generator = BatchGenerator(str(config_path))
        generator.generate_batch()

        logger.info("轨迹生成完成")

    except Exception as e:
        logger.error(f"执行过程中出错: {str(e)}")
        raise

if __name__ == '__main__':
    main() 
```

### plot_style.py
```python
"""
matplotlib作图样式配置文件
将此文件放在项目根目录下，在绘图时导入即可使用统一的样式
"""
import matplotlib.pyplot as plt
import matplotlib as mpl
from pathlib import Path

def setup_style():
    """设置matplotlib的默认样式"""
    # 设置字体路径
    FONT_PATHS = {
        'times': '/usr/share/fonts/truetype/custom/times.ttf',
        'simsun': '/usr/share/fonts/truetype/custom/simsun.ttc'
    }
    
    # 添加字体文件
    for font_path in FONT_PATHS.values():
        if Path(font_path).exists():
            mpl.font_manager.fontManager.addfont(font_path)
    
    # 设置默认参数
    plt.rcParams.update({
        'font.family': ['sans-serif'],
        'font.sans-serif': ['SimSun'],  # 中文默认使用宋体
        'font.serif': ['Times New Roman'],  # 英文默认使用Times New Roman
        'axes.unicode_minus': False,  # 解决负号显示问题
        'font.size': 16,  # 默认字体大小
        'axes.titlesize': 16,
        'axes.labelsize': 16,
        'xtick.labelsize': 16,
        'ytick.labelsize': 16,
        'legend.fontsize': 16,
        'figure.figsize': [8, 6],  # 默认图像大小
        'figure.dpi': 100,  # 默认分辨率
        'savefig.dpi': 300,  # 保存图片的分辨率
        'axes.grid': True,  # 默认显示网格
        'grid.alpha': 0.3,  # 网格透明度
        'grid.linestyle': '--',  # 网格线型
        # 设置数学公式字体
        'mathtext.fontset': 'custom',
        'mathtext.rm': 'Times New Roman',
        'mathtext.it': 'Times New Roman:italic',
        'mathtext.bf': 'Times New Roman:bold',
        'mathtext.sf': 'Times New Roman',
        'mathtext.tt': 'Times New Roman',
        'mathtext.cal': 'Times New Roman',
        'mathtext.default': 'regular'
    })

# 在导入模块时自动设置样式
setup_style() 
```

### plot_test.py
```python
import matplotlib.pyplot as plt
import numpy as np
import sys
from matplotlib.font_manager import FontProperties

def setup_plot_style():
    """设置绘图全局样式"""
    try:
        # 设置字体
        plt.rcParams['font.family'] = ['sans-serif']
        plt.rcParams['font.sans-serif'] = ['Noto Sans CJK SC', 'Noto Serif CJK SC']  # 中文使用Noto字体
        plt.rcParams['axes.unicode_minus'] = False
        plt.rcParams['font.size'] = 16
        print("成功设置字体样式")
    except Exception as e:
        print(f"设置样式时出错: {str(e)}")
        sys.exit(1)

def test_plot():
    """测试绘图函数"""
    try:
        # 设置绘图样式
        setup_plot_style()
        
        # 创建测试数据
        x = np.linspace(0, 10, 100)
        y1 = 1e3 * np.sin(x)
        y2 = 1e-3 * np.cos(x)
        
        print("成功创建测试数据")
        
        # 创建图形
        fig, ax = plt.subplots(figsize=(10, 6))
        
        # 绘制曲线
        ax.plot(x, y1, 'b-', label='正弦曲线')
        ax.plot(x, y2, 'r--', label='余弦曲线')
        
        print("成功绘制曲线")
        
        # 设置标题和标签
        ax.set_title('三角函数测试图', fontsize=16)
        ax.set_xlabel('时间 (s)', fontsize=16)
        ax.set_ylabel('幅值 ($\\times 10^{-3}$)', fontsize=16)
        
        # 设置图例
        ax.legend(fontsize=16)
        
        # 添加网格
        ax.grid(True, linestyle='--', alpha=0.7)
        
        print("正在保存图片...")
        # 保存图片
        plt.savefig('test_figure.png', dpi=300, bbox_inches='tight')
        plt.close()
        print("图片已保存为 test_figure.png")
        
    except Exception as e:
        print(f"绘图过程中出错: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    test_plot() 
```

### readme.md
```
项目：基于 OORD 数据学习与精细环境约束的合成轨迹生成器 (复杂版)

版本: 1.2
日期: 2025-03-27
目标读者: 开发工程师 (需要具备数据分析、GIS处理与模拟基础)

1. 项目概述与目标

目标: 开发一个高级轨迹生成工具，该工具首先从真实轨迹数据集 (OORD) 中学习目标的运动特性及其与环境（DEM、坡度大小、坡度方向、土地覆盖）的交互规律，然后利用这些知识，在更大的地理范围内批量生成具有逼真动态行为的合成轨迹。

核心要求:

数据驱动学习: 从 OORD 数据中量化分析并提取目标在不同环境下的速度、转向等行为模式。

精细环境感知: 生成的轨迹不仅受坡度大小和土地覆盖影响，还必须考虑坡度方向（坡向）与车辆行驶方向的相互作用（如上下坡、横坡行驶），这会动态影响速度和可行性。

批量生成: 能够自动生成指定数量（N条）的轨迹。

特定起终点: 用户指定终点区域特征（如靠近城市），程序自动选择满足距离约束（如>80km）的起点。

可控属性: 轨迹总长度（主要通过起终点选择实现）和平均速度（通过模拟参数和学习结果影响）应大致可控且符合真实性。

动态真实性: 生成的轨迹应体现速度变化、加减速、以及与精细环境匹配的随机性，力求在多维度统计特性上与 OORD 数据相似。

可评估性: 提供量化和可视化方法，用于评估生成的合成轨迹与 OORD 数据的相似度。

最终交付物:

一个或多个 Python 脚本/模块，能执行学习、地图生成、起终点选择、批量轨迹模拟、评估的全流程。

批量的合成轨迹数据文件（如 CSV）。

评估报告（图表和统计数据）。

学习结果和中间地图文件（可选）。

2. 输入数据

GIS 环境数据 (需放置在 data/input/gis/):

dem_30m_100km.tif: 数字高程模型 (WGS 84, ~30m res)。

landcover_30m_100km.tif: 土地覆盖数据 (分类编码, 与 DEM 对齐)。

(新增/计算生成) slope_magnitude_30m_100km.tif: 坡度大小 (单位：度, 从 DEM 计算)。

(新增/计算生成) slope_aspect_30m_100km.tif: 坡度方向/坡向 (单位：度, 北为0, 顺时针, 从 DEM 计算)。

(备选/计算生成) dzdx_30m_100km.tif 和 dzdy_30m_100km.tif: X 和 Y 方向的地形梯度（如果选择使用梯度向量而非坡度+坡向）。

OORD 轨迹数据 (需放置在 data/input/oord/):

多个原始轨迹文件 (如 CSV/GPX，包含时间戳、经纬度坐标)。

配置文件 (config.py):

数据文件路径。

(新增) NUM_TRAJECTORIES_TO_GENERATE: 要生成的轨迹总数 (e.g., 500)。

(新增) NUM_END_POINTS: 要选择的固定终点数量 (e.g., 3)。

(新增) MIN_START_END_DISTANCE_METERS: 起终点最小直线距离 (e.g., 80000)。

(新增) URBAN_LANDCOVER_CODES: 代表城市/建成区的地物编码列表 (e.g., [1, 10])。

(新增) IMPASSABLE_LANDCOVER_CODES: 代表绝对不可通行的地物编码列表 (e.g., [11], 水体)。

坡度离散化区间 (SLOPE_BINS)。

模拟参数 (dt, MAX_ACCELERATION, MAX_DECELERATION)。

(新增) 车辆稳定性参数 (可选，如最大允许横坡坡度 MAX_CROSS_SLOPE_DEGREES)。

输出目录路径。

3. 输出数据

核心输出 (放置在 data/output/synthetic_batch_XXX/):

trajectory_1.csv, trajectory_2.csv, ..., trajectory_N.csv: 每个文件包含一条完整的合成轨迹 (timestamp, row, col, lon, lat, speed_mps, heading_degrees)。

评估输出 (放置在 data/output/evaluation_report_XXX/):

.png 图表文件：全局/分组运动参数分布对比图。

.log 或 .txt 文件：统计量比较、K-S 检验结果等。

中间/学习结果 (可选，放置在 data/output/intermediate/):

学习到的规则/模型 (learned_params.pkl 或 .json)。

增强的环境地图 (max_speed_map.tif, typical_speed_map.tif, speed_stddev_map.tif, cost_map.tif)。 注意：这里的速度图主要基于坡度大小学习。

计算出的坡度/坡向/梯度图 (如果不在输入中提供)。

4. 技术栈与依赖库 (保持 V1.0 推荐)

Python 3.x, rasterio, numpy, pandas, geopandas, scipy, scikit-learn (可选), pathfinding/skimage.graph, matplotlib, seaborn, logging。

(新增/可选) richdem 或其他库用于更高效的地形属性计算。

5. 详细实现步骤

阶段 0: 初始化与配置

设置环境: 创建虚拟环境并安装所有依赖。

配置管理 (config.py): 定义所有路径、参数、阈值。

日志设置: 配置 logging 模块记录详细信息。

阶段 1: 数据准备与地形分析 (扩展)

加载 GIS 数据: 使用 rasterio 加载 DEM, Landcover。记录元数据。处理 NoData。

计算地形属性 (关键补充):

计算坡度大小 (Slope Magnitude): 从 DEM 计算每个像素的坡度（度）。保存为 slope_magnitude_30m_100km.tif。

计算坡向 (Slope Aspect): 从 DEM 计算每个像素的坡向（度，北为0，顺时针）。处理平坦区域（通常坡向设为 -1 或特定值）。保存为 slope_aspect_30m_100km.tif。

(备选) 计算梯度: 使用 numpy.gradient 或类似方法计算 dz/dx 和 dz/dy。保存为 dzdx...tif, dzdy...tif。

工具: 可使用 gdaldem 命令行工具、rasterio 配合 numpy 或 richdem 库。确保输出与 DEM 对齐。

加载与预处理 OORD 数据:

同 V1.0 指南：读取、统一坐标系、计算瞬时速度、朝向、转向率、加速度。

将地理坐标转换为像素坐标 (row, col)。

存储为包含 timestamp, row, col, lon, lat, speed_mps, heading, turn_rate_dps, acceleration_mps2, trajectory_id 的 DataFrame。

阶段 2: 学习运动特性与环境交互 (可选增强)

关联环境信息:

遍历处理后的 OORD DataFrame。

查询并添加对应的 elevation, slope_magnitude, slope_aspect (或 dzdx, dzdy), landcover。

定义环境分组:

主要依据：landcover 和 离散化的 slope_magnitude 等级。

创建环境组标签 group_label = f"LC{lc_code}_S{slope_mag_label}"。

分组统计分析 (基于坡度大小):

按 group_label 分组。

计算各组的速度 (mean, median, std, max/quantile), 转向率, 加速度统计量。

建立环境-运动规则/模型 (查找表或拟合函数):

目标：确定各组的 MaxSpeed_learned, TypicalSpeed_learned, SpeedStdDev_learned 等 (主要反映坡度大小和地物影响)。

处理数据不足的组。

保存学习结果。

(高级/可选) 学习坡向影响:

在每个 OORD 点，计算其行驶方向 (heading) 与地形坡向 (aspect) 的关系，得到 slope_along_path_oord 和 cross_slope_oord。

尝试分析 OORD 速度与这两个方向性坡度指标的关系（可能需要更复杂的模型，如分段回归或基于规则的分析）。这可以用于直接指导模拟阶段的速度调整函数 f 和 g，而非仅基于设定的规则。

阶段 3: 构建增强的环境地图

初始化地图数组: 创建 max_speed_map, typical_speed_map, speed_stddev_map, cost_map (以及加载或确认 slope_magnitude_map, slope_aspect_map, dzdx_map, dzdy_map 已准备好)。

像素级计算 (速度图):

遍历栅格，获取 landcover_value, slope_magnitude_value。

确定 group_label。

从阶段 2 学习结果查询或计算得到 max_s, typ_s, std_s (主要基于坡度大小)。

填充 max_speed_map, typical_speed_map, speed_stddev_map。

计算成本图 (cost_map for A - 简化方案):*

基于 typical_speed_map (坡度大小影响) 计算成本：cost = pixel_size / typical_speed (如果 typical_speed > 0)。不可通行区域成本设为 np.inf。

注意: 这个成本图主要反映基于坡度大小和地物的平均通行难度，用于简化 A* 规划。

(可选) 保存所有生成的地图。

阶段 4: 批量起终点选择 (新增)

(移至此处或作为独立模块 point_selector.py)

实现 select_start_end_pairs 函数 (参考补丁 V1.1 描述):

加载 landcover_array。

根据 URBAN_LANDCOVER_CODES 随机选择 NUM_END_POINTS 个不同的、可通行的终点 selected_end_points。

对于每个 end_point，循环随机选择候选起点 start_point_cand：

检查起点可通行性 (is_accessible)。

计算与 end_point 的直线距离 (使用像素大小)。

如果距离 > MIN_START_END_DISTANCE_METERS，接受该起点，将其与 end_point 配对，加入 generation_pairs 列表。

持续此过程，直到为所有终点找到足够数量的起点，达到 NUM_TRAJECTORIES_TO_GENERATE 的目标。

记录选择过程和结果。

返回 generation_pairs 列表 [(start1, end1), (start2, end2), ...]。

阶段 5: 批量合成轨迹生成 (核心模拟，包含坡向逻辑)

(移至此处或作为主控脚本 batch_generator.py)

主循环: 遍历 generation_pairs 列表中的每一对 (start_point, end_point)。

5.1 路径规划 (A) - 简化方案:*

输入: start_point, end_point, 以及阶段 3 生成的 基于坡度大小的 cost_map。

运行 A* 找到最低成本路径 path = [(r0, c0), ..., (rn, cn)]。

如果找不到路径，记录错误并跳过当前对。

5.2 Agent-Based 运动模拟 (时间步进 - 关键修改):

初始化: Agent 状态 (pos, speed=0, heading, time=0), 轨迹列表, 路径索引。设置 dt。

模拟循环 (直到接近终点):

获取当前环境参数:

根据 agent_pos 查询 max_speed_map, typical_speed_map, speed_stddev_map 得到 base_max_s, base_typ_s, base_std_s (基于坡度大小)。

查询坡度方向信息: 查询 slope_magnitude_map, slope_aspect_map (或 dzdx_map, dzdy_map) 得到 current_slope_mag, current_aspect (或 current_dzdx, current_dzdy)。

计算方向性坡度指标:

获取 Agent 当前朝向 current_heading (度)。

计算 delta_angle = current_heading - current_aspect (处理角度环绕)。

slope_along_path = current_slope_mag * cos(radians(delta_angle))

cross_slope = current_slope_mag * abs(sin(radians(delta_angle)))

(备选) 使用梯度: heading_vector = (sin(radians(h)), cos(radians(h))), slope_vector = (current_dzdx, current_dzdy). slope_along_path = dot(heading_vector, slope_vector) / ||slope_vector|| (如果需要单位坡度)。计算横坡需要更复杂的向量运算。

动态调整速度约束 (核心修改):

max_speed_adjusted = base_max_s # 初始值

target_speed_base = base_typ_s + np.random.normal(0, base_std_s) # 基础目标+随机性

应用坡度方向约束 (示例规则):

reduction_factor_uphill = max(0.1, 1 - k_uphill * max(0, slope_along_path)) # 上坡减速

reduction_factor_downhill = 1 + k_downhill * max(0, -slope_along_path) # 下坡可能轻微加速，但需上限

reduction_factor_cross = max(0.05, 1 - k_cross * cross_slope**2) # 横坡急剧减速 (平方项更敏感)

max_speed_adjusted *= reduction_factor_uphill * reduction_factor_cross

target_speed_adjusted = target_speed_base * reduction_factor_uphill * reduction_factor_cross

(重要) max_speed_adjusted = np.clip(max_speed_adjusted, 0, MAX_BRAKING_LIMITED_SPEED_ON_DOWNHILL) # 下坡制动限制

(重要) if cross_slope > MAX_CROSS_SLOPE_DEGREES: max_speed_adjusted = min(max_speed_adjusted, VERY_LOW_SPEED) # 超过横坡阈值极大限速

target_speed = np.clip(target_speed_adjusted, 0, max_speed_adjusted) # 最终目标速度

应用加速度限制: 计算 accel_needed, 限制 actual_accel, 更新 next_speed。

最终速度约束: next_speed = np.clip(next_speed, 0, max_speed_adjusted)。

确定目标朝向: 指向下一个路径点 path[path_index]。

应用转向限制 (可选): 基于学习或设定的转向率限制。更新 next_heading。

更新位置: delta_dist = next_speed * dt, 计算 next_pos。

更新 Agent 状态, 更新时间, 记录轨迹点。

路径点切换 & 终止条件。

5.3 (可选) 验证与迭代: 检查生成轨迹的长度和平均速度。注意：引入坡向约束后，实际平均速度可能低于仅基于坡度大小的预期。

5.4 保存轨迹: 将生成的 trajectory 列表保存为唯一的 CSV 文件到批处理输出目录。

记录日志: 详细记录每条轨迹的生成过程和结果。

阶段 6: 评估 (新增)

(作为独立模块 evaluator.py 或脚本)

加载数据: 实现 load_synthetic_data 加载指定批次目录的所有轨迹；实现 load_processed_oord_data 加载处理好的 OORD 数据 (确保包含所需列，包括 group_label 如果要做环境交互比较)。

执行比较:

全局统计比较: 调用 compare_global_distributions 比较 speed_mps, acceleration_mps2, turn_rate_dps 等的分布 (KDE图, 统计量, K-S检验)。

环境交互比较: 调用 compare_environment_interaction 按 group_label (基于地物和坡度大小) 比较 speed_mps 分布。

(可选/较难) 局部路径比较: 实现 compare_local_segments，选择 OORD 片段，强制模拟器跟随路径，比较速度剖面。

可视化检查: 随机抽取几条合成轨迹与 OORD 轨迹叠加在 DEM/Slope/Landcover 地图上进行目视检查，特别关注在不同坡向下的行为是否合理。

保存报告: 将图表和统计结果保存到评估输出目录。

6. 代码结构与最佳实践

模块化: data_loader.py, terrain_analyzer.py (新增), oord_analyzer.py, environment_mapper.py, point_selector.py (新增), path_planner.py, simulator.py (核心修改), evaluator.py (新增), batch_generator.py (或修改 main.py), config.py, utils.py。

配置分离: 所有参数放入 config.py。

测试: 对地形分析、点选择、模拟器核心逻辑（特别是速度调整部分）、评估函数编写单元/集成测试。

文档 & 日志: 详细 README，清晰 Docstrings，注释复杂逻辑（如坡向约束规则），使用 logging 记录过程。

版本控制 (Git)。

7. 潜在挑战与注意事项 (更新)

OORD 数据质量与代表性。

坡向学习的复杂度: 从 OORD 中可靠地学习坡向影响可能需要大量高质量数据和复杂模型。初期可先依赖基于物理直觉的规则。

方向性 A* 的复杂度: 如果简化 A* 方案导致路径选择不佳，实现方向感知的 A* 会显著增加计算成本和实现难度。

模拟参数调优: dt, 加速度限制, 以及新增的坡向影响因子 (k_uphill, k_cross 等) 和阈值 (MAX_CROSS_SLOPE_DEGREES) 需要仔细调整和验证。

像素级模拟精度。

评估指标的解释: K-S 检验在高样本量下易显著；应更关注分布形状和关键统计量的接近程度。可视化非常重要。

这份 V1.2 指南整合了我们讨论的所有要点，为开发一个更真实、功能更完善的合成轨迹生成器提供了详细的蓝图。实施时建议逐步进行，先确保地形分析和模拟器中坡向逻辑的基础实现，再完善批量处理和评估部分。

注意激活wargame虚拟环境再运行。
```

### requirements.txt
```
# 核心依赖
numpy>=1.20.0
pandas>=1.3.0
matplotlib>=3.4.0
seaborn>=0.11.0
rasterio>=1.2.0
richdem>=0.3.4
gdal>=3.0.0
scipy>=1.7.0
pathlib>=1.0.1
typing>=3.7.4
logging>=0.5.1.2
argparse>=1.4.0

# 测试依赖
pytest>=6.2.0
pytest-cov>=2.12.0

# 开发工具
black>=21.5b2
flake8>=3.9.0
isort>=5.9.0 
```

### scripts/create_test_data.py
```python
 
```

### scripts/generate_environment_maps.py
```python
"""
环境地图生成脚本
根据地形数据和学习到的运动模式生成增强的环境地图
"""

import logging
from pathlib import Path

from src.data_processing import TerrainLoader, EnvironmentMapper
from src.utils.logging_utils import setup_logging

def main():
    # 设置日志
    setup_logging()
    logger = logging.getLogger(__name__)
    logger.info("开始生成环境地图")
    
    # 加载地形数据
    logger.info("加载地形数据...")
    terrain_loader = TerrainLoader()
    terrain_loader.load_dem("data/input/gis/dem_30m_100km.tif")
    terrain_loader.load_landcover("data/input/gis/landcover_30m_100km.tif")
    
    # 加载学习到的运动模式
    logger.info("加载运动模式...")
    import pickle
    with open("data/output/intermediate/learned_patterns.pkl", 'rb') as f:
        motion_patterns = pickle.load(f)
    
    # 创建环境地图生成器
    mapper = EnvironmentMapper(
        terrain_loader=terrain_loader,
        motion_patterns=motion_patterns,
        output_dir="data/output/intermediate"
    )
    
    try:
        # 生成地图
        mapper.generate_maps()
        logger.info("环境地图生成完成")
        
    except Exception as e:
        logger.error(f"地图生成失败: {str(e)}")
        raise

if __name__ == "__main__":
    main() 
```

### scripts/select_points.py
```python
"""
使用PointSelector选择轨迹的起终点对
"""

import json
import logging
from pathlib import Path

import yaml

from src.data_processing import TerrainLoader
from src.trajectory_generation import PointSelector
from src.utils.logging_utils import setup_logging

def main():
    # 设置日志
    setup_logging(
        log_file='logs/point_selection.log',
        log_level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    # 加载配置
    with open('config/point_selection.yaml', 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    
    # 创建输出目录
    output_dir = Path('data/output/points')
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # 加载地形数据
    terrain_loader = TerrainLoader(
        dem_file='data/input/gis/dem_30m_100km.tif',
        landcover_file='data/input/gis/landcover_30m_100km.tif'
    )
    
    # 创建点选择器
    selector = PointSelector(terrain_loader, config)
    
    try:
        # 选择起终点对
        point_pairs = selector.select_points()
        
        # 保存结果
        output_file = output_dir / 'selected_points.json'
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(point_pairs, f, indent=2)
        logger.info(f"已保存选择的起终点对到: {output_file}")
        
        # 可视化结果
        vis_file = output_dir / 'points_visualization.png'
        selector.visualize_points(str(vis_file))
        
    except Exception as e:
        logger.error(f"选择起终点对时出错: {e}")
        raise

if __name__ == '__main__':
    main() 
```

### scripts/test_evaluator.py
```python
"""
测试轨迹评估器功能
"""

import logging
from pathlib import Path
import json
import pandas as pd
import numpy as np

from src.evaluation import Evaluator
from src.utils.logging_utils import setup_logging

def main():
    # 设置日志
    setup_logging(
        log_file='logs/evaluation.log',
        log_level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    # 创建输出目录
    output_dir = Path('data/output/evaluation')
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # 加载OORD数据
    logger.info("加载OORD数据...")
    oord_data = pd.read_csv(
        'data/output/intermediate/processed_oord_data.csv'
    )
    
    # 加载生成的轨迹数据
    logger.info("加载生成的轨迹数据...")
    trajectories = []
    group_labels_list = []
    
    # 从trajectory_generation目录加载所有轨迹
    traj_dir = Path('data/output/trajectory_generation')
    for traj_file in traj_dir.glob('trajectory_*.json'):
        with open(traj_file, 'r') as f:
            traj_data = json.load(f)
            trajectories.append(traj_data)
            
            # 如果有环境组标签文件，也加载它
            group_file = traj_file.parent / f"{traj_file.stem}_groups.json"
            if group_file.exists():
                with open(group_file, 'r') as gf:
                    group_labels = json.load(gf)
                    group_labels_list.append(group_labels)
    
    if not trajectories:
        logger.error("未找到生成的轨迹数据")
        return
    
    # 创建评估器
    evaluator = Evaluator(
        oord_data=oord_data,
        output_dir=str(output_dir)
    )
    
    # 评估单条轨迹
    logger.info("评估第一条轨迹...")
    single_result = evaluator.evaluate_trajectory(
        trajectories[0],
        group_labels_list[0] if group_labels_list else None
    )
    
    # 评估所有轨迹
    logger.info("评估所有轨迹...")
    batch_results = evaluator.evaluate_batch(
        trajectories,
        group_labels_list if group_labels_list else None
    )
    
    # 绘制分布对比图
    logger.info("生成分布对比图...")
    evaluator.plot_distributions(trajectories)
    
    # 生成评估报告
    logger.info("生成评估报告...")
    evaluator.generate_report(
        batch_results,
        output_dir / 'evaluation_report.md'
    )
    
    logger.info("评估完成")
    logger.info(f"评估结果已保存到: {output_dir}")

if __name__ == "__main__":
    main() 
```

### scripts/test_path_planner.py
```python
"""
测试路径规划器功能
"""

import logging
from pathlib import Path
import pickle
import matplotlib.pyplot as plt
import numpy as np
import json

from src.data_processing import TerrainLoader, EnvironmentMapper
from src.trajectory_generation import PathPlanner
from src.utils.logging_utils import setup_logging

def main():
    # 设置日志
    setup_logging(
        log_file='logs/path_planning.log',
        log_level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    # 创建输出目录
    output_dir = Path('data/output/path_planning')
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # 加载地形数据
    logger.info("加载地形数据...")
    terrain_loader = TerrainLoader()
    terrain_loader.load_dem("data/input/gis/dem_30m_100km.tif")
    terrain_loader.load_landcover("data/input/gis/landcover_30m_100km.tif")
    
    # 加载学习到的运动模式
    logger.info("加载运动模式...")
    with open("data/output/intermediate/learned_patterns.pkl", 'rb') as f:
        motion_patterns = pickle.load(f)
    
    # 创建环境地图生成器
    mapper = EnvironmentMapper(
        terrain_loader=terrain_loader,
        motion_patterns=motion_patterns,
        output_dir="data/output/intermediate"
    )
    
    # 生成环境地图
    mapper.generate_maps()
    
    # 创建路径规划器
    planner = PathPlanner(
        terrain_loader=terrain_loader,
        environment_mapper=mapper,
        config={}
    )
    
    # 加载测试用的起终点对
    with open("data/output/points/selected_points.json", 'r') as f:
        point_pairs = json.load(f)
    
    # 选择第一对点进行测试
    start_coord, end_coord = point_pairs[0]
    
    # 转换为像素坐标
    start_point = terrain_loader.transform_coordinates(
        start_coord[0],
        start_coord[1]
    )
    end_point = terrain_loader.transform_coordinates(
        end_coord[0],
        end_coord[1]
    )
    
    # 规划路径
    logger.info("开始路径规划...")
    path = planner.plan_path(start_point, end_point)
    
    if path is None:
        logger.error("未找到有效路径")
        return
    
    # 平滑路径
    smoothed_path = planner.smooth_path(path)
    
    # 可视化结果
    plt.figure(figsize=(15, 10))
    
    # 绘制成本图
    plt.imshow(
        np.log(planner.cost_map + 1),
        cmap='YlOrRd',
        alpha=0.7
    )
    plt.colorbar(label='Log(Cost + 1)')
    
    # 绘制原始路径
    path_array = np.array(path)
    plt.plot(
        path_array[:, 1],
        path_array[:, 0],
        'b-',
        label='Original Path',
        alpha=0.5
    )
    
    # 绘制平滑路径
    smoothed_array = np.array(smoothed_path)
    plt.plot(
        smoothed_array[:, 1],
        smoothed_array[:, 0],
        'g-',
        label='Smoothed Path',
        linewidth=2
    )
    
    # 标记起终点
    plt.plot(
        start_point[1],
        start_point[0],
        'go',
        label='Start',
        markersize=10
    )
    plt.plot(
        end_point[1],
        end_point[0],
        'ro',
        label='End',
        markersize=10
    )
    
    plt.title('Path Planning Result')
    plt.legend()
    
    # 保存结果
    output_file = output_dir / 'path_planning_test.png'
    plt.savefig(output_file)
    logger.info(f"已保存可视化结果到: {output_file}")
    plt.close()
    
    # 输出路径统计信息
    path_length = len(path)
    smoothed_length = len(smoothed_path)
    total_cost = sum(planner.cost_map[r, c] for r, c in path)
    smoothed_cost = sum(planner.cost_map[r, c] for r, c in smoothed_path)
    
    logger.info("\n=== 路径统计 ===")
    logger.info(f"原始路径长度: {path_length} 点")
    logger.info(f"平滑路径长度: {smoothed_length} 点")
    logger.info(f"原始路径总成本: {total_cost:.2f}")
    logger.info(f"平滑路径总成本: {smoothed_cost:.2f}")

if __name__ == "__main__":
    main() 
```

### scripts/test_trajectory_generator.py
```python
"""
测试轨迹生成器功能
"""

import logging
from pathlib import Path
import pickle
import json
import matplotlib.pyplot as plt
import numpy as np

from src.data_processing import TerrainLoader, EnvironmentMapper
from src.trajectory_generation import PathPlanner, TrajectoryGenerator
from src.utils.logging_utils import setup_logging

def main():
    # 设置日志
    setup_logging(
        log_file='logs/trajectory_generation.log',
        log_level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    # 创建输出目录
    output_dir = Path('data/output/trajectory_generation')
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # 加载地形数据
    logger.info("加载地形数据...")
    terrain_loader = TerrainLoader()
    terrain_loader.load_dem("data/input/gis/dem_30m_100km.tif")
    terrain_loader.load_landcover("data/input/gis/landcover_30m_100km.tif")
    
    # 加载学习到的运动模式
    logger.info("加载运动模式...")
    with open("data/output/intermediate/learned_patterns.pkl", 'rb') as f:
        motion_patterns = pickle.load(f)
    
    # 创建环境地图生成器
    mapper = EnvironmentMapper(
        terrain_loader=terrain_loader,
        motion_patterns=motion_patterns,
        output_dir="data/output/intermediate"
    )
    
    # 生成环境地图
    mapper.generate_maps()
    
    # 创建路径规划器
    planner = PathPlanner(
        terrain_loader=terrain_loader,
        environment_mapper=mapper,
        config={}
    )
    
    # 创建轨迹生成器
    generator_config = {
        'dt': 0.1,  # 时间步长（秒）
        'MAX_ACCELERATION': 2.0,  # 最大加速度（米/秒²）
        'MAX_DECELERATION': 3.0,  # 最大减速度（米/秒²）
        'MAX_SPEED': 20.0,  # 最大速度（米/秒）
        'MIN_SPEED': 0.1  # 最小速度（米/秒）
    }
    
    generator = TrajectoryGenerator(
        terrain_loader=terrain_loader,
        environment_mapper=mapper,
        config=generator_config
    )
    
    # 加载测试用的起终点对
    with open("data/output/points/selected_points.json", 'r') as f:
        point_pairs = json.load(f)
    
    # 选择第一对点进行测试
    start_coord, end_coord = point_pairs[0]
    
    # 转换为像素坐标
    start_point = terrain_loader.transform_coordinates(
        start_coord[0],
        start_coord[1]
    )
    end_point = terrain_loader.transform_coordinates(
        end_coord[0],
        end_coord[1]
    )
    
    # 规划路径
    logger.info("开始路径规划...")
    path = planner.plan_path(start_point, end_point)
    
    if path is None:
        logger.error("未找到有效路径")
        return
    
    # 生成轨迹
    logger.info("开始生成轨迹...")
    trajectory = generator.generate_trajectory(path)
    
    # 可视化结果
    plt.figure(figsize=(15, 10))
    
    # 绘制地形
    plt.imshow(
        terrain_loader.dem_data,
        cmap='terrain',
        alpha=0.7
    )
    plt.colorbar(label='Elevation (m)')
    
    # 绘制轨迹
    positions = np.array(trajectory['positions'])
    plt.plot(
        positions[:, 1],
        positions[:, 0],
        'g-',
        label='Trajectory',
        linewidth=2
    )
    
    # 标记起终点
    plt.plot(
        start_point[1],
        start_point[0],
        'go',
        label='Start',
        markersize=10
    )
    plt.plot(
        end_point[1],
        end_point[0],
        'ro',
        label='End',
        markersize=10
    )
    
    plt.title('Generated Trajectory')
    plt.legend()
    
    # 保存轨迹图
    output_file = output_dir / 'trajectory_test.png'
    plt.savefig(output_file)
    logger.info(f"已保存轨迹图到: {output_file}")
    plt.close()
    
    # 绘制速度曲线
    plt.figure(figsize=(12, 6))
    plt.plot(
        trajectory['timestamps'],
        trajectory['speeds'],
        'b-',
        label='Speed'
    )
    plt.grid(True)
    plt.xlabel('Time (s)')
    plt.ylabel('Speed (m/s)')
    plt.title('Speed Profile')
    plt.legend()
    
    # 保存速度图
    output_file = output_dir / 'speed_profile.png'
    plt.savefig(output_file)
    logger.info(f"已保存速度图到: {output_file}")
    plt.close()
    
    # 输出轨迹统计信息
    total_time = trajectory['timestamps'][-1]
    total_distance = sum(
        np.sqrt(
            sum((a - b)**2 for a, b in zip(p1, p2))
        ) * terrain_loader.resolution
        for p1, p2 in zip(
            trajectory['positions'][:-1],
            trajectory['positions'][1:]
        )
    )
    avg_speed = total_distance / total_time
    max_speed = max(trajectory['speeds'])
    min_speed = min(trajectory['speeds'])
    
    logger.info("\n=== 轨迹统计 ===")
    logger.info(f"总时间: {total_time:.2f} 秒")
    logger.info(f"总距离: {total_distance:.2f} 米")
    logger.info(f"平均速度: {avg_speed:.2f} 米/秒")
    logger.info(f"最大速度: {max_speed:.2f} 米/秒")
    logger.info(f"最小速度: {min_speed:.2f} 米/秒")
    
    # 保存轨迹数据
    output_file = output_dir / 'trajectory_test.json'
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump({
            'timestamps': trajectory['timestamps'],
            'coordinates': trajectory['coordinates'],
            'speeds': trajectory['speeds'],
            'headings': trajectory['headings']
        }, f, indent=2)
    logger.info(f"已保存轨迹数据到: {output_file}")

if __name__ == "__main__":
    main() 
```

### scripts/train_motion_patterns.py
```python
"""
运动模式学习脚本
从OORD数据中学习目标在不同环境下的运动特性
"""

import logging
import os
from pathlib import Path

import numpy as np
import pandas as pd

from src.data_processing import TerrainLoader, OORDProcessor, MotionPatternLearner
from src.utils.logging_utils import setup_logging

def main():
    # 设置日志
    setup_logging()
    logger = logging.getLogger(__name__)
    logger.info("开始运动模式学习")
    
    # 创建输出目录
    output_dir = Path("data/output/intermediate")
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # 加载地形数据
    logger.info("加载地形数据...")
    terrain_loader = TerrainLoader()
    terrain_loader.load_dem("data/input/gis/dem_30m_100km.tif")
    terrain_loader.load_landcover("data/input/gis/landcover_30m_100km.tif")
    
    # 加载OORD轨迹数据
    logger.info("加载OORD轨迹数据...")
    oord_processor = OORDProcessor(terrain_loader)
    trajectories = []
    
    oord_dir = Path("data/input/oord")
    for file in oord_dir.glob("*.csv"):
        try:
            traj = oord_processor.load_trajectory(file)
            if traj is not None and len(traj) > 0:
                trajectories.append(traj)
                logger.info(f"成功加载轨迹: {file.name}")
            else:
                logger.warning(f"轨迹为空: {file.name}")
        except Exception as e:
            logger.error(f"加载轨迹失败 {file.name}: {str(e)}")
    
    if not trajectories:
        logger.error("未找到有效的轨迹数据")
        return
    
    logger.info(f"共加载 {len(trajectories)} 条轨迹")
    
    # 创建运动模式学习器
    logger.info("开始学习运动模式...")
    learner = MotionPatternLearner(terrain_loader)
    
    try:
        # 执行学习
        learner.learn_from_trajectories(trajectories)
        
        # 保存学习结果
        output_file = output_dir / "learned_patterns.pkl"
        learner.save_patterns(str(output_file))
        logger.info(f"学习结果已保存到: {output_file}")
        
        # 输出学习结果摘要
        patterns = learner.get_learned_patterns()
        
        logger.info("\n=== 学习结果摘要 ===")
        
        # 坡度-速度关系
        slope_speed = patterns['slope_speed_model']
        logger.info("\n坡度-速度关系:")
        logger.info(f"平地速度(0-5度): {slope_speed.iloc[0]['mean']:.2f} m/s")
        logger.info(f"速度因子范围: {slope_speed['speed_factor'].min():.2f} - {slope_speed['speed_factor'].max():.2f}")
        
        # 地表类型-速度关系
        landcover_speed = patterns['landcover_speed_stats']
        logger.info("\n地表类型-速度关系:")
        for lc_type, stats in landcover_speed.iterrows():
            logger.info(f"类型 {lc_type}: 平均速度 = {stats['mean']:.2f} m/s, 速度因子 = {stats['speed_factor']:.2f}")
        
        # 转向率统计
        turn_rate = patterns['turn_rate_stats']
        logger.info("\n转向率统计:")
        logger.info(f"平均值: {turn_rate['mean']:.2f} rad/s")
        logger.info(f"标准差: {turn_rate['std']:.2f} rad/s")
        logger.info(f"90百分位: {turn_rate['percentiles']['90']:.2f} rad/s")
        
        # 加速度统计
        accel = patterns['acceleration_stats']
        logger.info("\n加速度统计:")
        logger.info(f"平均值: {accel['mean']:.2f} m/s²")
        logger.info(f"标准差: {accel['std']:.2f} m/s²")
        logger.info(f"90百分位: {accel['percentiles']['90']:.2f} m/s²")
        
        # 环境聚类
        clusters = patterns['environment_clusters']
        logger.info(f"\n环境聚类 (k={clusters['n_clusters']}):")
        for i, stats in enumerate(clusters['cluster_stats']):
            logger.info(f"\n簇 {i+1}:")
            logger.info(f"样本数: {stats['size']}")
            logger.info(f"平均坡度: {stats['slope_mean']:.1f}° (±{stats['slope_std']:.1f}°)")
            logger.info(f"主要地表类型: {stats['landcover_mode']}")
            logger.info(f"平均速度: {stats['speed_mean']:.2f} m/s (±{stats['speed_std']:.2f} m/s)")
        
    except Exception as e:
        logger.error(f"学习过程失败: {str(e)}")
        raise
    
    logger.info("运动模式学习完成")

if __name__ == "__main__":
    main() 
```

### setup.py
```python
"""安装配置文件"""

from setuptools import setup, find_packages

with open("README.md", "r", encoding="utf-8") as fh:
    long_description = fh.read()

with open("requirements.txt", "r", encoding="utf-8") as fh:
    requirements = [line.strip() for line in fh if line.strip() and not line.startswith("#")]

setup(
    name="complex_trajectories_generator",
    version="0.1",
    author="作者名",
    author_email="邮箱",
    description="基于地形和环境约束的复杂轨迹生成系统",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/username/complex_trajectories_generator",
    packages=find_packages(),
    classifiers=[
        "Development Status :: 3 - Alpha",
        "Intended Audience :: Science/Research",
        "Topic :: Scientific/Engineering :: GIS",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3.8",
        "Operating System :: OS Independent",
    ],
    python_requires=">=3.8",
    install_requires=[
        "numpy",
        "pandas",
        "scipy",
        "matplotlib",
        "seaborn",
        "rasterio",
        "geopandas",
        "scikit-learn",
        "pathfinding",
        "scikit-image",
        "richdem"
    ],
    entry_points={
        "console_scripts": [
            "generate_trajectories=src.main:main",
        ],
    },
) 
```

### src/__init__.py
```python
"""
复杂轨迹生成器项目
基于OORD数据学习与环境约束的合成轨迹生成
"""

__version__ = "1.0.0" 
```

### src/analysis/__init__.py
```python
"""
分析模块
包含环境分析、轨迹学习和模型拟合相关的功能
"""

from .environment_analyzer import EnvironmentAnalyzer

__all__ = ['EnvironmentAnalyzer'] 
```

### src/analysis/environment_analyzer.py
```python
"""
环境分析模块
负责分析OORD轨迹在不同环境条件（坡度、土地覆盖）下的运动特征
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import pandas as pd
from scipy import stats
from sklearn.preprocessing import KBinsDiscretizer

from ..config import SLOPE_BINS, SLOPE_LABELS
from ..data_processing import GISDataLoader, TrajectoryLoader

# 配置日志
logger = logging.getLogger(__name__)

class EnvironmentAnalyzer:
    """环境分析器，用于学习轨迹与环境的关系"""
    
    def __init__(self, gis_loader: GISDataLoader):
        """
        初始化环境分析器
        
        Args:
            gis_loader: 已加载GIS数据的GISDataLoader实例
        """
        self.gis_loader = gis_loader
        self.environment_stats: Dict[str, Dict] = {}  # 存储环境-运动特征统计
        self.speed_models: Dict[str, Dict] = {}  # 存储环境组的速度模型
    
    def analyze_trajectory(self, trajectory_df: pd.DataFrame) -> pd.DataFrame:
        """
        分析单条轨迹的环境特征
        
        Args:
            trajectory_df: 预处理后的轨迹DataFrame
            
        Returns:
            enriched_df: 添加了环境信息的DataFrame
        """
        df = trajectory_df.copy()
        
        # 获取轨迹点的像素坐标
        pixel_coords = np.array([
            self.gis_loader.get_pixel_coords(lon, lat)
            for lon, lat in zip(df['longitude'], df['latitude'])
        ])
        
        # 添加环境信息
        df['elevation'] = [
            self.gis_loader.get_elevation(row, col)
            for row, col in pixel_coords
        ]
        
        df['slope'] = [
            self.gis_loader.get_slope(row, col)
            for row, col in pixel_coords
        ]
        
        df['landcover'] = [
            self.gis_loader.get_landcover(row, col)
            for row, col in pixel_coords
        ]
        
        # 添加坡度等级
        df['slope_class'] = pd.cut(
            df['slope'],
            bins=SLOPE_BINS,
            labels=SLOPE_LABELS,
            include_lowest=True
        ).astype(str).str.replace('S', '')  # 移除'S'前缀，只保留数字
        
        # 创建环境组标签
        df['environment_group'] = df.apply(
            lambda x: f"LC{int(x['landcover'])}_SS{x['slope_class']}", 
            axis=1
        )
        
        return df
    
    def analyze_all_trajectories(self, processed_trajectories: Dict[str, pd.DataFrame]) -> Dict[str, pd.DataFrame]:
        """
        分析所有轨迹的环境特征
        
        Args:
            processed_trajectories: 预处理后的轨迹字典
            
        Returns:
            enriched_trajectories: 添加了环境信息的轨迹字典
        """
        enriched_trajectories = {}
        for traj_id, df in processed_trajectories.items():
            try:
                enriched_df = self.analyze_trajectory(df)
                enriched_trajectories[traj_id] = enriched_df
                logger.info(f"完成轨迹 {traj_id} 的环境分析")
            except Exception as e:
                logger.error(f"分析轨迹 {traj_id} 时出错: {str(e)}")
                continue
        
        return enriched_trajectories
    
    def compute_environment_statistics(self, enriched_trajectories: Dict[str, pd.DataFrame]) -> Dict[str, Dict]:
        """
        计算不同环境条件下的运动特征统计
        
        Args:
            enriched_trajectories: 添加了环境信息的轨迹字典
            
        Returns:
            environment_stats: 环境-运动特征统计字典
        """
        # 合并所有轨迹数据
        all_data = pd.concat(enriched_trajectories.values(), ignore_index=True)
        
        # 按环境组进行分组统计
        grouped = all_data.groupby('environment_group')
        
        for group_name, group_data in grouped:
            # 计算速度统计量
            speed_stats = {
                'mean': group_data['speed'].mean(),
                'std': group_data['speed'].std(),
                'median': group_data['speed'].median(),
                'q25': group_data['speed'].quantile(0.25),
                'q75': group_data['speed'].quantile(0.75),
                'max': group_data['speed'].quantile(0.95),  # 使用95分位数作为最大速度
                'min': group_data['speed'].quantile(0.05)   # 使用5分位数作为最小速度
            }
            
            # 计算转向率统计量
            turn_rate_stats = {
                'mean': group_data['turn_rate'].mean(),
                'std': group_data['turn_rate'].std(),
                'median': group_data['turn_rate'].median(),
                'max': abs(group_data['turn_rate']).quantile(0.95)
            }
            
            # 计算加速度统计量
            accel_stats = {
                'mean': group_data['acceleration'].mean(),
                'std': group_data['acceleration'].std(),
                'max_accel': group_data['acceleration'].quantile(0.95),
                'max_decel': abs(group_data['acceleration'].quantile(0.05))
            }
            
            # 存储该环境组的统计结果
            self.environment_stats[group_name] = {
                'speed': speed_stats,
                'turn_rate': turn_rate_stats,
                'acceleration': accel_stats,
                'sample_size': len(group_data)
            }
        
        logger.info(f"完成 {len(self.environment_stats)} 个环境组的统计分析")
        return self.environment_stats
    
    def fit_speed_models(self, enriched_trajectories: Dict[str, pd.DataFrame], min_samples: int = 10) -> Dict[str, Dict]:
        """
        为每个环境组拟合速度分布模型
        
        Args:
            enriched_trajectories: 添加了环境信息的轨迹字典
            min_samples: 拟合模型所需的最小样本数量
            
        Returns:
            speed_models: 环境组的速度模型字典
        """
        # 合并所有轨迹数据
        all_data = pd.concat(enriched_trajectories.values(), ignore_index=True)
        
        # 按环境组拟合速度分布
        for group_name, group_data in all_data.groupby('environment_group'):
            speeds = group_data['speed'].dropna().values
            
            if len(speeds) < min_samples:  # 样本太少，跳过拟合
                logger.warning(f"环境组 {group_name} 样本数量不足 ({len(speeds)})")
                continue
            
            try:
                # 尝试拟合多个分布，选择最佳拟合
                distributions = ['norm', 'gamma', 'lognorm']
                best_dist = None
                best_params = None
                best_kstest = float('inf')
                
                for dist_name in distributions:
                    # 拟合分布
                    params = getattr(stats, dist_name).fit(speeds)
                    # 进行KS检验
                    ks_statistic, _ = stats.kstest(speeds, dist_name, params)
                    
                    if ks_statistic < best_kstest:
                        best_dist = dist_name
                        best_params = params
                        best_kstest = ks_statistic
                
                self.speed_models[group_name] = {
                    'distribution': best_dist,
                    'parameters': best_params,
                    'ks_statistic': best_kstest
                }
                
                logger.info(f"环境组 {group_name} 速度分布拟合完成，使用 {best_dist} 分布")
                
            except Exception as e:
                logger.error(f"拟合环境组 {group_name} 的速度分布时出错: {str(e)}")
                continue
        
        return self.speed_models
    
    def get_environment_group_stats(self, landcover: int, slope: float) -> Optional[Dict]:
        """
        获取指定环境条件下的统计信息
        
        Args:
            landcover: 土地覆盖类型
            slope: 坡度值
            
        Returns:
            stats: 该环境组的统计信息，如果没有找到则返回None
        """
        # 将坡度值转换为坡度等级
        slope_class = pd.cut(
            [slope], 
            bins=SLOPE_BINS, 
            labels=SLOPE_LABELS, 
            include_lowest=True
        )[0].replace('S', '')  # 移除'S'前缀，只保留数字
        
        # 构建环境组标签
        group_name = f"LC{int(landcover)}_SS{slope_class}"
        
        if group_name not in self.environment_stats:
            logger.warning(f"环境组 {group_name} 没有统计数据")
            return None
            
        return self.environment_stats[group_name]
    
    def sample_speed(self, landcover: int, slope: float) -> float:
        """
        根据环境条件采样合理的速度值
        
        Args:
            landcover: 土地覆盖类型编码
            slope: 坡度值（度）
            
        Returns:
            speed: 采样的速度值（米/秒）
        """
        # 确定坡度等级
        slope_class = pd.cut(
            [slope], 
            bins=SLOPE_BINS, 
            labels=SLOPE_LABELS, 
            include_lowest=True
        )[0].replace('S', '')  # 移除'S'前缀，只保留数字
        
        # 构建环境组标签
        group_name = f"LC{int(landcover)}_SS{slope_class}"
        
        if group_name in self.speed_models:
            model = self.speed_models[group_name]
            dist = getattr(stats, model['distribution'])
            speed = dist.rvs(*model['parameters'])
            
            # 确保速度在合理范围内
            stats = self.environment_stats[group_name]['speed']
            speed = np.clip(speed, stats['min'], stats['max'])
            
            return float(speed)
        else:
            # 如果没有该环境组的模型，返回一个基于统计的速度
            if group_name in self.environment_stats:
                stats = self.environment_stats[group_name]['speed']
                return float(np.random.normal(stats['mean'], stats['std']))
            else:
                logger.warning(f"环境组 {group_name} 没有速度模型和统计数据")
                return 5.0  # 返回一个默认的合理速度值 
```

### src/config.py
```python
"""
项目配置文件
包含所有重要的常量、路径和参数设置
"""

import os
from pathlib import Path

# 项目根目录
PROJECT_ROOT = Path(__file__).parent.parent.absolute()

# 数据路径
DATA_DIR = PROJECT_ROOT / "data"
RAW_DATA_DIR = DATA_DIR / "raw"
PROCESSED_DATA_DIR = DATA_DIR / "processed"
CORE_TRAJECTORIES_DIR = DATA_DIR / "core_trajectories"

# GIS数据路径
DEM_DIR = RAW_DATA_DIR / "dem"
LANDCOVER_DIR = RAW_DATA_DIR / "landcover"

# 输出路径
OUTPUT_DIR = PROJECT_ROOT / "output"
FIGURES_DIR = OUTPUT_DIR / "figures"
RESULTS_DIR = OUTPUT_DIR / "results"

# 确保必要的目录存在
for dir_path in [PROCESSED_DATA_DIR, OUTPUT_DIR, FIGURES_DIR, RESULTS_DIR]:
    os.makedirs(dir_path, exist_ok=True)

# 分析参数
SLOPE_BINS = [-float('inf'), 5, 10, 15, 20, 25, 30, float('inf')]  # 坡度分级边界值
SLOPE_LABELS = [f"S{i}" for i in range(len(SLOPE_BINS)-1)]  # 坡度等级标签

# 模拟参数
SIMULATION_DT = 1.0  # 模拟时间步长（秒）
MAX_ACCELERATION = 2.0  # 最大加速度 (m/s^2)
MAX_DECELERATION = 4.0  # 最大减速度 (m/s^2)
MAX_TURN_RATE = 45.0  # 最大转向率 (度/秒)

# 轨迹生成约束
TARGET_LENGTH_RANGE = (80_000, 120_000)  # 目标轨迹长度范围（米）
DEFAULT_TARGET_SPEED = 30.0  # 默认目标平均速度（km/h）

# 随机种子（用于复现结果）
RANDOM_SEED = 42

# 轨迹数据列
TRAJECTORY_COLUMNS = [
    'timestamp',      # 时间戳
    'longitude',      # 经度
    'latitude',       # 纬度
    'elevation',      # 海拔高度（米）
    'speed',         # 速度（米/秒）
    'heading',       # 航向角（度）
    'turn_rate',     # 转向率（度/秒）
    'acceleration'   # 加速度（米/秒²）
] 
```

### src/data_processing/__init__.py
```python
"""
数据处理模块
包含地形数据加载、地形分析和OORD数据处理功能
"""

from .terrain_loader import TerrainLoader
from .terrain_analyzer import TerrainAnalyzer
from .oord_processor import OORDProcessor

__all__ = ['TerrainLoader', 'TerrainAnalyzer', 'OORDProcessor'] 
```

### src/data_processing/data_loader.py
```python
"""
数据加载模块
负责加载和预处理GIS数据（DEM、坡度、土地覆盖）和OORD轨迹数据
"""

import logging
from pathlib import Path
from typing import Tuple, Union

import numpy as np
import pandas as pd
import rasterio
from rasterio.transform import rowcol

from ..config import DEM_DIR, LANDCOVER_DIR

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class GISDataLoader:
    """GIS数据加载器，用于加载和处理DEM、坡度和土地覆盖数据"""
    
    def __init__(self):
        self.dem = None
        self.slope = None
        self.landcover = None
        self.transform = None
        self.crs = None
        self.nodata = None
    
    def load_dem(self, dem_path: Union[str, Path]) -> np.ndarray:
        """
        加载DEM数据
        
        Args:
            dem_path: DEM文件路径
            
        Returns:
            dem_data: DEM数组
        """
        try:
            with rasterio.open(dem_path) as src:
                self.dem = src.read(1)  # 读取第一个波段
                self.transform = src.transform
                self.crs = src.crs
                self.nodata = src.nodata
                logger.info(f"成功加载DEM数据，形状: {self.dem.shape}")
                return self.dem
        except Exception as e:
            logger.error(f"加载DEM数据失败: {str(e)}")
            raise
    
    def load_slope(self, slope_path: Union[str, Path]) -> np.ndarray:
        """
        加载坡度数据
        
        Args:
            slope_path: 坡度文件路径
            
        Returns:
            slope_data: 坡度数组
        """
        try:
            with rasterio.open(slope_path) as src:
                self.slope = src.read(1)
                # 验证与DEM的一致性
                if self.dem is not None:
                    assert self.slope.shape == self.dem.shape, "坡度数据与DEM形状不一致"
                logger.info(f"成功加载坡度数据，形状: {self.slope.shape}")
                return self.slope
        except Exception as e:
            logger.error(f"加载坡度数据失败: {str(e)}")
            raise
    
    def load_landcover(self, landcover_path: Union[str, Path]) -> np.ndarray:
        """
        加载土地覆盖数据
        
        Args:
            landcover_path: 土地覆盖文件路径
            
        Returns:
            landcover_data: 土地覆盖数组
        """
        try:
            with rasterio.open(landcover_path) as src:
                self.landcover = src.read(1)
                # 验证与DEM的一致性
                if self.dem is not None:
                    assert self.landcover.shape == self.dem.shape, "土地覆盖数据与DEM形状不一致"
                logger.info(f"成功加载土地覆盖数据，形状: {self.landcover.shape}")
                return self.landcover
        except Exception as e:
            logger.error(f"加载土地覆盖数据失败: {str(e)}")
            raise
    
    def get_pixel_coords(self, lon: float, lat: float) -> Tuple[int, int]:
        """
        将地理坐标转换为像素坐标
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            (row, col): 像素坐标元组
        """
        if self.transform is None:
            raise ValueError("未加载GIS数据，无法进行坐标转换")
        
        row, col = rowcol(self.transform, lon, lat)
        return row, col
    
    def get_elevation(self, row: int, col: int) -> float:
        """获取指定像素位置的高程值"""
        if self.dem is None:
            raise ValueError("未加载DEM数据")
        return self.dem[row, col]
    
    def get_slope(self, row: int, col: int) -> float:
        """获取指定像素位置的坡度值"""
        if self.slope is None:
            raise ValueError("未加载坡度数据")
        return self.slope[row, col]
    
    def get_landcover(self, row: int, col: int) -> int:
        """获取指定像素位置的土地覆盖类型"""
        if self.landcover is None:
            raise ValueError("未加载土地覆盖数据")
        return self.landcover[row, col] 
```

### src/data_processing/environment_mapper.py
```python
"""
环境地图生成器
根据地形数据和学习结果构建增强的环境地图
"""

import logging
from pathlib import Path
from typing import Dict, Optional

import numpy as np
import rasterio
from rasterio.transform import Affine

from .terrain_analyzer import TerrainAnalyzer
from .terrain_loader import TerrainLoader

logger = logging.getLogger(__name__)

class EnvironmentMapper:
    """环境地图生成器"""
    
    def __init__(
            self,
            terrain_loader: TerrainLoader,
            motion_patterns: Dict,
            output_dir: str = "data/output/intermediate"
        ):
        """
        初始化环境地图生成器
        
        Args:
            terrain_loader: 地形数据加载器实例
            motion_patterns: 学习到的运动模式
            output_dir: 输出目录
        """
        self.terrain_loader = terrain_loader
        self.terrain_analyzer = TerrainAnalyzer(terrain_loader)
        self.motion_patterns = motion_patterns
        self.output_dir = Path(output_dir)
        
        # 确保输出目录存在
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # 初始化地图数组
        shape = terrain_loader.dem_data.shape
        self.max_speed_map = np.zeros(shape, dtype=np.float32)
        self.typical_speed_map = np.zeros(shape, dtype=np.float32)
        self.speed_stddev_map = np.zeros(shape, dtype=np.float32)
        self.cost_map = np.zeros(shape, dtype=np.float32)
    
    def generate_maps(self) -> None:
        """生成所有环境地图"""
        logger.info("开始生成环境地图...")
        
        # 获取地形属性
        rows, cols = self.terrain_loader.dem_data.shape
        for row in range(rows):
            for col in range(cols):
                # 获取地理坐标
                lon, lat = self.terrain_loader.transform_pixel_to_coord(row, col)
                
                # 获取地形属性
                terrain_attrs = self.terrain_analyzer.get_terrain_attributes(lon, lat)
                landcover = self.terrain_loader.get_landcover(lon, lat)
                
                # 计算速度特征
                max_s, typ_s, std_s = self._calculate_speed_features(
                    terrain_attrs['slope_magnitude'],
                    landcover
                )
                
                # 更新地图
                self.max_speed_map[row, col] = max_s
                self.typical_speed_map[row, col] = typ_s
                self.speed_stddev_map[row, col] = std_s
                
                # 计算成本（基于典型速度）
                if typ_s > 0:
                    self.cost_map[row, col] = self.terrain_loader.resolution / typ_s
                else:
                    self.cost_map[row, col] = np.inf
        
        logger.info("环境地图生成完成")
        
        # 保存地图
        self._save_maps()
    
    def _calculate_speed_features(
            self,
            slope_magnitude: float,
            landcover: int
        ) -> tuple[float, float, float]:
        """
        计算给定位置的速度特征
        
        Args:
            slope_magnitude: 坡度大小(度)
            landcover: 地表类型编码
            
        Returns:
            tuple: (最大速度, 典型速度, 速度标准差)
        """
        # 获取坡度速度模型
        slope_speed = self.motion_patterns['slope_speed_model']
        
        # 找到对应的坡度组
        for (lower, upper), row in slope_speed.iterrows():
            if lower <= slope_magnitude < upper:
                slope_factor = row['speed_factor']
                break
        else:
            slope_factor = slope_speed.iloc[-1]['speed_factor']  # 使用最陡坡度组的因子
        
        # 获取地表类型速度统计
        landcover_stats = self.motion_patterns['landcover_speed_stats']
        if landcover in landcover_stats.index:
            lc_stats = landcover_stats.loc[landcover]
            lc_factor = lc_stats['speed_factor']
            speed_std = lc_stats['std']
        else:
            lc_factor = 0.5  # 默认因子
            speed_std = landcover_stats['std'].mean()  # 使用平均标准差
        
        # 计算速度特征
        base_speed = 20.0  # 基准速度 (m/s)
        max_speed = base_speed * slope_factor * lc_factor
        typical_speed = max_speed * 0.8  # 典型速度略低于最大速度
        
        return max_speed, typical_speed, speed_std
    
    def _save_maps(self) -> None:
        """保存生成的地图"""
        # 准备元数据
        meta = self.terrain_loader.get_raster_meta()
        
        # 保存最大速度图
        self._save_raster(
            self.max_speed_map,
            self.output_dir / "max_speed_map.tif",
            meta,
            "最大速度图 (m/s)"
        )
        
        # 保存典型速度图
        self._save_raster(
            self.typical_speed_map,
            self.output_dir / "typical_speed_map.tif",
            meta,
            "典型速度图 (m/s)"
        )
        
        # 保存速度标准差图
        self._save_raster(
            self.speed_stddev_map,
            self.output_dir / "speed_stddev_map.tif",
            meta,
            "速度标准差图 (m/s)"
        )
        
        # 保存成本图
        self._save_raster(
            self.cost_map,
            self.output_dir / "cost_map.tif",
            meta,
            "成本图 (s/m)"
        )
        
        logger.info("已保存所有环境地图")
    
    def _save_raster(
            self,
            data: np.ndarray,
            filepath: Path,
            meta: Dict,
            description: str
        ) -> None:
        """
        保存栅格数据
        
        Args:
            data: 栅格数据
            filepath: 保存路径
            meta: 元数据
            description: 数据描述
        """
        meta = meta.copy()
        meta.update({
            'dtype': 'float32',
            'description': description
        })
        
        with rasterio.open(filepath, 'w', **meta) as dst:
            dst.write(data, 1)
        logger.info(f"已保存 {description} 到: {filepath}")
    
    def get_maps(self) -> Dict[str, np.ndarray]:
        """
        获取生成的地图
        
        Returns:
            Dict: 包含所有生成的地图
        """
        return {
            'max_speed_map': self.max_speed_map,
            'typical_speed_map': self.typical_speed_map,
            'speed_stddev_map': self.speed_stddev_map,
            'cost_map': self.cost_map
        } 
```

### src/data_processing/motion_pattern_learner.py
```python
"""
运动模式学习器
从OORD数据中学习目标在不同环境下的运动特性
"""

import logging
from typing import Dict, List, Optional, Tuple

import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

from .terrain_analyzer import TerrainAnalyzer
from .terrain_loader import TerrainLoader

logger = logging.getLogger(__name__)

class MotionPatternLearner:
    """运动模式学习器"""
    
    def __init__(self, terrain_loader: TerrainLoader):
        """
        初始化运动模式学习器
        
        Args:
            terrain_loader: 地形数据加载器实例
        """
        self.terrain_loader = terrain_loader
        self.terrain_analyzer = TerrainAnalyzer(terrain_loader)
        
        # 学习结果
        self.learned_patterns = {
            'slope_speed_model': None,          # 坡度-速度关系模型
            'slope_direction_model': None,      # 坡向-速度关系模型
            'landcover_speed_stats': None,      # 地表类型-速度统计
            'turn_rate_stats': None,            # 转向率统计
            'acceleration_stats': None,         # 加速度统计
            'environment_clusters': None        # 环境分类结果
        }
        
        # 环境分组参数
        self.env_params = {
            'slope_bins': [0, 5, 15, 30, 90],   # 坡度分组边界
            'direction_bins': [-180, -135, -90, -45, 0, 45, 90, 135, 180],  # 相对坡向分组
            'min_samples': 100                   # 每组最小样本数
        }
    
    def learn_from_trajectories(self, trajectories: List[pd.DataFrame]) -> None:
        """
        从轨迹数据中学习运动模式
        
        Args:
            trajectories: OORD轨迹数据列表
        """
        logger.info("开始从%d条轨迹中学习运动模式", len(trajectories))
        
        # 合并所有轨迹数据
        combined_data = self._preprocess_trajectories(trajectories)
        
        # 学习各种运动模式
        self._learn_slope_speed_relation(combined_data)
        self._learn_slope_direction_effect(combined_data)
        self._learn_landcover_speed_relation(combined_data)
        self._learn_turn_rate_patterns(combined_data)
        self._learn_acceleration_patterns(combined_data)
        self._cluster_environments(combined_data)
        
        logger.info("运动模式学习完成")
    
    def _preprocess_trajectories(self, trajectories: List[pd.DataFrame]) -> pd.DataFrame:
        """
        预处理轨迹数据，添加环境特征
        
        Args:
            trajectories: 轨迹数据列表
            
        Returns:
            pd.DataFrame: 处理后的数据
        """
        processed_data = []
        
        for traj in trajectories:
            # 计算基本运动特征
            traj = traj.copy()
            traj['speed'] = np.sqrt(
                traj['velocity_north_ms']**2 + 
                traj['velocity_east_ms']**2
            )
            traj['acceleration'] = np.sqrt(
                traj['acceleration_x_ms2']**2 + 
                traj['acceleration_y_ms2']**2 + 
                traj['acceleration_z_ms2']**2
            )
            traj['turn_rate'] = np.sqrt(
                traj['angular_velocity_x_rads']**2 + 
                traj['angular_velocity_y_rads']**2 + 
                traj['angular_velocity_z_rads']**2
            )
            
            # 计算行进方向（航向角）
            traj['heading'] = np.degrees(np.arctan2(
                traj['velocity_east_ms'],
                traj['velocity_north_ms']
            ))
            traj['heading'] = np.where(traj['heading'] < 0, 
                                     traj['heading'] + 360,
                                     traj['heading'])
            
            # 添加环境特征
            for idx, row in traj.iterrows():
                terrain_attrs = self.terrain_analyzer.get_terrain_attributes(
                    row['longitude'],
                    row['latitude']
                )
                traj.loc[idx, 'slope_magnitude'] = terrain_attrs['slope_magnitude']
                traj.loc[idx, 'slope_aspect'] = terrain_attrs['slope_aspect']
                traj.loc[idx, 'landcover'] = self.terrain_loader.get_landcover(
                    row['longitude'],
                    row['latitude']
                )
            
            # 计算相对坡向（行进方向与坡向的夹角）
            traj['relative_aspect'] = traj['heading'] - traj['slope_aspect']
            traj['relative_aspect'] = np.where(
                traj['relative_aspect'] > 180,
                traj['relative_aspect'] - 360,
                traj['relative_aspect']
            )
            traj['relative_aspect'] = np.where(
                traj['relative_aspect'] < -180,
                traj['relative_aspect'] + 360,
                traj['relative_aspect']
            )
            
            processed_data.append(traj)
        
        return pd.concat(processed_data, ignore_index=True)
    
    def _learn_slope_speed_relation(self, data: pd.DataFrame) -> None:
        """学习坡度与速度的关系"""
        # 按坡度分组统计速度
        slope_speed = data.groupby(pd.cut(
            data['slope_magnitude'],
            bins=self.env_params['slope_bins']
        ))['speed'].agg(['mean', 'std', 'count'])
        
        # 过滤掉样本数不足的组
        slope_speed = slope_speed[slope_speed['count'] >= self.env_params['min_samples']]
        
        # 计算速度因子（相对于平地速度的比例）
        flat_speed = slope_speed.iloc[0]['mean']  # 第一组（0-5度）作为基准
        slope_speed['speed_factor'] = slope_speed['mean'] / flat_speed
        
        self.learned_patterns['slope_speed_model'] = slope_speed
    
    def _learn_slope_direction_effect(self, data: pd.DataFrame) -> None:
        """学习坡向对速度的影响"""
        # 按相对坡向和坡度大小分组
        direction_groups = data.groupby([
            pd.cut(data['relative_aspect'], 
                  bins=self.env_params['direction_bins']),
            pd.cut(data['slope_magnitude'],
                  bins=self.env_params['slope_bins'])
        ])
        
        # 统计每组的速度特征
        direction_speed = direction_groups['speed'].agg(['mean', 'std', 'count'])
        
        # 过滤样本数不足的组
        direction_speed = direction_speed[
            direction_speed['count'] >= self.env_params['min_samples']
        ]
        
        # 计算速度影响因子
        flat_forward_speed = direction_speed.xs(
            (slice(-45, 45), slice(0, 5)),  # 平地前向组
            level=[0, 1]
        )['mean'].mean()
        
        direction_speed['speed_factor'] = direction_speed['mean'] / flat_forward_speed
        
        self.learned_patterns['slope_direction_model'] = direction_speed
    
    def _learn_landcover_speed_relation(self, data: pd.DataFrame) -> None:
        """学习地表类型与速度的关系"""
        # 按地表类型分组统计
        landcover_speed = data.groupby('landcover')['speed'].agg([
            'mean', 'std', 'min', 'max', 'count'
        ])
        
        # 过滤样本数不足的组
        landcover_speed = landcover_speed[
            landcover_speed['count'] >= self.env_params['min_samples']
        ]
        
        # 计算速度因子
        road_speed = landcover_speed.loc[1]['mean']  # 假设1为道路类型
        landcover_speed['speed_factor'] = landcover_speed['mean'] / road_speed
        
        self.learned_patterns['landcover_speed_stats'] = landcover_speed
    
    def _learn_turn_rate_patterns(self, data: pd.DataFrame) -> None:
        """学习转向率模式"""
        # 计算转向率统计特征
        turn_rate_stats = {
            'mean': float(data['turn_rate'].mean()),
            'std': float(data['turn_rate'].std()),
            'percentiles': {
                '50': float(data['turn_rate'].quantile(0.5)),
                '75': float(data['turn_rate'].quantile(0.75)),
                '90': float(data['turn_rate'].quantile(0.9)),
                '95': float(data['turn_rate'].quantile(0.95)),
                '99': float(data['turn_rate'].quantile(0.99))
            }
        }
        
        self.learned_patterns['turn_rate_stats'] = turn_rate_stats
    
    def _learn_acceleration_patterns(self, data: pd.DataFrame) -> None:
        """学习加速度模式"""
        # 计算加速度统计特征
        acceleration_stats = {
            'mean': float(data['acceleration'].mean()),
            'std': float(data['acceleration'].std()),
            'percentiles': {
                '50': float(data['acceleration'].quantile(0.5)),
                '75': float(data['acceleration'].quantile(0.75)),
                '90': float(data['acceleration'].quantile(0.9)),
                '95': float(data['acceleration'].quantile(0.95)),
                '99': float(data['acceleration'].quantile(0.99))
            }
        }
        
        self.learned_patterns['acceleration_stats'] = acceleration_stats
    
    def _cluster_environments(self, data: pd.DataFrame) -> None:
        """
        对环境特征进行聚类分析
        用于发现典型的环境组合模式
        """
        # 准备特征
        features = ['slope_magnitude', 'relative_aspect', 'landcover']
        X = data[features].copy()
        
        # 标准化
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)
        
        # K-means聚类
        n_clusters = 5  # 可以根据需要调整
        kmeans = KMeans(n_clusters=n_clusters, random_state=42)
        clusters = kmeans.fit_predict(X_scaled)
        
        # 分析每个簇的特征
        cluster_stats = []
        for i in range(n_clusters):
            cluster_data = data[clusters == i]
            stats = {
                'size': len(cluster_data),
                'slope_mean': float(cluster_data['slope_magnitude'].mean()),
                'slope_std': float(cluster_data['slope_magnitude'].std()),
                'relative_aspect_mean': float(cluster_data['relative_aspect'].mean()),
                'relative_aspect_std': float(cluster_data['relative_aspect'].std()),
                'landcover_mode': int(cluster_data['landcover'].mode().iloc[0]),
                'speed_mean': float(cluster_data['speed'].mean()),
                'speed_std': float(cluster_data['speed'].std())
            }
            cluster_stats.append(stats)
        
        self.learned_patterns['environment_clusters'] = {
            'n_clusters': n_clusters,
            'cluster_centers': kmeans.cluster_centers_.tolist(),
            'feature_names': features,
            'scaler': scaler,
            'cluster_stats': cluster_stats
        }
    
    def get_learned_patterns(self) -> Dict:
        """
        获取学习到的运动模式
        
        Returns:
            Dict: 学习结果字典
        """
        return self.learned_patterns
    
    def save_patterns(self, filepath: str) -> None:
        """
        保存学习结果到文件
        
        Args:
            filepath: 保存路径
        """
        import pickle
        with open(filepath, 'wb') as f:
            pickle.dump(self.learned_patterns, f)
        logger.info("学习结果已保存到: %s", filepath)
    
    def load_patterns(self, filepath: str) -> None:
        """
        从文件加载学习结果
        
        Args:
            filepath: 文件路径
        """
        import pickle
        with open(filepath, 'rb') as f:
            self.learned_patterns = pickle.load(f)
        logger.info("已从%s加载学习结果", filepath) 
```

### src/data_processing/oord_processor.py
```python
"""
OORD数据处理模块
负责处理和分析OORD轨迹数据
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import pandas as pd
from scipy.stats import binned_statistic_2d

from .terrain_loader import TerrainLoader
from .terrain_analyzer import TerrainAnalyzer

logger = logging.getLogger(__name__)

class OORDProcessor:
    """OORD数据处理器"""
    
    def __init__(self, terrain_loader: Optional[TerrainLoader] = None):
        """
        初始化OORD数据处理器
        
        Args:
            terrain_loader: 地形数据加载器实例，如果为None则不进行地形分析
        """
        self.terrain_loader = terrain_loader
        self.terrain_analyzer = TerrainAnalyzer() if terrain_loader is not None else None
        self.trajectories: Dict[str, pd.DataFrame] = {}
        self.processed_trajectories: Dict[str, pd.DataFrame] = {}
        self.environment_stats: Optional[Dict] = None
        
    def load_trajectory(self, trajectory_file: Union[str, Path]) -> pd.DataFrame:
        """
        加载轨迹数据
        
        Args:
            trajectory_file: 轨迹文件路径
            
        Returns:
            pd.DataFrame: 处理后的轨迹数据
        """
        try:
            # 读取CSV文件
            df = pd.read_csv(trajectory_file)
            
            # 转换时间戳
            df['timestamp'] = pd.to_datetime(df['timestamp_ms'], unit='ms')
            
            # 计算速度和加速度
            df['speed'] = np.sqrt(
                df['velocity_north_ms']**2 + 
                df['velocity_east_ms']**2
            )
            df['acceleration'] = np.sqrt(
                df['acceleration_x_ms2']**2 + 
                df['acceleration_y_ms2']**2 + 
                df['acceleration_z_ms2']**2
            )
            
            # 计算航向角
            df['heading'] = np.degrees(np.arctan2(
                df['velocity_east_ms'],
                df['velocity_north_ms']
            )) % 360
            
            # 计算转向率
            df['turn_rate'] = np.sqrt(
                df['angular_velocity_x_rads']**2 + 
                df['angular_velocity_y_rads']**2 + 
                df['angular_velocity_z_rads']**2
            )
            
            # 如果有地形数据，添加地形相关信息
            if self.terrain_loader is not None:
                df['elevation'] = df.apply(
                    lambda row: self.terrain_loader.get_elevation(row['longitude'], row['latitude']),
                    axis=1
                )
                df['landcover'] = df.apply(
                    lambda row: self.terrain_loader.get_landcover(row['longitude'], row['latitude']),
                    axis=1
                )
            
            # 保存轨迹数据
            trajectory_id = Path(trajectory_file).stem
            self.trajectories[trajectory_id] = df
            
            return df
            
        except Exception as e:
            logger.error(f"处理轨迹文件 {trajectory_file} 失败: {str(e)}")
            raise
            
    def process_trajectory(
            self,
            trajectory_id: str,
            max_speed: float = 50.0
        ) -> pd.DataFrame:
        """
        处理轨迹数据
        
        Args:
            trajectory_id: 轨迹ID
            max_speed: 最大速度阈值，单位：米/秒
            
        Returns:
            pd.DataFrame: 处理后的轨迹数据
        """
        if trajectory_id not in self.trajectories:
            raise ValueError(f"未找到轨迹 {trajectory_id}")
        
        df = self.trajectories[trajectory_id].copy()
        
        # 速度过滤
        df = df[df['speed'] <= max_speed].copy()
        
        # 如果有地形数据，添加环境分组
        if self.terrain_loader is not None and self.terrain_analyzer is not None:
            # 确保地形分析器已初始化
            if self.terrain_analyzer.slope_magnitude is None:
                self.terrain_analyzer.load_dem(
                    self.terrain_loader.dem_data,
                    self.terrain_loader.resolution
                )
                self.terrain_analyzer.calculate_slope_magnitude()
            
            # 获取每个点的坡度
            df['slope_magnitude'] = df.apply(
                lambda row: self.terrain_analyzer.get_terrain_attributes(
                    row['longitude'], row['latitude']
                )['slope_magnitude'],
                axis=1
            )
            
            # 坡度分组
            df['slope_group'] = pd.cut(
                df['slope_magnitude'],
                bins=[0, 5, 15, 30, np.inf],
                labels=['flat', 'gentle', 'moderate', 'steep'],
                include_lowest=True  # 包含最小值
            )
            
            # 环境分组标签
            df['group_label'] = df.apply(
                lambda row: f"{row['slope_group']}_{row['landcover']}",
                axis=1
            )
        else:
            # 如果没有地形数据，使用默认值
            df['slope_magnitude'] = 0.0
            df['slope_group'] = 'flat'
            df['group_label'] = 'flat_0'
        
        # 保存处理后的轨迹
        self.processed_trajectories[trajectory_id] = df
        
        return df
        
    def analyze_environment_interaction(self) -> Dict:
        """
        分析轨迹与环境的交互关系
        
        Returns:
            Dict: 环境交互统计信息
        """
        if not self.processed_trajectories:
            raise ValueError("没有处理过的轨迹数据")
        
        # 合并所有处理过的轨迹
        all_trajectories = pd.concat(self.processed_trajectories.values())
        
        def safe_std(x: pd.Series) -> float:
            """安全计算标准差，当样本数小于2时返回0"""
            return float(x.std()) if len(x) > 1 else 0.0
        
        # 如果没有地形数据，只分析基本运动特征
        if self.terrain_loader is None:
            stats = {
                'overall': {
                    'speed_mean': float(all_trajectories['speed'].mean()),
                    'speed_std': safe_std(all_trajectories['speed']),
                    'speed_median': float(all_trajectories['speed'].median()),
                    'speed_max': float(all_trajectories['speed'].max()),
                    'acceleration_std': safe_std(all_trajectories['acceleration']),
                    'turn_rate_std': safe_std(all_trajectories['turn_rate']),
                    'sample_size': int(len(all_trajectories))
                }
            }
            return stats
        
        # 如果有地形数据，按环境分组分析
        stats = {}
        for group_label in all_trajectories['group_label'].unique():
            group_data = all_trajectories[all_trajectories['group_label'] == group_label]
            if len(group_data) > 0:  # 只处理非空组
                stats[group_label] = {
                    'speed_mean': float(group_data['speed'].mean()),
                    'speed_std': safe_std(group_data['speed']),
                    'speed_median': float(group_data['speed'].median()),
                    'speed_max': float(group_data['speed'].max()),
                    'acceleration_std': safe_std(group_data['acceleration']),
                    'turn_rate_std': safe_std(group_data['turn_rate']),
                    'sample_size': int(len(group_data))
                }
        
        return stats
        
    def _get_slope_magnitude(self, lon: float, lat: float) -> float:
        """
        获取指定位置的坡度大小
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            slope_magnitude: 坡度大小（度）
        """
        if self.terrain_analyzer.slope_magnitude is None:
            return 0.0
            
        row, col = self.terrain_loader.get_pixel_coords(lon, lat)
        if 0 <= row < self.terrain_analyzer.slope_magnitude.shape[0] and \
           0 <= col < self.terrain_analyzer.slope_magnitude.shape[1]:
            return float(self.terrain_analyzer.slope_magnitude[row, col])
        return 0.0
        
    @staticmethod
    def _calculate_haversine_distance(lon: np.ndarray, lat: np.ndarray) -> np.ndarray:
        """
        计算相邻点间的Haversine距离
        
        Args:
            lon: 经度数组
            lat: 纬度数组
            
        Returns:
            distances: 距离数组（米）
        """
        R = 6371000  # 地球半径（米）
        
        # 转换为弧度
        lon_rad = np.radians(lon)
        lat_rad = np.radians(lat)
        
        # 计算差值
        dlon = np.diff(lon_rad)
        dlat = np.diff(lat_rad)
        
        # Haversine公式
        a = np.sin(dlat/2)**2 + np.cos(lat_rad[:-1]) * np.cos(lat_rad[1:]) * np.sin(dlon/2)**2
        c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1-a))
        
        distances = np.zeros_like(lon)
        distances[1:] = R * c
        return distances
        
    @staticmethod
    def _calculate_heading(lon: np.ndarray, lat: np.ndarray) -> np.ndarray:
        """
        计算航向角（度，北为0，顺时针）
        
        Args:
            lon: 经度数组
            lat: 纬度数组
            
        Returns:
            headings: 航向角数组（度）
        """
        # 转换为弧度
        lon_rad = np.radians(lon)
        lat_rad = np.radians(lat)
        
        # 计算差值
        dlon = np.diff(lon_rad)
        dlat = np.diff(lat_rad)
        
        # 计算方位角
        y = np.sin(dlon) * np.cos(lat_rad[1:])
        x = np.cos(lat_rad[:-1]) * np.sin(lat_rad[1:]) - \
            np.sin(lat_rad[:-1]) * np.cos(lat_rad[1:]) * np.cos(dlon)
        
        heading_rad = np.arctan2(y, x)
        heading_deg = np.degrees(heading_rad) % 360
        
        headings = np.zeros_like(lon)
        headings[1:] = heading_deg
        headings[0] = headings[1]  # 第一个点使用第二个点的航向
        return headings

    def calculate_haversine_distance(
            self,
            lon1: float,
            lat1: float,
            lon2: float,
            lat2: float
        ) -> float:
        """
        计算两点间的Haversine距离
        
        Args:
            lon1: 起点经度
            lat1: 起点纬度
            lon2: 终点经度
            lat2: 终点纬度
            
        Returns:
            float: 两点间的距离，单位：公里
        """
        # 地球平均半径（公里）
        R = 6371.0
        
        # 将经纬度转换为弧度
        lat1_rad = np.radians(lat1)
        lon1_rad = np.radians(lon1)
        lat2_rad = np.radians(lat2)
        lon2_rad = np.radians(lon2)
        
        # 计算差值
        dlat = lat2_rad - lat1_rad
        dlon = lon2_rad - lon1_rad
        
        # Haversine公式
        a = np.sin(dlat/2)**2 + np.cos(lat1_rad) * np.cos(lat2_rad) * np.sin(dlon/2)**2
        c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1-a))
        distance = R * c
        
        return distance

    def calculate_heading(
            self,
            velocity_north: float,
            velocity_east: float
        ) -> float:
        """
        计算航向角
        
        Args:
            velocity_north: 北向速度分量
            velocity_east: 东向速度分量
            
        Returns:
            float: 航向角，单位：度，范围[0, 360)
        """
        heading = np.degrees(np.arctan2(velocity_east, velocity_north)) % 360
        return heading 
```

### src/data_processing/terrain_analyzer.py
```python
"""
地形分析模块
负责计算和分析DEM数据，生成坡度、坡向等地形特征
"""

import logging
from pathlib import Path
from typing import Dict, Optional, Tuple, Union

import numpy as np
import rasterio
from rasterio.errors import RasterioIOError
import richdem as rd

logger = logging.getLogger(__name__)

class TerrainAnalyzer:
    """地形分析器"""
    
    def __init__(self):
        """初始化地形分析器"""
        self.dem_data: Optional[np.ndarray] = None
        self.resolution: Optional[float] = None
        self.slope_magnitude: Optional[np.ndarray] = None
        self.slope_aspect: Optional[np.ndarray] = None
        self.dzdx: Optional[np.ndarray] = None
        self.dzdy: Optional[np.ndarray] = None
        
    def load_dem(self, dem_data: np.ndarray, resolution: float):
        """
        加载DEM数据
        
        Args:
            dem_data: DEM数据数组
            resolution: 空间分辨率（米）
        """
        self.dem_data = dem_data
        self.resolution = resolution
        logger.info(f"加载DEM数据，形状: {dem_data.shape}, 分辨率: {resolution}米")
        
    def calculate_slope_magnitude(self) -> np.ndarray:
        """
        计算坡度大小（度）
        
        Returns:
            slope_magnitude: 坡度大小数组（度）
        """
        if self.dem_data is None or self.resolution is None:
            raise ValueError("请先加载DEM数据")
            
        # 计算X和Y方向的梯度
        self.dzdx, self.dzdy = np.gradient(self.dem_data, self.resolution)
        
        # 计算坡度（弧度）
        slope_rad = np.arctan(np.sqrt(self.dzdx**2 + self.dzdy**2))
        
        # 转换为度
        self.slope_magnitude = np.degrees(slope_rad)
        
        logger.info(f"计算坡度大小完成，范围: [{self.slope_magnitude.min():.2f}, {self.slope_magnitude.max():.2f}]度")
        return self.slope_magnitude
        
    def calculate_slope_aspect(self) -> np.ndarray:
        """
        计算坡向（度，北为0，顺时针）
        
        Returns:
            slope_aspect: 坡向数组（度）
        """
        if self.dzdx is None or self.dzdy is None:
            self.calculate_slope_magnitude()
            
        # 计算坡向（弧度）
        aspect_rad = np.arctan2(self.dzdx, self.dzdy)
        
        # 转换为度并调整为北为0
        self.slope_aspect = np.degrees(aspect_rad)
        self.slope_aspect = (450 - self.slope_aspect) % 360
        
        # 处理平坦区域（坡度接近0的区域）
        flat_mask = self.slope_magnitude < 0.1  # 坡度小于0.1度视为平地
        self.slope_aspect[flat_mask] = -1  # 平地的坡向设为-1
        
        logger.info("计算坡向完成")
        return self.slope_aspect
        
    def get_terrain_attributes(self, lon: float, lat: float) -> Dict[str, float]:
        """
        获取指定位置的地形属性
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            Dict[str, float]: 地形属性字典，包含：
                - slope_magnitude: 坡度大小（度）
                - slope_aspect: 坡向（度）
        """
        if self.dem_data is None:
            return {
                'slope_magnitude': 0.0,
                'slope_aspect': -1.0
            }
        
        # 获取像素坐标
        row = int((lat - 39.0) / (30 / 111000))  # 30米分辨率，1度约等于111公里
        col = int((lon - 116.0) / (30 / (111000 * np.cos(np.radians(lat)))))
        
        # 检查坐标是否在范围内
        if not (0 <= row < self.dem_data.shape[0] and 0 <= col < self.dem_data.shape[1]):
            return {
                'slope_magnitude': 0.0,
                'slope_aspect': -1.0
            }
        
        slope_mag = self.slope_magnitude[row, col] if self.slope_magnitude is not None else 0.0
        slope_asp = self.slope_aspect[row, col] if self.slope_aspect is not None else -1.0
        
        return {
            'slope_magnitude': float(slope_mag),
            'slope_aspect': float(slope_asp)
        }
        
    def calculate_gradients(self) -> Tuple[np.ndarray, np.ndarray]:
        """
        计算X和Y方向的地形梯度
        
        Returns:
            (dzdx, dzdy): X和Y方向的梯度数组
        """
        if self.dem_data is None or self.resolution is None:
            raise ValueError("未加载DEM数据")
            
        # 使用numpy.gradient计算梯度
        dy, dx = np.gradient(self.dem_data)
        self.dzdx = dx / self.resolution  # X方向梯度
        self.dzdy = dy / self.resolution  # Y方向梯度
        
        logger.info("完成地形梯度计算")
        return self.dzdx, self.dzdy
        
    def save_results(self, output_dir: Union[str, Path]):
        """
        保存计算结果
        
        Args:
            output_dir: 输出目录
        """
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # 保存坡度大小
        if self.slope_magnitude is not None:
            slope_path = output_dir / "slope_magnitude_30m_100km.tif"
            self._save_array(self.slope_magnitude, slope_path, "坡度大小")
            
        # 保存坡向
        if self.slope_aspect is not None:
            aspect_path = output_dir / "slope_aspect_30m_100km.tif"
            self._save_array(self.slope_aspect, aspect_path, "坡向")
            
        # 保存梯度
        if self.dzdx is not None and self.dzdy is not None:
            dzdx_path = output_dir / "dzdx_30m_100km.tif"
            dzdy_path = output_dir / "dzdy_30m_100km.tif"
            self._save_array(self.dzdx, dzdx_path, "X方向梯度")
            self._save_array(self.dzdy, dzdy_path, "Y方向梯度")
            
    def _save_array(self, array: np.ndarray, path: Path, description: str):
        """
        保存数组为GeoTIFF文件
        
        Args:
            array: 要保存的数组
            path: 保存路径
            description: 数据描述
        """
        try:
            with rasterio.open(path, 'w',
                             driver='GTiff',
                             height=array.shape[0],
                             width=array.shape[1],
                             count=1,
                             dtype=array.dtype,
                             crs='+proj=latlong',
                             transform=None) as dst:
                dst.write(array, 1)
            logger.info(f"保存{description}数据到: {path}")
        except Exception as e:
            logger.error(f"保存{description}数据失败: {str(e)}")
            raise 
```

### src/data_processing/terrain_loader.py
```python
"""
GIS数据加载模块
负责加载DEM、土地覆盖等GIS数据
"""

import logging
from pathlib import Path
from typing import Dict, Optional, Tuple, Union

import numpy as np
import rasterio
from rasterio.errors import RasterioIOError

logger = logging.getLogger(__name__)

class TerrainLoader:
    """GIS地形数据加载器"""
    
    def __init__(self):
        """初始化地形数据加载器"""
        self.dem_data: Optional[np.ndarray] = None
        self.landcover_data: Optional[np.ndarray] = None
        self.transform = None
        self.crs = None
        self.resolution = None
        self.bounds = None
        
    def load_dem(self, dem_path: Union[str, Path]) -> np.ndarray:
        """
        加载DEM数据
        
        Args:
            dem_path: DEM文件路径(.tif格式)
            
        Returns:
            dem_array: DEM数据数组
        """
        try:
            with rasterio.open(dem_path) as src:
                self.dem_data = src.read(1)  # 读取第一个波段
                self.transform = src.transform
                self.crs = src.crs
                self.resolution = (src.res[0], src.res[1])
                self.bounds = src.bounds
                
            logger.info(f"成功加载DEM数据，形状: {self.dem_data.shape}")
            return self.dem_data
            
        except RasterioIOError as e:
            logger.error(f"加载DEM文件失败: {str(e)}")
            raise
            
    def load_landcover(self, landcover_path: Union[str, Path]) -> np.ndarray:
        """
        加载土地覆盖数据
        
        Args:
            landcover_path: 土地覆盖数据文件路径(.tif格式)
            
        Returns:
            landcover_array: 土地覆盖数据数组
        """
        try:
            with rasterio.open(landcover_path) as src:
                self.landcover_data = src.read(1)
                
                # 验证与DEM的一致性
                if self.dem_data is not None:
                    if src.shape != self.dem_data.shape:
                        raise ValueError("土地覆盖数据与DEM形状不一致")
                    if src.transform != self.transform:
                        raise ValueError("土地覆盖数据与DEM空间参考不一致")
                
            logger.info(f"成功加载土地覆盖数据，形状: {self.landcover_data.shape}")
            return self.landcover_data
            
        except RasterioIOError as e:
            logger.error(f"加载土地覆盖数据失败: {str(e)}")
            raise
            
    def get_pixel_coords(self, lon: float, lat: float) -> Tuple[int, int]:
        """
        将经纬度坐标转换为像素坐标
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            (row, col): 像素坐标
        """
        if self.transform is None:
            raise ValueError("未加载任何地形数据")
            
        col, row = ~self.transform * (lon, lat)
        return int(row), int(col)
        
    def get_geo_coords(self, row: int, col: int) -> Tuple[float, float]:
        """
        将像素坐标转换为经纬度坐标
        
        Args:
            row: 行号
            col: 列号
            
        Returns:
            (lon, lat): 经纬度坐标
        """
        if self.transform is None:
            raise ValueError("未加载任何地形数据")
            
        lon, lat = self.transform * (col, row)
        return lon, lat
        
    def get_elevation(self, lon: float, lat: float) -> float:
        """
        获取指定位置的高程值
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            elevation: 高程值
        """
        if self.dem_data is None:
            raise ValueError("未加载DEM数据")
            
        row, col = self.get_pixel_coords(lon, lat)
        if 0 <= row < self.dem_data.shape[0] and 0 <= col < self.dem_data.shape[1]:
            return float(self.dem_data[row, col])
        else:
            raise ValueError("坐标超出DEM范围")
            
    def get_landcover(self, lon: float, lat: float) -> int:
        """
        获取指定位置的土地覆盖类型
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            landcover_code: 土地覆盖类型代码
        """
        if self.landcover_data is None:
            raise ValueError("未加载土地覆盖数据")
            
        row, col = self.get_pixel_coords(lon, lat)
        if 0 <= row < self.landcover_data.shape[0] and 0 <= col < self.landcover_data.shape[1]:
            return int(self.landcover_data[row, col])
        else:
            raise ValueError("坐标超出土地覆盖数据范围") 
```

### src/data_processing/trajectory_loader.py
```python
"""
OORD轨迹数据加载和预处理模块
负责加载、清洗和预处理OORD轨迹数据
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import pandas as pd
from scipy.spatial.distance import cdist

from ..config import CORE_TRAJECTORIES_DIR

# 配置日志
logger = logging.getLogger(__name__)

class TrajectoryLoader:
    """OORD轨迹数据加载器"""
    
    def __init__(self):
        """初始化轨迹加载器"""
        self.trajectories: Dict[str, pd.DataFrame] = {}
        self.processed_trajectories: Dict[str, pd.DataFrame] = {}
    
    def load_trajectory(self, file_path: Union[str, Path]) -> pd.DataFrame:
        """
        加载单个轨迹文件
        
        Args:
            file_path: 轨迹文件路径
            
        Returns:
            trajectory_df: 包含轨迹数据的DataFrame
        """
        try:
            # 假设轨迹文件是CSV格式，包含timestamp,longitude,latitude列
            df = pd.read_csv(file_path)
            
            # 验证必要的列是否存在
            required_columns = ['timestamp', 'longitude', 'latitude']
            missing_columns = [col for col in required_columns if col not in df.columns]
            if missing_columns:
                raise ValueError(f"轨迹文件缺少必要的列: {missing_columns}")
            
            # 确保时间戳是datetime类型
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            
            # 按时间戳排序
            df = df.sort_values('timestamp')
            
            # 将轨迹存储在字典中
            trajectory_id = Path(file_path).stem
            self.trajectories[trajectory_id] = df
            
            logger.info(f"成功加载轨迹 {trajectory_id}，共 {len(df)} 个点")
            return df
            
        except Exception as e:
            logger.error(f"加载轨迹文件 {file_path} 失败: {str(e)}")
            raise
    
    def load_all_trajectories(self, directory: Union[str, Path] = CORE_TRAJECTORIES_DIR) -> Dict[str, pd.DataFrame]:
        """
        加载目录中的所有轨迹文件
        
        Args:
            directory: 轨迹文件目录
            
        Returns:
            trajectories: 轨迹数据字典，键为轨迹ID
        """
        directory = Path(directory)
        try:
            for file_path in directory.glob("*.csv"):
                self.load_trajectory(file_path)
            
            logger.info(f"成功加载 {len(self.trajectories)} 条轨迹")
            return self.trajectories
            
        except Exception as e:
            logger.error(f"加载轨迹目录 {directory} 失败: {str(e)}")
            raise
    
    def preprocess_trajectory(self, trajectory_id: str, 
                            min_speed: float = 0.1,
                            max_speed: float = 50.0,
                            min_distance: float = 1.0) -> pd.DataFrame:
        """
        预处理单条轨迹，计算速度、方向等特征，并进行异常值过滤
        
        Args:
            trajectory_id: 轨迹ID
            min_speed: 最小合理速度（米/秒）
            max_speed: 最大合理速度（米/秒）
            min_distance: 最小点间距离（米）
            
        Returns:
            processed_df: 处理后的轨迹DataFrame
        """
        if trajectory_id not in self.trajectories:
            raise KeyError(f"轨迹 {trajectory_id} 不存在")
            
        df = self.trajectories[trajectory_id].copy()
        
        # 计算时间差（秒）
        df['time_diff'] = df['timestamp'].diff().dt.total_seconds()
        
        # 计算相邻点间的距离（米）
        coords = df[['longitude', 'latitude']].values
        distances = np.zeros(len(df))
        distances[1:] = self._haversine_distance(coords[:-1], coords[1:])
        df['distance'] = distances
        
        # 计算速度（米/秒）
        df['speed'] = df['distance'] / df['time_diff']
        
        # 计算方向角（度）
        df['heading'] = self._calculate_heading(coords)
        
        # 计算转向率（度/秒）
        df['turn_rate'] = df['heading'].diff() / df['time_diff']
        
        # 过滤异常值
        mask = (
            (df['speed'] >= min_speed) & 
            (df['speed'] <= max_speed) &
            (df['distance'] >= min_distance)
        )
        
        df_filtered = df[mask].copy()
        
        # 重新计算过滤后的特征
        df_filtered['time_diff'] = df_filtered['timestamp'].diff().dt.total_seconds()
        df_filtered['acceleration'] = df_filtered['speed'].diff() / df_filtered['time_diff']
        
        # 存储处理后的轨迹
        self.processed_trajectories[trajectory_id] = df_filtered
        
        logger.info(f"轨迹 {trajectory_id} 预处理完成，保留 {len(df_filtered)}/{len(df)} 个点")
        return df_filtered
    
    def preprocess_all_trajectories(self, **kwargs) -> Dict[str, pd.DataFrame]:
        """
        预处理所有已加载的轨迹
        
        Args:
            **kwargs: 传递给preprocess_trajectory的参数
            
        Returns:
            processed_trajectories: 处理后的轨迹数据字典
        """
        for trajectory_id in self.trajectories:
            self.preprocess_trajectory(trajectory_id, **kwargs)
        
        logger.info(f"完成 {len(self.processed_trajectories)} 条轨迹的预处理")
        return self.processed_trajectories
    
    @staticmethod
    def _haversine_distance(point1: np.ndarray, point2: np.ndarray) -> np.ndarray:
        """
        计算两点间的Haversine距离（米）
        
        Args:
            point1: [longitude, latitude] 数组
            point2: [longitude, latitude] 数组
            
        Returns:
            distances: 距离数组（米）
        """
        R = 6371000  # 地球半径（米）
        
        # 转换为弧度
        lat1, lon1 = np.radians(point1[:, 1]), np.radians(point1[:, 0])
        lat2, lon2 = np.radians(point2[:, 1]), np.radians(point2[:, 0])
        
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        
        a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2
        c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1-a))
        
        return R * c
    
    @staticmethod
    def _calculate_heading(coords: np.ndarray) -> np.ndarray:
        """
        计算轨迹点的方向角（度）
        
        Args:
            coords: [[longitude, latitude], ...] 数组
            
        Returns:
            headings: 方向角数组（度）
        """
        # 初始化方向角数组
        headings = np.zeros(len(coords))
        
        # 计算相邻点的经纬度差
        dlon = np.radians(np.diff(coords[:, 0]))
        lat1 = np.radians(coords[:-1, 1])
        lat2 = np.radians(coords[1:, 1])
        
        # 计算方位角
        y = np.sin(dlon) * np.cos(lat2)
        x = np.cos(lat1) * np.sin(lat2) - np.sin(lat1) * np.cos(lat2) * np.cos(dlon)
        heading_rad = np.arctan2(y, x)
        
        # 转换为度数并调整到[0, 360)范围
        headings[1:] = (np.degrees(heading_rad) + 360) % 360
        headings[0] = headings[1]  # 第一个点的方向与第二个点相同
        
        return headings 
```

### src/evaluation/__init__.py
```python

```

### src/evaluation/evaluator.py
```python
"""
轨迹评估器
用于评估生成轨迹的质量和真实性
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import numpy as np
import pandas as pd
from scipy import stats
import matplotlib.pyplot as plt
import seaborn as sns

logger = logging.getLogger(__name__)

class Evaluator:
    """轨迹评估器"""
    
    def __init__(
            self,
            oord_data: pd.DataFrame,
            output_dir: str
        ):
        """
        初始化评估器
        
        Args:
            oord_data: OORD轨迹数据，包含：
                - timestamp_ms: 时间戳（毫秒）
                - speed_mps: 速度（米/秒）
                - heading_degrees: 朝向（度）
                - turn_rate_dps: 转向率（度/秒）
                - acceleration_mps2: 加速度（米/秒²）
                - group_label: 环境组标签
            output_dir: 评估结果输出目录
        """
        self.oord_data = oord_data
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # 计算OORD数据的统计特征
        self._calculate_oord_statistics()
    
    def _calculate_oord_statistics(self) -> None:
        """计算OORD数据的统计特征"""
        # 全局统计
        self.oord_stats = {
            'speed': {
                'mean': self.oord_data['speed_mps'].mean(),
                'std': self.oord_data['speed_mps'].std(),
                'min': self.oord_data['speed_mps'].min(),
                'max': self.oord_data['speed_mps'].max(),
                'percentiles': np.percentile(
                    self.oord_data['speed_mps'],
                    [25, 50, 75]
                )
            },
            'acceleration': {
                'mean': self.oord_data['acceleration_mps2'].mean(),
                'std': self.oord_data['acceleration_mps2'].std(),
                'min': self.oord_data['acceleration_mps2'].min(),
                'max': self.oord_data['acceleration_mps2'].max(),
                'percentiles': np.percentile(
                    self.oord_data['acceleration_mps2'],
                    [25, 50, 75]
                )
            },
            'turn_rate': {
                'mean': self.oord_data['turn_rate_dps'].mean(),
                'std': self.oord_data['turn_rate_dps'].std(),
                'min': self.oord_data['turn_rate_dps'].min(),
                'max': self.oord_data['turn_rate_dps'].max(),
                'percentiles': np.percentile(
                    self.oord_data['turn_rate_dps'],
                    [25, 50, 75]
                )
            }
        }
        
        # 按环境组统计
        self.oord_group_stats = {}
        for group in self.oord_data['group_label'].unique():
            group_data = self.oord_data[
                self.oord_data['group_label'] == group
            ]
            self.oord_group_stats[group] = {
                'speed': {
                    'mean': group_data['speed_mps'].mean(),
                    'std': group_data['speed_mps'].std()
                }
            }
    
    def evaluate_trajectory(
            self,
            trajectory: Dict,
            group_labels: Optional[List[str]] = None
        ) -> Dict:
        """
        评估单条轨迹
        
        Args:
            trajectory: 轨迹数据字典，包含：
                - timestamps: 时间戳列表（秒）
                - speeds: 速度列表（米/秒）
                - headings: 朝向列表（度）
            group_labels: 轨迹点的环境组标签列表，可选
            
        Returns:
            Dict: 评估结果
        """
        # 转换为DataFrame
        traj_df = pd.DataFrame({
            'timestamp': trajectory['timestamps'],
            'speed': trajectory['speeds'],
            'heading': trajectory['headings']
        })
        
        # 计算转向率和加速度
        traj_df['turn_rate'] = np.gradient(
            traj_df['heading'],
            traj_df['timestamp']
        )
        traj_df['acceleration'] = np.gradient(
            traj_df['speed'],
            traj_df['timestamp']
        )
        
        # 计算统计特征
        stats_result = {
            'speed': {
                'mean': traj_df['speed'].mean(),
                'std': traj_df['speed'].std(),
                'min': traj_df['speed'].min(),
                'max': traj_df['speed'].max(),
                'percentiles': np.percentile(
                    traj_df['speed'],
                    [25, 50, 75]
                )
            },
            'acceleration': {
                'mean': traj_df['acceleration'].mean(),
                'std': traj_df['acceleration'].std(),
                'min': traj_df['acceleration'].min(),
                'max': traj_df['acceleration'].max(),
                'percentiles': np.percentile(
                    traj_df['acceleration'],
                    [25, 50, 75]
                )
            },
            'turn_rate': {
                'mean': traj_df['turn_rate'].mean(),
                'std': traj_df['turn_rate'].std(),
                'min': traj_df['turn_rate'].min(),
                'max': traj_df['turn_rate'].max(),
                'percentiles': np.percentile(
                    traj_df['turn_rate'],
                    [25, 50, 75]
                )
            }
        }
        
        # 进行KS检验
        ks_results = {
            'speed': stats.ks_2samp(
                traj_df['speed'],
                self.oord_data['speed_mps']
            ),
            'acceleration': stats.ks_2samp(
                traj_df['acceleration'],
                self.oord_data['acceleration_mps2']
            ),
            'turn_rate': stats.ks_2samp(
                traj_df['turn_rate'],
                self.oord_data['turn_rate_dps']
            )
        }
        
        # 如果提供了环境组标签，进行分组评估
        group_results = {}
        if group_labels is not None:
            traj_df['group_label'] = group_labels
            for group in traj_df['group_label'].unique():
                group_data = traj_df[
                    traj_df['group_label'] == group
                ]
                oord_group_data = self.oord_data[
                    self.oord_data['group_label'] == group
                ]
                
                if len(group_data) > 0 and len(oord_group_data) > 0:
                    group_results[group] = {
                        'speed': {
                            'mean': group_data['speed'].mean(),
                            'std': group_data['speed'].std(),
                            'ks_test': stats.ks_2samp(
                                group_data['speed'],
                                oord_group_data['speed_mps']
                            )
                        }
                    }
        
        return {
            'statistics': stats_result,
            'ks_tests': ks_results,
            'group_results': group_results
        }
    
    def evaluate_batch(
            self,
            trajectories: List[Dict],
            group_labels_list: Optional[List[List[str]]] = None
        ) -> Dict:
        """
        评估一批轨迹
        
        Args:
            trajectories: 轨迹数据字典列表
            group_labels_list: 轨迹点的环境组标签列表的列表，可选
            
        Returns:
            Dict: 评估结果
        """
        # 评估每条轨迹
        results = []
        for i, traj in enumerate(trajectories):
            group_labels = (
                group_labels_list[i]
                if group_labels_list is not None
                else None
            )
            results.append(
                self.evaluate_trajectory(traj, group_labels)
            )
        
        # 汇总统计结果
        speed_means = [r['statistics']['speed']['mean'] for r in results]
        accel_means = [
            r['statistics']['acceleration']['mean']
            for r in results
        ]
        turn_means = [
            r['statistics']['turn_rate']['mean']
            for r in results
        ]
        
        summary = {
            'speed': {
                'mean_of_means': np.mean(speed_means),
                'std_of_means': np.std(speed_means)
            },
            'acceleration': {
                'mean_of_means': np.mean(accel_means),
                'std_of_means': np.std(accel_means)
            },
            'turn_rate': {
                'mean_of_means': np.mean(turn_means),
                'std_of_means': np.std(turn_means)
            }
        }
        
        return {
            'individual_results': results,
            'summary': summary
        }
    
    def plot_distributions(
            self,
            trajectories: List[Dict],
            prefix: str = ''
        ) -> None:
        """
        绘制分布对比图
        
        Args:
            trajectories: 轨迹数据字典列表
            prefix: 输出文件名前缀
        """
        # 合并所有轨迹数据
        all_speeds = []
        all_accels = []
        all_turns = []
        
        for traj in trajectories:
            all_speeds.extend(traj['speeds'])
            
            # 计算加速度和转向率
            times = np.array(traj['timestamps'])
            speeds = np.array(traj['speeds'])
            headings = np.array(traj['headings'])
            
            accels = np.gradient(speeds, times)
            turns = np.gradient(headings, times)
            
            all_accels.extend(accels)
            all_turns.extend(turns)
        
        # 绘制速度分布
        plt.figure(figsize=(10, 6))
        sns.kdeplot(
            data=self.oord_data['speed_mps'],
            label='OORD',
            color='blue'
        )
        sns.kdeplot(
            data=all_speeds,
            label='Generated',
            color='red'
        )
        plt.title('Speed Distribution Comparison')
        plt.xlabel('Speed (m/s)')
        plt.ylabel('Density')
        plt.legend()
        plt.savefig(
            self.output_dir / f'{prefix}speed_distribution.png'
        )
        plt.close()
        
        # 绘制加速度分布
        plt.figure(figsize=(10, 6))
        sns.kdeplot(
            data=self.oord_data['acceleration_mps2'],
            label='OORD',
            color='blue'
        )
        sns.kdeplot(
            data=all_accels,
            label='Generated',
            color='red'
        )
        plt.title('Acceleration Distribution Comparison')
        plt.xlabel('Acceleration (m/s²)')
        plt.ylabel('Density')
        plt.legend()
        plt.savefig(
            self.output_dir / f'{prefix}acceleration_distribution.png'
        )
        plt.close()
        
        # 绘制转向率分布
        plt.figure(figsize=(10, 6))
        sns.kdeplot(
            data=self.oord_data['turn_rate_dps'],
            label='OORD',
            color='blue'
        )
        sns.kdeplot(
            data=all_turns,
            label='Generated',
            color='red'
        )
        plt.title('Turn Rate Distribution Comparison')
        plt.xlabel('Turn Rate (deg/s)')
        plt.ylabel('Density')
        plt.legend()
        plt.savefig(
            self.output_dir / f'{prefix}turn_rate_distribution.png'
        )
        plt.close()
    
    def generate_report(
            self,
            batch_results: Dict,
            output_file: str
        ) -> None:
        """
        生成评估报告
        
        Args:
            batch_results: 批量评估结果
            output_file: 输出文件路径
        """
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# 轨迹评估报告\n\n")
            
            # 写入总体统计
            f.write("## 总体统计\n\n")
            f.write("### 速度统计\n")
            f.write(f"- OORD平均速度: {self.oord_stats['speed']['mean']:.2f} m/s\n")
            f.write(f"- 生成轨迹平均速度: {batch_results['summary']['speed']['mean_of_means']:.2f} m/s\n")
            f.write(f"- OORD速度标准差: {self.oord_stats['speed']['std']:.2f} m/s\n")
            f.write(f"- 生成轨迹速度标准差: {batch_results['summary']['speed']['std_of_means']:.2f} m/s\n\n")
            
            f.write("### 加速度统计\n")
            f.write(f"- OORD平均加速度: {self.oord_stats['acceleration']['mean']:.2f} m/s²\n")
            f.write(f"- 生成轨迹平均加速度: {batch_results['summary']['acceleration']['mean_of_means']:.2f} m/s²\n")
            f.write(f"- OORD加速度标准差: {self.oord_stats['acceleration']['std']:.2f} m/s²\n")
            f.write(f"- 生成轨迹加速度标准差: {batch_results['summary']['acceleration']['std_of_means']:.2f} m/s²\n\n")
            
            f.write("### 转向率统计\n")
            f.write(f"- OORD平均转向率: {self.oord_stats['turn_rate']['mean']:.2f} deg/s\n")
            f.write(f"- 生成轨迹平均转向率: {batch_results['summary']['turn_rate']['mean_of_means']:.2f} deg/s\n")
            f.write(f"- OORD转向率标准差: {self.oord_stats['turn_rate']['std']:.2f} deg/s\n")
            f.write(f"- 生成轨迹转向率标准差: {batch_results['summary']['turn_rate']['std_of_means']:.2f} deg/s\n\n")
            
            # 写入KS检验结果
            f.write("## KS检验结果\n\n")
            for i, result in enumerate(batch_results['individual_results']):
                f.write(f"### 轨迹 {i+1}\n")
                f.write("- 速度分布检验:\n")
                f.write(f"  - 统计量: {result['ks_tests']['speed'].statistic:.4f}\n")
                f.write(f"  - p值: {result['ks_tests']['speed'].pvalue:.4f}\n")
                f.write("- 加速度分布检验:\n")
                f.write(f"  - 统计量: {result['ks_tests']['acceleration'].statistic:.4f}\n")
                f.write(f"  - p值: {result['ks_tests']['acceleration'].pvalue:.4f}\n")
                f.write("- 转向率分布检验:\n")
                f.write(f"  - 统计量: {result['ks_tests']['turn_rate'].statistic:.4f}\n")
                f.write(f"  - p值: {result['ks_tests']['turn_rate'].pvalue:.4f}\n\n")
            
            # 写入环境组分析结果
            if any(r['group_results'] for r in batch_results['individual_results']):
                f.write("## 环境组分析\n\n")
                for i, result in enumerate(batch_results['individual_results']):
                    if result['group_results']:
                        f.write(f"### 轨迹 {i+1}\n")
                        for group, stats in result['group_results'].items():
                            f.write(f"#### {group}\n")
                            f.write(f"- 平均速度: {stats['speed']['mean']:.2f} m/s\n")
                            f.write(f"- 速度标准差: {stats['speed']['std']:.2f} m/s\n")
                            f.write("- KS检验结果:\n")
                            f.write(f"  - 统计量: {stats['speed']['ks_test'].statistic:.4f}\n")
                            f.write(f"  - p值: {stats['speed']['ks_test'].pvalue:.4f}\n\n") 
```

### src/generator/__init__.py
```python
"""
轨迹生成器模块
"""

from .trajectory_generator import TrajectoryGenerator

__all__ = ['TrajectoryGenerator'] 
```

### src/generator/batch_generator.py
```python
"""批量轨迹生成器主控脚本

负责协调各个模块，完成从地形分析到轨迹生成的全流程。

输入:
- 配置文件
- GIS数据
- OORD数据

输出:
- 批量生成的轨迹
- 评估报告
"""

import logging
import os
from pathlib import Path
from datetime import datetime
from typing import List, Tuple, Dict
import json

from .terrain_analyzer import TerrainAnalyzer
from .environment_mapper import EnvironmentMapper
from .point_selector import PointSelector
from .path_planner import PathPlanner
from .motion_simulator import MotionSimulator, EnvironmentParams
from .evaluator import Evaluator

# 配置日志
logging.basicConfig(level=logging.INFO,
                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class BatchGenerator:
    """批量轨迹生成器类"""

    def __init__(self, config_path: str):
        """初始化批量生成器

        Args:
            config_path: 配置文件路径
        """
        # 加载配置
        with open(config_path) as f:
            self.config = json.load(f)

        # 创建输出目录
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.batch_dir = Path(self.config['output_dir']) / f"synthetic_batch_{timestamp}"
        self.batch_dir.mkdir(parents=True, exist_ok=True)

        # 保存配置副本
        with open(self.batch_dir / 'config.json', 'w') as f:
            json.dump(self.config, f, indent=4)

        # 初始化组件
        self.terrain_analyzer = TerrainAnalyzer(
            self.config['dem_path'],
            self.config['output_dir']
        )
        self.environment_mapper = EnvironmentMapper(
            self.config,
            self.config['output_dir']
        )
        self.point_selector = PointSelector(self.config)
        self.path_planner = PathPlanner(self.config)
        self.motion_simulator = MotionSimulator()
        self.evaluator = Evaluator(
            self.config,
            self.batch_dir / 'evaluation'
        )

    def generate_batch(self) -> None:
        """执行批量轨迹生成流程"""
        logger.info("开始批量生成轨迹...")

        # 1. 地形分析
        logger.info("步骤1: 地形分析")
        self.terrain_analyzer.calculate_terrain_attributes()

        # 2. 构建环境地图
        logger.info("步骤2: 构建环境地图")
        learned_params = self._load_learned_params()
        self.environment_mapper.build_environment_maps(learned_params)

        # 3. 选择起终点对
        logger.info("步骤3: 选择起终点对")
        generation_pairs = self.point_selector.select_start_end_pairs()
        if not generation_pairs:
            logger.error("未能找到合适的起终点对")
            return

        # 4. 为每对起终点生成轨迹
        logger.info("步骤4: 生成轨迹")
        successful_count = 0
        for i, (start_point, end_point) in enumerate(generation_pairs):
            try:
                # 规划路径
                path = self.path_planner.plan_path(start_point, end_point)
                if not path:
                    logger.warning(f"无法为第 {i+1} 对起终点规划路径")
                    continue

                # 模拟运动
                trajectory = self.motion_simulator.simulate_motion(
                    path,
                    self._get_environment_params
                )

                # 保存轨迹
                self._save_trajectory(trajectory, i + 1)
                successful_count += 1

            except Exception as e:
                logger.error(f"生成第 {i+1} 条轨迹时出错: {str(e)}")
                continue

        logger.info(f"成功生成 {successful_count} 条轨迹")

        # 5. 评估生成的轨迹
        if successful_count > 0:
            logger.info("步骤5: 评估轨迹")
            self.evaluator.evaluate_batch(
                str(self.batch_dir),
                self.config['oord_processed_path']
            )

        logger.info("批量生成完成")

    def _load_learned_params(self) -> Dict:
        """加载学习到的参数

        Returns:
            Dict: 学习到的参数
        """
        params_path = Path(self.config['output_dir']) / 'intermediate/learned_params.json'
        if params_path.exists():
            with open(params_path) as f:
                return json.load(f)
        return {}  # 如果文件不存在，返回空字典

    def _get_environment_params(self, lon: float, lat: float) -> EnvironmentParams:
        """获取指定位置的环境参数

        Args:
            lon: 经度
            lat: 纬度

        Returns:
            EnvironmentParams: 环境参数
        """
        # 从环境地图获取基础参数
        max_speed, typical_speed, speed_stddev = \
            self.environment_mapper.get_environment_params(lon, lat)

        # 获取地形信息
        slope, aspect, _, _ = self.terrain_analyzer.get_terrain_info(lon, lat)

        # 创建环境参数对象
        return EnvironmentParams(
            max_speed=max_speed,
            typical_speed=typical_speed,
            speed_stddev=speed_stddev,
            slope_magnitude=slope,
            slope_aspect=aspect
        )

    def _save_trajectory(self, trajectory: List[Tuple], index: int) -> None:
        """保存轨迹到文件

        Args:
            trajectory: 轨迹点列表
            index: 轨迹索引
        """
        import pandas as pd

        # 创建DataFrame
        df = pd.DataFrame(
            trajectory,
            columns=['timestamp', 'lon', 'lat', 'speed_mps', 'heading_degrees']
        )

        # 保存为CSV
        output_path = self.batch_dir / f'trajectory_{index:04d}.csv'
        df.to_csv(output_path, index=False)
        logger.debug(f"轨迹已保存到: {output_path}")

def main():
    """主函数"""
    import argparse

    parser = argparse.ArgumentParser(description='批量生成轨迹')
    parser.add_argument('config', help='配置文件路径')
    args = parser.parse_args()

    try:
        generator = BatchGenerator(args.config)
        generator.generate_batch()
    except Exception as e:
        logger.error(f"执行过程中出错: {str(e)}")
        raise

if __name__ == '__main__':
    main() 
```

### src/generator/config.py
```python
"""环境地图生成器配置文件

定义环境地图生成所需的常量和参数。
"""

# 坡度相关参数
MAX_SLOPE_THRESHOLD = 45.0  # 最大可通行坡度（度）
SLOPE_SPEED_FACTOR = 0.02   # 坡度对速度的影响因子
MAX_SPEED = 5.0            # 基础最大速度（米/秒）

# 速度相关参数
TYPICAL_SPEED_FACTOR = 0.8  # 典型速度与最大速度的比例
UP_SLOPE_FACTOR = 0.03     # 上坡减速因子
DOWN_SLOPE_FACTOR = 0.01   # 下坡增速因子
CROSS_SLOPE_FACTOR = 0.02  # 横坡减速因子

# 标准差相关参数
BASE_SPEED_STDDEV_FACTOR = 0.2  # 基础速度标准差因子
SLOPE_STDDEV_FACTOR = 0.5       # 坡度对标准差的影响因子
COMPLEX_TERRAIN_STDDEV_FACTOR = 1.5  # 复杂地形标准差增加因子

# 复杂地形代码
COMPLEX_TERRAIN_CODES = [
    21,  # 山地
    22,  # 丘陵
    23,  # 高原
]

# 土地覆盖速度因子
LANDCOVER_SPEED_FACTORS = {
    11: 1.0,   # 平原
    12: 0.9,   # 草地
    13: 0.8,   # 灌木
    21: 0.7,   # 山地
    22: 0.8,   # 丘陵
    23: 0.9,   # 高原
    31: 0.0,   # 水体
    41: 0.0,   # 冰川
    51: 0.6,   # 建筑区
    61: 0.7,   # 农田
    71: 0.8,   # 林地
    81: 0.0,   # 沼泽
    82: 0.0,   # 盐碱地
}

# 土地覆盖成本因子
LANDCOVER_COST_FACTORS = {
    11: 1.0,   # 平原
    12: 1.2,   # 草地
    13: 1.3,   # 灌木
    21: 1.5,   # 山地
    22: 1.3,   # 丘陵
    23: 1.2,   # 高原
    51: 1.4,   # 建筑区
    61: 1.2,   # 农田
    71: 1.3,   # 林地
}

# 不可通行土地覆盖代码
IMPASSABLE_LANDCOVER_CODES = [
    31,  # 水体
    41,  # 冰川
    81,  # 沼泽
    82,  # 盐碱地
]

# 起点选择相关参数
MIN_START_END_DISTANCE_METERS = 1000.0  # 起终点最小距离（米）
MIN_START_POINTS_SPACING = 250.0        # 起点之间的最小间距（米）
MAX_SEARCH_RADIUS = 5000.0             # 最大搜索半径（米）
MAX_SEARCH_ATTEMPTS = 1000             # 最大搜索尝试次数 
```

### src/generator/data_loader.py
```python
"""数据加载器模块

此模块负责加载和预处理OORD轨迹数据，功能包括：
1. 读取轨迹文件(CSV/GPX)
2. 统一坐标系
3. 计算运动参数(速度、朝向、转向率、加速度)
4. 将地理坐标转换为像素坐标

输入:
    - OORD轨迹文件 (CSV/GPX格式)
    - GIS环境数据的地理参考信息

输出:
    - 预处理后的轨迹DataFrame，包含：
        - timestamp: 时间戳
        - row, col: 像素坐标
        - lon, lat: 地理坐标
        - speed_mps: 速度(米/秒)
        - heading_degrees: 朝向(度)
        - turn_rate_dps: 转向率(度/秒)
        - acceleration_mps2: 加速度(米/秒²)
        - trajectory_id: 轨迹ID
"""

import pandas as pd
import numpy as np
import glob
import os
from pathlib import Path
import logging
from typing import List, Tuple, Union
import rasterio
from rasterio.transform import Affine
import gpxpy
from datetime import datetime
import pytz

class DataLoader:
    """数据加载器类"""
    
    def __init__(self, gis_transform: Affine, gis_shape: Tuple[int, int]):
        """初始化数据加载器
        
        Args:
            gis_transform: GIS数据的地理变换矩阵
            gis_shape: GIS数据的形状(height, width)
        """
        self.transform = gis_transform
        self.height, self.width = gis_shape
        self.logger = logging.getLogger(__name__)
    
    def load_trajectory_file(self, file_path: str) -> pd.DataFrame:
        """加载单个轨迹文件
        
        支持CSV和GPX格式。
        CSV格式要求包含timestamp、longitude、latitude列。
        
        Args:
            file_path: 轨迹文件路径
            
        Returns:
            pd.DataFrame: 预处理后的轨迹数据
        """
        # 获取文件扩展名
        ext = Path(file_path).suffix.lower()
        
        # 根据文件类型选择加载方法
        if ext == '.csv':
            df = self._load_csv(file_path)
        elif ext == '.gpx':
            df = self._load_gpx(file_path)
        else:
            raise ValueError(f"不支持的文件格式: {ext}")
        
        # 预处理数据
        df = self._preprocess_trajectory(df)
        
        return df
    
    def load_all_trajectories(self, data_dir: str) -> pd.DataFrame:
        """加载目录下的所有轨迹文件
        
        Args:
            data_dir: 数据目录路径
            
        Returns:
            pd.DataFrame: 合并后的轨迹数据
        """
        # 获取所有轨迹文件
        csv_files = glob.glob(os.path.join(data_dir, "*.csv"))
        gpx_files = glob.glob(os.path.join(data_dir, "*.gpx"))
        all_files = csv_files + gpx_files
        
        if not all_files:
            raise FileNotFoundError(f"在目录 {data_dir} 中未找到轨迹文件")
        
        # 加载所有文件
        dfs = []
        for file_path in all_files:
            try:
                df = self.load_trajectory_file(file_path)
                # 添加轨迹ID
                df['trajectory_id'] = Path(file_path).stem
                dfs.append(df)
            except Exception as e:
                self.logger.error(f"加载文件 {file_path} 失败: {e}")
                continue
        
        # 合并所有数据
        if not dfs:
            raise ValueError("没有成功加载任何轨迹文件")
        
        merged_df = pd.concat(dfs, ignore_index=True)
        return merged_df
    
    def _load_csv(self, file_path: str) -> pd.DataFrame:
        """加载CSV格式的轨迹文件
        
        Args:
            file_path: CSV文件路径
            
        Returns:
            pd.DataFrame: 原始轨迹数据
        """
        try:
            df = pd.read_csv(file_path)
            required_cols = ['timestamp', 'longitude', 'latitude']
            if not all(col in df.columns for col in required_cols):
                raise ValueError(f"CSV文件缺少必需的列: {required_cols}")
            
            # 确保时间戳格式正确
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            
            return df
        except Exception as e:
            raise ValueError(f"加载CSV文件失败: {e}")
    
    def _load_gpx(self, file_path: str) -> pd.DataFrame:
        """加载GPX格式的轨迹文件
        
        Args:
            file_path: GPX文件路径
            
        Returns:
            pd.DataFrame: 原始轨迹数据
        """
        try:
            with open(file_path, 'r') as gpx_file:
                gpx = gpxpy.parse(gpx_file)
            
            data = []
            for track in gpx.tracks:
                for segment in track.segments:
                    for point in segment.points:
                        data.append({
                            'timestamp': point.time.replace(tzinfo=None),
                            'longitude': point.longitude,
                            'latitude': point.latitude
                        })
            
            return pd.DataFrame(data)
        except Exception as e:
            raise ValueError(f"加载GPX文件失败: {e}")
    
    def _preprocess_trajectory(self, df: pd.DataFrame) -> pd.DataFrame:
        """预处理轨迹数据
        
        1. 计算像素坐标
        2. 计算速度
        3. 计算朝向
        4. 计算转向率
        5. 计算加速度
        
        Args:
            df: 原始轨迹数据
            
        Returns:
            pd.DataFrame: 预处理后的轨迹数据
        """
        # 确保时间戳已排序
        df = df.sort_values('timestamp')
        
        # 计算像素坐标
        rows, cols = self._convert_to_pixel_coords(df['latitude'].values, df['longitude'].values)
        df['row'] = rows
        df['col'] = cols
        
        # 计算时间差(秒)
        df['dt'] = df['timestamp'].diff().dt.total_seconds()
        
        # 计算位移和速度
        df['dx'] = df['longitude'].diff() * 111320 * np.cos(np.radians(df['latitude']))  # 米
        df['dy'] = df['latitude'].diff() * 111320  # 米
        df['distance'] = np.sqrt(df['dx']**2 + df['dy']**2)  # 米
        df['speed_mps'] = df['distance'] / df['dt']
        
        # 计算朝向(度)
        df['heading_degrees'] = np.degrees(np.arctan2(df['dx'], df['dy']))
        df['heading_degrees'] = (90 - df['heading_degrees']) % 360  # 转换为北为0
        
        # 计算转向率(度/秒)
        df['heading_change'] = df['heading_degrees'].diff()
        # 处理角度环绕
        df.loc[df['heading_change'] > 180, 'heading_change'] -= 360
        df.loc[df['heading_change'] < -180, 'heading_change'] += 360
        df['turn_rate_dps'] = df['heading_change'] / df['dt']
        
        # 计算加速度(米/秒²)
        df['acceleration_mps2'] = df['speed_mps'].diff() / df['dt']
        
        # 清理临时列和无效值
        df = df.drop(['dx', 'dy', 'distance', 'dt', 'heading_change'], axis=1)
        df = df.fillna(0)  # 第一个点的差分值设为0
        
        # 移除异常值
        df = self._remove_outliers(df)
        
        return df
    
    def _convert_to_pixel_coords(self, lats: np.ndarray, lons: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """将地理坐标转换为像素坐标
        
        Args:
            lats: 纬度数组
            lons: 经度数组
            
        Returns:
            Tuple[np.ndarray, np.ndarray]: (行坐标数组, 列坐标数组)
        """
        # 使用仿射变换矩阵进行转换
        cols, rows = ~self.transform * (lons, lats)
        
        # 确保坐标在有效范围内
        rows = np.clip(rows, 0, self.height - 1)
        cols = np.clip(cols, 0, self.width - 1)
        
        return rows.astype(int), cols.astype(int)
    
    def _remove_outliers(self, df: pd.DataFrame, speed_threshold: float = 50.0,
                        acc_threshold: float = 10.0, turn_rate_threshold: float = 90.0) -> pd.DataFrame:
        """移除异常值
        
        Args:
            df: 轨迹数据
            speed_threshold: 速度阈值(米/秒)
            acc_threshold: 加速度阈值(米/秒²)
            turn_rate_threshold: 转向率阈值(度/秒)
            
        Returns:
            pd.DataFrame: 清理后的数据
        """
        # 创建掩码
        mask = (
            (df['speed_mps'] <= speed_threshold) &
            (abs(df['acceleration_mps2']) <= acc_threshold) &
            (abs(df['turn_rate_dps']) <= turn_rate_threshold)
        )
        
        # 记录被移除的点数
        removed_count = (~mask).sum()
        if removed_count > 0:
            self.logger.warning(f"移除了 {removed_count} 个异常值")
        
        return df[mask].copy() 
```

### src/generator/environment_mapper.py
```python
"""环境地图生成器模块

此模块负责生成环境地图，包括：
1. 最大速度地图：基于坡度大小和土地覆盖类型
2. 典型速度地图：考虑坡度方向对速度的影响
3. 速度标准差地图：反映速度的变化程度
4. 成本地图：用于路径规划

输入:
    - 土地覆盖栅格文件 (.tif)
    - 坡度大小栅格文件 (.tif)
    - 坡度方向栅格文件 (.tif)

输出:
    - 最大速度地图 (max_speed_map.tif)
    - 典型速度地图 (typical_speed_map.tif)
    - 速度标准差地图 (speed_stddev_map.tif)
    - 成本地图 (cost_map.tif)
"""

import numpy as np
import rasterio
from pathlib import Path
import logging
from typing import Tuple, Optional
import os

from src.generator.config import (
    MAX_SPEED, MAX_SLOPE_THRESHOLD, SLOPE_SPEED_FACTOR,
    TYPICAL_SPEED_FACTOR, UP_SLOPE_FACTOR, DOWN_SLOPE_FACTOR, CROSS_SLOPE_FACTOR,
    BASE_SPEED_STDDEV_FACTOR, SLOPE_STDDEV_FACTOR, COMPLEX_TERRAIN_STDDEV_FACTOR,
    COMPLEX_TERRAIN_CODES, LANDCOVER_SPEED_FACTORS, LANDCOVER_COST_FACTORS,
    IMPASSABLE_LANDCOVER_CODES
)

class EnvironmentMapper:
    """环境地图生成器类"""
    
    def __init__(self, landcover_path: str, slope_magnitude_path: str, slope_aspect_path: str):
        """初始化环境地图生成器
        
        Args:
            landcover_path: 土地覆盖栅格文件路径
            slope_magnitude_path: 坡度大小栅格文件路径
            slope_aspect_path: 坡度方向栅格文件路径
        """
        # 检查文件是否存在
        for path in [landcover_path, slope_magnitude_path, slope_aspect_path]:
            if not Path(path).exists():
                raise FileNotFoundError(f"找不到文件: {path}")
        
        # 读取栅格数据
        with rasterio.open(landcover_path) as src:
            self.landcover_data = src.read(1)
            self.transform = src.transform
            self.meta = src.meta.copy()
            self.height = src.height
            self.width = src.width
        
        with rasterio.open(slope_magnitude_path) as src:
            self.slope_magnitude_data = src.read(1)
        
        with rasterio.open(slope_aspect_path) as src:
            self.slope_aspect_data = src.read(1)
        
        # 验证数据形状一致
        if not (self.landcover_data.shape == self.slope_magnitude_data.shape == self.slope_aspect_data.shape):
            raise ValueError("输入数据形状不一致")
        
        # 初始化日志
        self.logger = logging.getLogger(__name__)
    
    def calculate_max_speed_map(self) -> np.ndarray:
        """计算最大速度地图
        
        基于坡度大小和土地覆盖类型计算每个像素的最大可能速度。
        不可通行区域（水体、冰川、陡峭区域）的速度设为0。
        
        Returns:
            np.ndarray: 最大速度地图（米/秒）
        """
        # 初始化最大速度地图
        max_speed = np.full(self.landcover_data.shape, MAX_SPEED, dtype=np.float32)
        
        # 处理不可通行区域
        impassable_mask = np.isin(self.landcover_data, IMPASSABLE_LANDCOVER_CODES)
        steep_mask = self.slope_magnitude_data > MAX_SLOPE_THRESHOLD
        max_speed[impassable_mask | steep_mask] = 0
        
        # 应用坡度影响
        slope_factor = np.clip(1 - SLOPE_SPEED_FACTOR * self.slope_magnitude_data, 0.1, 1.0)
        max_speed *= slope_factor
        
        # 应用土地覆盖影响
        for code, factor in LANDCOVER_SPEED_FACTORS.items():
            landcover_mask = self.landcover_data == code
            max_speed[landcover_mask] *= factor
        
        return max_speed
    
    def calculate_typical_speed_map(self) -> np.ndarray:
        """计算典型速度地图
        
        基于最大速度，考虑坡度方向对速度的影响。
        上坡时速度降低，下坡时速度略有提升，横坡时速度显著降低。
        
        Returns:
            np.ndarray: 典型速度地图（米/秒）
        """
        # 获取基础最大速度
        typical_speed = self.calculate_max_speed_map() * TYPICAL_SPEED_FACTOR
        
        # 处理平地（坡向为-1）
        flat_mask = self.slope_aspect_data == -1
        typical_speed[flat_mask] *= 1.0  # 平地不需要额外调整
        
        # 处理有坡度的区域
        slope_mask = ~flat_mask
        if np.any(slope_mask):
            # 计算不同方向的影响因子
            # 这里假设我们主要考虑南北方向的运动
            # 坡向0度是北向，180度是南向
            north_factor = np.where(
                self.slope_aspect_data < 90,
                1 - UP_SLOPE_FACTOR * self.slope_magnitude_data,
                1.0
            )
            south_factor = np.where(
                self.slope_aspect_data > 90,
                1 + DOWN_SLOPE_FACTOR * self.slope_magnitude_data,
                1.0
            )
            
            # 计算横坡影响（东西方向）
            cross_slope_factor = np.where(
                (self.slope_aspect_data >= 45) & (self.slope_aspect_data <= 135) |
                (self.slope_aspect_data >= 225) & (self.slope_aspect_data <= 315),
                1 - CROSS_SLOPE_FACTOR * self.slope_magnitude_data,
                1.0
            )
            
            # 组合所有影响因子
            combined_factor = np.minimum(north_factor, south_factor) * cross_slope_factor
            combined_factor = np.clip(combined_factor, 0.1, 1.2)  # 限制因子范围
            
            # 应用到典型速度
            typical_speed[slope_mask] *= combined_factor[slope_mask]
        
        return typical_speed
    
    def calculate_speed_stddev_map(self) -> np.ndarray:
        """计算速度标准差地图
        
        基于典型速度和地形复杂度计算速度的标准差。
        复杂地形（如山地）的标准差较大，平坦区域的标准差较小。
        
        Returns:
            np.ndarray: 速度标准差地图（米/秒）
        """
        # 获取典型速度
        typical_speed = self.calculate_typical_speed_map()
        
        # 初始化标准差地图
        speed_stddev = typical_speed * BASE_SPEED_STDDEV_FACTOR
        
        # 处理不可通行区域
        impassable_mask = np.isin(self.landcover_data, IMPASSABLE_LANDCOVER_CODES)
        steep_mask = self.slope_magnitude_data > MAX_SLOPE_THRESHOLD
        speed_stddev[impassable_mask | steep_mask] = 0
        
        # 增加复杂地形的标准差
        complex_mask = np.isin(self.landcover_data, COMPLEX_TERRAIN_CODES)
        speed_stddev[complex_mask] *= COMPLEX_TERRAIN_STDDEV_FACTOR
        
        # 根据坡度增加标准差
        slope_stddev_factor = np.clip(
            1 + SLOPE_STDDEV_FACTOR * (self.slope_magnitude_data / MAX_SLOPE_THRESHOLD),
            1.0,
            2.0
        )
        speed_stddev *= slope_stddev_factor
        
        return speed_stddev
    
    def calculate_cost_map(self) -> np.ndarray:
        """计算成本地图
        
        基于典型速度和土地覆盖类型计算通行成本。
        不可通行区域的成本设为无穷大。
        
        Returns:
            np.ndarray: 成本地图（秒/米）
        """
        # 获取典型速度
        typical_speed = self.calculate_typical_speed_map()
        
        # 初始化成本地图
        cost = np.zeros_like(typical_speed)
        
        # 处理不可通行区域
        impassable_mask = np.isin(self.landcover_data, IMPASSABLE_LANDCOVER_CODES)
        steep_mask = self.slope_magnitude_data > MAX_SLOPE_THRESHOLD
        cost[impassable_mask | steep_mask] = np.inf
        
        # 计算可通行区域的成本
        passable_mask = ~(impassable_mask | steep_mask)
        cost[passable_mask] = 1 / typical_speed[passable_mask]  # 基础成本：单位距离所需时间
        
        # 应用土地覆盖成本因子
        for code, factor in LANDCOVER_COST_FACTORS.items():
            landcover_mask = self.landcover_data == code
            cost[landcover_mask & passable_mask] *= factor
        
        return cost
    
    def save_environment_maps(
        self,
        output_dir: str,
        max_speed_map: np.ndarray,
        typical_speed_map: np.ndarray,
        speed_stddev_map: np.ndarray,
        cost_map: np.ndarray
    ) -> None:
        """保存环境地图
        
        Args:
            output_dir: 输出目录路径
            max_speed_map: 最大速度地图
            typical_speed_map: 典型速度地图
            speed_stddev_map: 速度标准差地图
            cost_map: 成本地图
        """
        # 确保输出目录存在
        os.makedirs(output_dir, exist_ok=True)
        
        # 准备元数据
        meta = self.meta.copy()
        meta.update(dtype=np.float32)
        
        # 保存最大速度地图
        with rasterio.open(os.path.join(output_dir, "max_speed_map.tif"), 'w', **meta) as dst:
            dst.write(max_speed_map.astype(np.float32), 1)
        
        # 保存典型速度地图
        with rasterio.open(os.path.join(output_dir, "typical_speed_map.tif"), 'w', **meta) as dst:
            dst.write(typical_speed_map.astype(np.float32), 1)
        
        # 保存速度标准差地图
        with rasterio.open(os.path.join(output_dir, "speed_stddev_map.tif"), 'w', **meta) as dst:
            dst.write(speed_stddev_map.astype(np.float32), 1)
        
        # 保存成本地图
        with rasterio.open(os.path.join(output_dir, "cost_map.tif"), 'w', **meta) as dst:
            dst.write(cost_map.astype(np.float32), 1)
        
        self.logger.info(f"环境地图已保存到目录: {output_dir}")
    
    def get_environment_params(self, row: int, col: int) -> dict:
        """获取指定位置的环境参数
        
        Args:
            row: 像素行号（从0开始）
            col: 像素列号（从0开始）
            
        Returns:
            包含环境参数的字典：
            {
                'max_speed': 最大速度 (m/s),
                'typical_speed': 典型速度 (m/s),
                'speed_stddev': 速度标准差 (m/s),
                'cost': 移动成本 (s/m),
                'landcover': 土地覆盖类型代码,
                'slope_magnitude': 坡度大小 (度),
                'slope_aspect': 坡向 (度),
                'is_passable': 是否可通行
            }
        
        Raises:
            ValueError: 如果位置超出范围
        """
        # 检查位置是否在有效范围内
        if not (0 <= row < self.height and 0 <= col < self.width):
            raise ValueError(f"位置 ({row}, {col}) 超出范围")
        
        # 获取土地覆盖和坡度信息
        landcover = self.landcover_data[row, col]
        slope_magnitude = self.slope_magnitude_data[row, col]
        slope_aspect = self.slope_aspect_data[row, col]
        
        # 判断是否可通行
        is_passable = (
            landcover not in IMPASSABLE_LANDCOVER_CODES and
            slope_magnitude <= MAX_SLOPE_THRESHOLD
        )
        
        # 获取环境参数
        max_speed = self.calculate_max_speed_map()[row, col]
        typical_speed = self.calculate_typical_speed_map()[row, col]
        speed_stddev = self.calculate_speed_stddev_map()[row, col]
        cost = self.calculate_cost_map()[row, col]
        
        return {
            'max_speed': float(max_speed),
            'typical_speed': float(typical_speed),
            'speed_stddev': float(speed_stddev),
            'cost': float(cost),
            'landcover': int(landcover),
            'slope_magnitude': float(slope_magnitude),
            'slope_aspect': float(slope_aspect),
            'is_passable': bool(is_passable)
        } 
```

### src/generator/evaluator.py
```python
"""轨迹评估器模块

负责评估生成的轨迹与OORD数据的相似度。

输入:
- 生成的轨迹数据
- OORD参考数据
- 环境数据

输出:
- 评估报告（图表和统计数据）
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
from typing import List, Dict, Tuple
import logging
from pathlib import Path
import json

logger = logging.getLogger(__name__)

class Evaluator:
    """轨迹评估器类"""

    def __init__(self, config: dict, output_dir: str):
        """初始化评估器

        Args:
            config: 配置字典
            output_dir: 输出目录路径
        """
        self.config = config
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # 设置图表样式
        plt.style.use('seaborn')
        sns.set_palette("husl")

    def load_synthetic_data(self, batch_dir: str) -> pd.DataFrame:
        """加载生成的轨迹数据

        Args:
            batch_dir: 批处理输出目录

        Returns:
            pd.DataFrame: 包含所有生成轨迹的DataFrame
        """
        logger.info(f"加载生成的轨迹数据: {batch_dir}")
        
        # 读取所有轨迹文件
        trajectories = []
        batch_path = Path(batch_dir)
        for traj_file in batch_path.glob("trajectory_*.csv"):
            df = pd.read_csv(traj_file)
            df['trajectory_id'] = traj_file.stem
            trajectories.append(df)

        # 合并所有轨迹
        if not trajectories:
            raise ValueError(f"在 {batch_dir} 中未找到轨迹文件")
            
        return pd.concat(trajectories, ignore_index=True)

    def load_processed_oord_data(self, oord_path: str) -> pd.DataFrame:
        """加载处理好的OORD数据

        Args:
            oord_path: OORD数据文件路径

        Returns:
            pd.DataFrame: OORD数据
        """
        logger.info(f"加载OORD参考数据: {oord_path}")
        return pd.read_csv(oord_path)

    def compare_global_distributions(self, synthetic_df: pd.DataFrame,
                                  oord_df: pd.DataFrame) -> Dict:
        """比较全局统计分布

        Args:
            synthetic_df: 生成的轨迹数据
            oord_df: OORD参考数据

        Returns:
            Dict: 比较结果
        """
        logger.info("比较全局统计分布...")
        
        results = {}
        
        # 比较速度分布
        self._compare_distribution(
            synthetic_df['speed_mps'],
            oord_df['speed_mps'],
            'speed_distribution.png',
            '速度分布对比 (m/s)',
            results
        )
        
        # 比较加速度分布
        synthetic_acc = synthetic_df.groupby('trajectory_id')['speed_mps'].diff() / \
                       synthetic_df.groupby('trajectory_id')['timestamp'].diff()
        oord_acc = oord_df.groupby('trajectory_id')['speed_mps'].diff() / \
                  oord_df.groupby('trajectory_id')['timestamp'].diff()
        
        self._compare_distribution(
            synthetic_acc,
            oord_acc,
            'acceleration_distribution.png',
            '加速度分布对比 (m/s²)',
            results
        )
        
        # 比较转向率分布
        synthetic_turn = synthetic_df.groupby('trajectory_id')['heading_degrees'].diff() / \
                        synthetic_df.groupby('trajectory_id')['timestamp'].diff()
        oord_turn = oord_df.groupby('trajectory_id')['heading_degrees'].diff() / \
                   oord_df.groupby('trajectory_id')['timestamp'].diff()
        
        self._compare_distribution(
            synthetic_turn,
            oord_turn,
            'turn_rate_distribution.png',
            '转向率分布对比 (度/s)',
            results
        )
        
        return results

    def compare_environment_interaction(self, synthetic_df: pd.DataFrame,
                                     oord_df: pd.DataFrame) -> Dict:
        """比较与环境的交互特征

        Args:
            synthetic_df: 生成的轨迹数据
            oord_df: OORD参考数据

        Returns:
            Dict: 比较结果
        """
        logger.info("比较环境交互特征...")
        
        results = {}
        
        # 按坡度等级分组比较
        slope_bins = self.config['SLOPE_BINS']
        synthetic_df['slope_group'] = pd.cut(synthetic_df['slope_magnitude'],
                                           bins=slope_bins,
                                           labels=[f"{a:.1f}-{b:.1f}" for a, b in 
                                                 zip(slope_bins[:-1], slope_bins[1:])])
        oord_df['slope_group'] = pd.cut(oord_df['slope_magnitude'],
                                       bins=slope_bins,
                                       labels=[f"{a:.1f}-{b:.1f}" for a, b in 
                                             zip(slope_bins[:-1], slope_bins[1:])])
        
        # 绘制不同坡度下的速度箱线图
        plt.figure(figsize=(12, 6))
        plt.subplot(121)
        sns.boxplot(data=synthetic_df, x='slope_group', y='speed_mps')
        plt.title('生成轨迹: 坡度-速度关系')
        plt.xticks(rotation=45)
        
        plt.subplot(122)
        sns.boxplot(data=oord_df, x='slope_group', y='speed_mps')
        plt.title('OORD数据: 坡度-速度关系')
        plt.xticks(rotation=45)
        
        plt.tight_layout()
        plt.savefig(self.output_dir / 'slope_speed_relationship.png')
        plt.close()
        
        # 计算每个坡度组的统计量
        for slope_group in synthetic_df['slope_group'].unique():
            syn_speeds = synthetic_df[synthetic_df['slope_group'] == slope_group]['speed_mps']
            oord_speeds = oord_df[oord_df['slope_group'] == slope_group]['speed_mps']
            
            results[f'slope_group_{slope_group}'] = {
                'synthetic_mean': syn_speeds.mean(),
                'oord_mean': oord_speeds.mean(),
                'synthetic_std': syn_speeds.std(),
                'oord_std': oord_speeds.std(),
                'ks_statistic': stats.ks_2samp(syn_speeds, oord_speeds).statistic
            }
        
        return results

    def _compare_distribution(self, synthetic_data: pd.Series,
                            oord_data: pd.Series,
                            output_filename: str,
                            title: str,
                            results: Dict) -> None:
        """比较两个分布并生成可视化

        Args:
            synthetic_data: 生成的数据
            oord_data: OORD参考数据
            output_filename: 输出文件名
            title: 图表标题
            results: 结果字典
        """
        # 计算统计量
        syn_stats = {
            'mean': synthetic_data.mean(),
            'std': synthetic_data.std(),
            'median': synthetic_data.median(),
            'q1': synthetic_data.quantile(0.25),
            'q3': synthetic_data.quantile(0.75)
        }
        
        oord_stats = {
            'mean': oord_data.mean(),
            'std': oord_data.std(),
            'median': oord_data.median(),
            'q1': oord_data.quantile(0.25),
            'q3': oord_data.quantile(0.75)
        }
        
        # 执行K-S检验
        ks_stat, p_value = stats.ks_2samp(synthetic_data.dropna(),
                                         oord_data.dropna())
        
        # 绘制分布对比图
        plt.figure(figsize=(10, 6))
        sns.kdeplot(data=synthetic_data, label='生成轨迹')
        sns.kdeplot(data=oord_data, label='OORD数据')
        plt.title(title)
        plt.legend()
        plt.grid(True)
        plt.savefig(self.output_dir / output_filename)
        plt.close()
        
        # 保存结果
        metric_name = output_filename.split('.')[0]
        results[metric_name] = {
            'synthetic_stats': syn_stats,
            'oord_stats': oord_stats,
            'ks_test': {
                'statistic': ks_stat,
                'p_value': p_value
            }
        }

    def save_report(self, results: Dict) -> None:
        """保存评估报告

        Args:
            results: 评估结果
        """
        # 保存JSON格式的详细结果
        with open(self.output_dir / 'evaluation_results.json', 'w') as f:
            json.dump(results, f, indent=4)
        
        # 生成文本报告
        report_lines = [
            "轨迹生成评估报告",
            "=" * 50,
            "",
            "1. 全局统计比较",
            "-" * 20
        ]
        
        for metric, data in results.items():
            if metric.endswith('_distribution'):
                report_lines.extend([
                    f"\n{metric.replace('_', ' ').title()}:",
                    f"生成轨迹: 均值={data['synthetic_stats']['mean']:.2f}, "
                    f"标准差={data['synthetic_stats']['std']:.2f}",
                    f"OORD数据: 均值={data['oord_stats']['mean']:.2f}, "
                    f"标准差={data['oord_stats']['std']:.2f}",
                    f"K-S检验: 统计量={data['ks_test']['statistic']:.3f}, "
                    f"p值={data['ks_test']['p_value']:.3f}"
                ])
        
        report_lines.extend([
            "",
            "2. 环境交互分析",
            "-" * 20
        ])
        
        for key, data in results.items():
            if key.startswith('slope_group'):
                report_lines.extend([
                    f"\n{key}:",
                    f"生成轨迹: 均值={data['synthetic_mean']:.2f}, "
                    f"标准差={data['synthetic_std']:.2f}",
                    f"OORD数据: 均值={data['oord_mean']:.2f}, "
                    f"标准差={data['oord_std']:.2f}",
                    f"K-S统计量: {data['ks_statistic']:.3f}"
                ])
        
        # 保存文本报告
        with open(self.output_dir / 'evaluation_report.txt', 'w') as f:
            f.write('\n'.join(report_lines))
        
        logger.info(f"评估报告已保存到: {self.output_dir}")

    def evaluate_batch(self, batch_dir: str, oord_path: str) -> None:
        """评估一批生成的轨迹

        Args:
            batch_dir: 批处理输出目录
            oord_path: OORD数据文件路径
        """
        # 加载数据
        synthetic_df = self.load_synthetic_data(batch_dir)
        oord_df = self.load_processed_oord_data(oord_path)
        
        # 执行评估
        results = {}
        results.update(self.compare_global_distributions(synthetic_df, oord_df))
        results.update(self.compare_environment_interaction(synthetic_df, oord_df))
        
        # 保存报告
        self.save_report(results) 
```

### src/generator/motion_simulator.py
```python
"""运动模拟器模块

负责模拟目标在给定路径上的运动，考虑环境因素（坡度、土地覆盖）对速度和方向的影响。

输入参数:
- 路径点列表
- 环境参数（最大速度、典型速度、速度标准差）
- 运动约束（最大加速度、最大减速度、最大转向率）

输出:
- 轨迹点列表，包含时间戳、位置、速度和朝向
"""

import logging
import numpy as np
from typing import List, Tuple, Dict, Optional
from dataclasses import dataclass

# 配置日志
logger = logging.getLogger(__name__)

@dataclass
class MotionConstraints:
    """运动约束参数"""
    max_acceleration: float = 2.0  # 最大加速度 (m/s^2)
    max_deceleration: float = 4.0  # 最大减速度 (m/s^2)
    max_turn_rate: float = 45.0    # 最大转向率 (度/秒)
    min_speed: float = 0.0         # 最小速度 (m/s)
    time_step: float = 1.0         # 模拟时间步长 (秒)
    max_iterations: int = 10000    # 最大迭代次数
    position_threshold: float = 0.1  # 位置判断阈值 (m)

@dataclass
class EnvironmentParams:
    """环境参数
    
    Attributes:
        max_speed: 最大允许速度 (m/s)
        typical_speed: 典型速度 (m/s)
        speed_stddev: 速度标准差 (m/s)
        slope_magnitude: 坡度大小 (度)
        slope_aspect: 坡向角度 (度，北为0，顺时针)
        landcover_code: 土地覆盖类型编码
    """
    max_speed: float       # 最大允许速度 (m/s)
    typical_speed: float   # 典型速度 (m/s)
    speed_stddev: float   # 速度标准差 (m/s)
    slope_magnitude: float = 0.0  # 坡度大小 (度)
    slope_aspect: float = 0.0     # 坡向角度 (度，北为0，顺时针)
    landcover_code: int = 0       # 土地覆盖类型编码

@dataclass
class TerrainConstraints:
    """地形约束参数"""
    max_uphill_slope: float = 30.0    # 最大上坡坡度 (度)
    max_downhill_slope: float = 35.0  # 最大下坡坡度 (度)
    max_cross_slope: float = 25.0     # 最大横坡坡度 (度)
    k_uphill: float = 0.1             # 上坡减速系数
    k_downhill: float = 0.05          # 下坡加速系数
    k_cross: float = 0.2              # 横坡减速系数
    min_speed_steep_slope: float = 0.5 # 陡坡最小速度 (m/s)

class MotionSimulator:
    """运动模拟器类"""

    def __init__(self, motion_constraints: Optional[MotionConstraints] = None,
                 terrain_constraints: Optional[TerrainConstraints] = None):
        """初始化运动模拟器

        Args:
            motion_constraints: 运动约束参数，如果为None则使用默认值
            terrain_constraints: 地形约束参数，如果为None则使用默认值
        """
        self.motion_constraints = motion_constraints or MotionConstraints()
        self.terrain_constraints = terrain_constraints or TerrainConstraints()
        
        # 用于速度随机性的高斯噪声参数
        self.speed_noise_scale = 0.1  # 速度噪声比例
        self.heading_noise_scale = 2.0  # 朝向噪声（度）

    def _calculate_slope_effects(self, current_heading: float,
                              env_params: EnvironmentParams) -> Tuple[float, float, float]:
        """计算坡度对速度的影响

        Args:
            current_heading: 当前朝向 (度)
            env_params: 环境参数

        Returns:
            Tuple[float, float, float]: (纵向坡度, 横向坡度, 速度调整系数)
        """
        # 如果没有坡度信息，返回默认值
        if env_params.slope_magnitude == 0:
            return 0.0, 0.0, 1.0

        # 计算行驶方向与坡向的夹角
        delta_angle = current_heading - env_params.slope_aspect
        delta_angle_rad = np.radians(delta_angle)

        # 计算纵向坡度（上下坡）和横向坡度
        slope_along_path = env_params.slope_magnitude * np.cos(delta_angle_rad)
        cross_slope = env_params.slope_magnitude * abs(np.sin(delta_angle_rad))

        # 计算速度调整系数
        speed_factor = 1.0

        # 上坡减速
        if slope_along_path > 0:
            if slope_along_path > self.terrain_constraints.max_uphill_slope:
                speed_factor = 0.0  # 超过最大上坡坡度，无法通行
            else:
                reduction = max(0.1, 1 - self.terrain_constraints.k_uphill * slope_along_path)
                speed_factor *= reduction

        # 下坡加速/减速
        else:
            slope_down = -slope_along_path
            if slope_down > self.terrain_constraints.max_downhill_slope:
                speed_factor = 0.0  # 超过最大下坡坡度，无法通行
            else:
                # 下坡时轻微加速，但需要考虑制动限制
                factor = 1 + self.terrain_constraints.k_downhill * slope_down
                speed_factor *= min(factor, 1.2)  # 最多增加20%速度

        # 横坡减速
        if cross_slope > 0:
            if cross_slope > self.terrain_constraints.max_cross_slope:
                speed_factor = 0.0  # 超过最大横坡坡度，无法通行
            else:
                # 使用二次函数使横坡影响更敏感
                reduction = max(0.1, 1 - self.terrain_constraints.k_cross * (cross_slope ** 2))
                speed_factor *= reduction

        # 确保速度不会过低（除非完全无法通行）
        if speed_factor > 0:
            speed_factor = max(speed_factor, 
                             self.terrain_constraints.min_speed_steep_slope / env_params.typical_speed)

        return slope_along_path, cross_slope, speed_factor

    def _calculate_target_speed(self, env_params: EnvironmentParams,
                              current_heading: float) -> float:
        """计算目标速度，考虑环境限制、坡度影响和随机性

        Args:
            env_params: 环境参数
            current_heading: 当前朝向 (度)

        Returns:
            目标速度 (m/s)
        """
        # 基础目标速度是典型速度
        base_speed = env_params.typical_speed
        
        # 计算坡度影响
        _, _, speed_factor = self._calculate_slope_effects(current_heading, env_params)
        
        # 应用坡度影响
        base_speed *= speed_factor
        
        # 添加随机扰动（高斯噪声）
        noise = np.random.normal(0, env_params.speed_stddev * self.speed_noise_scale)
        target_speed = base_speed + noise
        
        # 限制在合理范围内
        target_speed = np.clip(
            target_speed,
            self.motion_constraints.min_speed,
            min(env_params.max_speed, env_params.typical_speed * 1.5)
        )
        
        return target_speed

    def simulate_motion(self, path: List[Tuple[float, float]],
                       env_params_func) -> List[Tuple[float, float, float, float, float]]:
        """模拟目标在给定路径上的运动

        Args:
            path: 路径点列表 [(lon, lat), ...]
            env_params_func: 函数，输入(lon, lat)返回对应位置的EnvironmentParams

        Returns:
            轨迹点列表 [(timestamp, lon, lat, speed, heading), ...]
        """
        if len(path) < 2:
            raise ValueError("路径至少需要包含两个点")

        # 初始化轨迹
        trajectory = []
        current_time = 0.0
        current_pos = path[0]
        current_speed = 0.0
        current_heading = self._calculate_initial_heading(path[0], path[1])
        
        # 添加初始点
        trajectory.append((
            current_time,
            current_pos[0],
            current_pos[1],
            current_speed,
            current_heading
        ))

        # 遍历路径点
        path_index = 1
        iteration_count = 0
        
        while path_index < len(path) and iteration_count < self.motion_constraints.max_iterations:
            # 获取目标点
            target_pos = path[path_index]
            
            # 获取当前位置的环境参数
            env_params = env_params_func(current_pos[0], current_pos[1])
            
            # 计算到目标点的距离和方向
            distance = self._calculate_distance(current_pos, target_pos)
            target_heading = self._calculate_heading(current_pos, target_pos)
            
            # 如果已经接近目标点，移动到下一个目标点
            if distance < self.motion_constraints.position_threshold:
                current_pos = target_pos  # 直接移动到目标点
                path_index += 1
                
                # 更新时间和轨迹点
                current_time += self.motion_constraints.time_step
                trajectory.append((
                    current_time,
                    current_pos[0],
                    current_pos[1],
                    current_speed,
                    current_heading
                ))
                
                if path_index < len(path):
                    target_pos = path[path_index]
                    target_heading = self._calculate_heading(current_pos, target_pos)
                    distance = self._calculate_distance(current_pos, target_pos)
                else:
                    # 到达终点，添加最后一个点并退出
                    current_time += self.motion_constraints.time_step
                    trajectory.append((
                        current_time,
                        current_pos[0],
                        current_pos[1],
                        0.0,  # 终点速度为0
                        current_heading
                    ))
                    break
                continue
            
            # 计算目标速度（考虑环境限制、坡度影响和随机性）
            target_speed = self._calculate_target_speed(env_params, current_heading)
            
            # 调整速度和朝向
            current_speed = self._adjust_speed(
                current_speed, target_speed, self.motion_constraints.time_step)
            current_heading = self._adjust_heading(
                current_heading, target_heading, self.motion_constraints.time_step)
            
            # 计算新位置（使用弧度进行计算）
            heading_rad = np.radians(current_heading)
            movement = current_speed * self.motion_constraints.time_step
            
            # 根据当前位置到目标点的距离来调整移动量
            scale = min(1.0, distance / movement) if movement > 0 else 1.0
            movement *= scale
            
            # 计算位置增量
            dx = movement * np.sin(heading_rad)  # 东西方向
            dy = movement * np.cos(heading_rad)  # 南北方向
            
            # 更新位置
            new_pos = (
                current_pos[0] + dx,
                current_pos[1] + dy
            )
            
            # 更新时间和位置
            current_time += self.motion_constraints.time_step
            current_pos = new_pos
            
            # 添加轨迹点
            trajectory.append((
                current_time,
                current_pos[0],
                current_pos[1],
                current_speed,
                current_heading
            ))
            
            iteration_count += 1

        if iteration_count >= self.motion_constraints.max_iterations:
            logger.warning(f"达到最大迭代次数 {self.motion_constraints.max_iterations}")

        return trajectory

    def _adjust_speed(self, current_speed: float,
                     target_speed: float,
                     dt: float) -> float:
        """调整速度，考虑加速度限制

        Args:
            current_speed: 当前速度 (m/s)
            target_speed: 目标速度 (m/s)
            dt: 时间步长 (秒)

        Returns:
            新的速度 (m/s)
        """
        speed_diff = target_speed - current_speed
        
        # 根据加速或减速选择合适的限制
        max_change = (self.motion_constraints.max_acceleration if speed_diff > 0
                     else self.motion_constraints.max_deceleration) * dt
        
        # 限制速度变化
        actual_change = np.clip(speed_diff, -max_change, max_change)
        new_speed = current_speed + actual_change
        
        return max(new_speed, self.motion_constraints.min_speed)

    def _adjust_heading(self, current_heading: float,
                       target_heading: float,
                       dt: float) -> float:
        """调整朝向，考虑转向率限制

        Args:
            current_heading: 当前朝向 (度)
            target_heading: 目标朝向 (度)
            dt: 时间步长 (秒)

        Returns:
            新的朝向 (度)
        """
        # 计算需要转向的角度（处理角度环绕）
        heading_diff = target_heading - current_heading
        if heading_diff > 180:
            heading_diff -= 360
        elif heading_diff < -180:
            heading_diff += 360
            
        # 添加随机扰动
        noise = np.random.normal(0, self.heading_noise_scale)
        heading_diff += noise
        
        # 限制转向率
        max_turn = self.motion_constraints.max_turn_rate * dt
        actual_turn = np.clip(heading_diff, -max_turn, max_turn)
        
        # 计算新的朝向（保持在0-360度范围内）
        new_heading = (current_heading + actual_turn) % 360
            
        return new_heading

    def _calculate_distance(self, pos1: Tuple[float, float],
                          pos2: Tuple[float, float]) -> float:
        """计算两点之间的欧氏距离"""
        return np.sqrt(
            (pos2[0] - pos1[0]) ** 2 +
            (pos2[1] - pos1[1]) ** 2
        )

    def _calculate_heading(self, pos1: Tuple[float, float],
                         pos2: Tuple[float, float]) -> float:
        """计算从pos1到pos2的朝向角（北为0度，顺时针）

        Args:
            pos1: 起始位置 (lon, lat)
            pos2: 目标位置 (lon, lat)

        Returns:
            朝向角（度）：北为0度，东为90度，南为180度，西为270度
        """
        dx = pos2[0] - pos1[0]  # 经度差（东西方向）
        dy = pos2[1] - pos1[1]  # 纬度差（南北方向）
        
        # 使用arctan2计算角度（弧度）
        # 注意：arctan2(y, x)的参数顺序，我们需要交换dx和dy来得到正确的角度
        angle_rad = np.arctan2(dx, dy)
        
        # 转换为度数并调整为以北为0度，东为90度
        angle_deg = np.degrees(angle_rad)
        # 如果角度为负，加360度使其在[0, 360)范围内
        if angle_deg < 0:
            angle_deg += 360
            
        return float(angle_deg)  # 确保返回Python float类型

    def _calculate_initial_heading(self, start_pos: Tuple[float, float],
                                 next_pos: Tuple[float, float]) -> float:
        """计算初始朝向"""
        return self._calculate_heading(start_pos, next_pos) 
```

### src/generator/oord_analyzer.py
```python
"""OORD数据分析器模块

此模块负责分析OORD轨迹数据中的运动特性与环境交互，功能包括：
1. 关联环境信息（高程、坡度、坡向、土地覆盖）
2. 定义环境分组
3. 分组统计分析
4. 建立环境-运动规则模型

输入:
    - 预处理后的OORD轨迹数据
    - 环境数据（DEM、坡度、坡向、土地覆盖）

输出:
    - 环境-运动规则模型
    - 统计分析结果
"""

import pandas as pd
import numpy as np
from pathlib import Path
import logging
from typing import Dict, List, Tuple, Optional
import json
from dataclasses import dataclass
from sklearn.preprocessing import KBinsDiscretizer

@dataclass
class EnvironmentGroup:
    """环境组数据类"""
    group_label: str  # 环境组标签
    landcover_code: int  # 土地覆盖编码
    slope_bin: int  # 坡度等级
    count: int  # 样本数量
    max_speed: float  # 最大速度
    typical_speed: float  # 典型速度
    speed_stddev: float  # 速度标准差
    max_turn_rate: float  # 最大转向率
    typical_turn_rate: float  # 典型转向率
    max_acceleration: float  # 最大加速度
    typical_acceleration: float  # 典型加速度

class OORDAnalyzer:
    """OORD数据分析器类"""
    
    def __init__(self, slope_bins: List[float], min_samples_per_group: int = 100):
        """初始化分析器
        
        Args:
            slope_bins: 坡度分组边界值列表
            min_samples_per_group: 每个环境组的最小样本数
        """
        self.slope_bins = slope_bins
        self.min_samples_per_group = min_samples_per_group
        self.logger = logging.getLogger(__name__)
        self.environment_groups: Dict[str, EnvironmentGroup] = {}
    
    def add_environment_info(self, df: pd.DataFrame,
                           dem_data: np.ndarray,
                           slope_data: np.ndarray,
                           aspect_data: np.ndarray,
                           landcover_data: np.ndarray) -> pd.DataFrame:
        """添加环境信息到轨迹数据
        
        Args:
            df: 预处理后的轨迹数据
            dem_data: DEM数据
            slope_data: 坡度数据
            aspect_data: 坡向数据
            landcover_data: 土地覆盖数据
            
        Returns:
            pd.DataFrame: 添加环境信息后的数据
            
        Raises:
            ValueError: 当数据缺少必要的列或数据形状不匹配时
        """
        # 检查必要的列
        required_cols = ['row', 'col']
        if 'heading_degrees' in df.columns:
            required_cols.append('heading_degrees')
        
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            raise ValueError(f"数据缺少必要的列: {missing_cols}")
            
        # 检查数据形状是否一致
        shape = dem_data.shape
        if (slope_data.shape != shape or
            aspect_data.shape != shape or
            landcover_data.shape != shape):
            raise ValueError(f"所有环境数据的形状必须一致。DEM形状: {shape}, "
                          f"坡度形状: {slope_data.shape}, "
                          f"坡向形状: {aspect_data.shape}, "
                          f"土地覆盖形状: {landcover_data.shape}")
        
        # 检查像素坐标是否在范围内
        if (df['row'].max() >= shape[0] or
            df['col'].max() >= shape[1] or
            df['row'].min() < 0 or
            df['col'].min() < 0):
            raise ValueError(f"像素坐标超出范围。数据形状: {shape}, "
                          f"行范围: [{df['row'].min()}, {df['row'].max()}], "
                          f"列范围: [{df['col'].min()}, {df['col'].max()}]")
        
        # 使用像素坐标获取环境数据
        df['elevation'] = dem_data[df['row'].values, df['col'].values]
        df['slope_magnitude'] = slope_data[df['row'].values, df['col'].values]
        df['slope_aspect'] = aspect_data[df['row'].values, df['col'].values]
        df['landcover'] = landcover_data[df['row'].values, df['col'].values]
        
        # 如果有朝向数据，计算方向性坡度
        if 'heading_degrees' in df.columns:
            # 计算行驶方向与坡向的关系
            df['delta_angle'] = df['heading_degrees'] - df['slope_aspect']
            # 处理角度环绕
            df.loc[df['delta_angle'] > 180, 'delta_angle'] -= 360
            df.loc[df['delta_angle'] < -180, 'delta_angle'] += 360
            
            # 计算方向性坡度
            df['slope_along_path'] = df['slope_magnitude'] * np.cos(np.radians(df['delta_angle']))
            df['cross_slope'] = df['slope_magnitude'] * np.abs(np.sin(np.radians(df['delta_angle'])))
        
        # 添加坡度等级
        df['slope_bin'] = pd.cut(df['slope_magnitude'],
                               bins=self.slope_bins,
                               labels=range(len(self.slope_bins)-1))
        
        # 创建环境组标签
        df['group_label'] = df.apply(
            lambda x: f"LC{x['landcover']}_S{x['slope_bin']}",
            axis=1
        )
        
        return df
    
    def analyze_groups(self, df: pd.DataFrame) -> None:
        """对每个环境组进行统计分析
        
        Args:
            df: 包含环境信息的轨迹数据
        """
        # 检查必要的列
        required_cols = ['speed_mps', 'turn_rate_dps', 'acceleration_mps2']
        if not all(col in df.columns for col in required_cols):
            raise ValueError(f"数据缺少必要的列: {required_cols}")
        
        # 按环境组分组
        groups = df.groupby('group_label')
        
        # 分析每个组
        for group_label, group_data in groups:
            # 检查样本数量
            if len(group_data) < self.min_samples_per_group:
                self.logger.warning(f"组 {group_label} 样本数量不足，跳过")
                continue
            
            # 提取landcover和slope_bin
            landcover_code = int(group_data['landcover'].iloc[0])  # 转换为Python int
            slope_bin = int(group_data['slope_bin'].iloc[0])  # 转换为Python int
            
            # 创建环境组对象
            self.environment_groups[group_label] = EnvironmentGroup(
                group_label=group_label,
                landcover_code=landcover_code,
                slope_bin=slope_bin,
                count=int(len(group_data)),  # 转换为Python int
                max_speed=float(np.percentile(group_data['speed_mps'], 95)),
                typical_speed=float(group_data['speed_mps'].median()),
                speed_stddev=float(group_data['speed_mps'].std()),
                max_turn_rate=float(np.percentile(abs(group_data['turn_rate_dps']), 95)),
                typical_turn_rate=float(group_data['turn_rate_dps'].median()),
                max_acceleration=float(np.percentile(abs(group_data['acceleration_mps2']), 95)),
                typical_acceleration=float(group_data['acceleration_mps2'].median())
            )
    
    def analyze_slope_direction_effect(self, df: pd.DataFrame) -> Dict:
        """分析坡向对速度的影响
        
        Args:
            df: 包含环境信息的轨迹数据
            
        Returns:
            Dict: 坡向影响系数
        """
        # 检查必要的列
        required_cols = ['slope_along_path', 'cross_slope', 'speed_mps']
        if not all(col in df.columns for col in required_cols):
            raise ValueError(f"数据缺少必要的列: {required_cols}")
        
        # 初始化结果字典
        effect_params = {}
        
        # 按landcover分组分析
        for landcover in df['landcover'].unique():
            lc_data = df[df['landcover'] == landcover]
            
            # 上坡影响（slope_along_path > 0）
            uphill_data = lc_data[lc_data['slope_along_path'] > 0]
            if len(uphill_data) > self.min_samples_per_group:
                # 使用线性回归分析上坡减速效应
                from sklearn.linear_model import LinearRegression
                X = uphill_data['slope_along_path'].values.reshape(-1, 1)
                y = uphill_data['speed_mps'].values
                reg = LinearRegression().fit(X, y)
                k_uphill = max(0.1, abs(reg.coef_[0]))  # 确保上坡减速系数为正
            else:
                k_uphill = 0.1  # 默认值
            
            # 横坡影响
            # 使用二次回归分析横坡减速效应
            from sklearn.preprocessing import PolynomialFeatures
            cross_slope_data = lc_data[lc_data['cross_slope'] > 0]
            if len(cross_slope_data) > self.min_samples_per_group:
                X = cross_slope_data['cross_slope'].values.reshape(-1, 1)
                poly = PolynomialFeatures(degree=2)
                X_poly = poly.fit_transform(X)
                y = cross_slope_data['speed_mps'].values
                reg = LinearRegression().fit(X_poly, y)
                k_cross = max(0.05, abs(reg.coef_[2]))  # 确保横坡减速系数为正
            else:
                k_cross = 0.05  # 默认值
            
            effect_params[str(int(landcover))] = {  # 转换landcover为字符串
                'k_uphill': float(k_uphill),  # 转换为Python float
                'k_cross': float(k_cross),  # 转换为Python float
                'max_cross_slope_degrees': 30.0  # 默认值
            }
        
        return effect_params
    
    def save_analysis_results(self, output_dir: str) -> None:
        """保存分析结果
        
        Args:
            output_dir: 输出目录路径
        """
        # 确保输出目录存在
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # 将环境组数据转换为字典
        groups_dict = {
            label: {
                'landcover_code': group.landcover_code,
                'slope_bin': group.slope_bin,
                'count': group.count,
                'max_speed': group.max_speed,
                'typical_speed': group.typical_speed,
                'speed_stddev': group.speed_stddev,
                'max_turn_rate': group.max_turn_rate,
                'typical_turn_rate': group.typical_turn_rate,
                'max_acceleration': group.max_acceleration,
                'typical_acceleration': group.typical_acceleration
            }
            for label, group in self.environment_groups.items()
        }
        
        # 保存为JSON文件
        with open(output_dir / 'environment_groups.json', 'w') as f:
            json.dump(groups_dict, f, indent=4)
        
        self.logger.info(f"分析结果已保存到: {output_dir}")
    
    def load_analysis_results(self, input_dir: str) -> None:
        """加载分析结果
        
        Args:
            input_dir: 输入目录路径
        """
        input_path = Path(input_dir) / 'environment_groups.json'
        
        if not input_path.exists():
            raise FileNotFoundError(f"找不到分析结果文件: {input_path}")
        
        # 从JSON文件加载数据
        with open(input_path, 'r') as f:
            groups_dict = json.load(f)
        
        # 转换为EnvironmentGroup对象
        self.environment_groups = {
            label: EnvironmentGroup(
                group_label=label,
                **{k: v for k, v in data.items()}
            )
            for label, data in groups_dict.items()
        }
        
        self.logger.info(f"已加载分析结果: {len(self.environment_groups)} 个环境组") 
```

### src/generator/path_planner.py
```python
"""
路径规划器模块
负责使用A*算法进行智能路径规划
"""

import heapq
import logging
import numpy as np
from typing import List, Tuple, Dict, Set, Optional
import rasterio
from pathlib import Path
from dataclasses import dataclass, field
from scipy.interpolate import splprep, splev

from ..data_processing import GISDataLoader
from src.generator.config import (
    LANDCOVER_COST_FACTORS,
    IMPASSABLE_LANDCOVER_CODES,
    MAX_SLOPE_THRESHOLD
)

# 配置日志
logger = logging.getLogger(__name__)

@dataclass(order=True)
class PathNode:
    """路径节点类，用于A*算法"""
    priority: float = field(compare=True)  # f = g + h
    position: Tuple[int, int] = field(compare=False)  # (row, col)
    g_cost: float = field(compare=False)  # 从起点到当前点的实际代价
    h_cost: float = field(compare=False)  # 从当前点到终点的估计代价
    parent: Optional['PathNode'] = field(compare=False, default=None)  # 父节点

class PathPlanner:
    """路径规划器类"""
    
    def __init__(
        self,
        cost_map_path: str,
        smoothness_weight: float = 0.3,
        heuristic_weight: float = 1.1,
        interpolation_points: int = 100
    ):
        """初始化路径规划器
        
        Args:
            cost_map_path: 成本地图文件路径
            smoothness_weight: 平滑度权重，控制路径的平滑程度
            heuristic_weight: 启发式权重，控制A*算法的搜索倾向
            interpolation_points: 插值点数量，控制平滑后路径的精度
        """
        # 检查文件是否存在
        if not Path(cost_map_path).exists():
            raise FileNotFoundError(f"找不到文件: {cost_map_path}")
        
        # 读取成本地图
        with rasterio.open(cost_map_path) as src:
            self.cost_map = src.read(1)
            self.transform = src.transform
            self.height = src.height
            self.width = src.width
        
        # 初始化参数
        self.smoothness_weight = smoothness_weight
        self.heuristic_weight = heuristic_weight
        self.interpolation_points = interpolation_points
        
        # 初始化日志
        self.logger = logging.getLogger(__name__)
        
        # 定义8个方向的偏移量（上、右上、右、右下、下、左下、左、左上）
        self.directions = [
            (-1, 0), (-1, 1), (0, 1), (1, 1),
            (1, 0), (1, -1), (0, -1), (-1, -1)
        ]
        
        # 计算对角线方向的代价系数（√2）
        self.direction_costs = [
            1.0, np.sqrt(2), 1.0, np.sqrt(2),
            1.0, np.sqrt(2), 1.0, np.sqrt(2)
        ]
    
    def is_valid_position(self, position: Tuple[int, int]) -> bool:
        """检查位置是否有效
        
        Args:
            position: 位置坐标 (row, col)
            
        Returns:
            bool: 位置是否有效
        """
        row, col = position
        return (0 <= row < self.height and 
                0 <= col < self.width and 
                self.cost_map[row, col] < float('inf'))
    
    def calculate_heuristic(
        self,
        position: Tuple[int, int],
        goal: Tuple[int, int]
    ) -> float:
        """计算启发式值（使用欧几里得距离）
        
        Args:
            position: 当前位置
            goal: 目标位置
            
        Returns:
            float: 启发式值
        """
        return np.sqrt(
            (position[0] - goal[0])**2 +
            (position[1] - goal[1])**2
        )
    
    def calculate_turn_cost(
        self,
        current: Tuple[int, int],
        next_pos: Tuple[int, int],
        parent: Optional[Tuple[int, int]] = None
    ) -> float:
        """计算转弯代价
        
        Args:
            current: 当前位置
            next_pos: 下一个位置
            parent: 父节点位置
            
        Returns:
            float: 转弯代价
        """
        if parent is None:
            return 0.0
        
        # 计算两个方向向量
        v1 = np.array([current[0] - parent[0], current[1] - parent[1]], dtype=np.float64)
        v2 = np.array([next_pos[0] - current[0], next_pos[1] - current[1]], dtype=np.float64)
        
        # 计算向量的模
        n1 = np.linalg.norm(v1)
        n2 = np.linalg.norm(v2)
        
        # 如果任一向量为零向量，说明路径重叠
        if n1 < 1e-6 or n2 < 1e-6:
            return self.smoothness_weight * np.pi
        
        # 计算夹角的余弦值
        cos_angle = np.dot(v1, v2) / (n1 * n2)
        cos_angle = np.clip(cos_angle, -1.0, 1.0)
        
        # 将余弦值转换为角度（0-180度）
        angle = np.arccos(cos_angle)
        
        # 返回转弯代价（角度越大，代价越高）
        return angle * self.smoothness_weight
    
    def find_path(
        self,
        start: Tuple[int, int],
        goal: Tuple[int, int]
    ) -> List[Tuple[int, int]]:
        """使用A*算法寻找最优路径
        
        Args:
            start: 起点坐标 (row, col)
            goal: 终点坐标 (row, col)
            
        Returns:
            List[Tuple[int, int]]: 路径点列表
        """
        # 检查起终点的有效性
        if not self.is_valid_position(start):
            raise ValueError(f"无效的起点坐标: {start}")
        if not self.is_valid_position(goal):
            raise ValueError(f"无效的终点坐标: {goal}")
        
        # 初始化开放列表和关闭列表
        open_list = []
        closed_set = set()
        
        # 创建起点节点
        start_node = PathNode(
            priority=0,
            position=start,
            g_cost=0,
            h_cost=self.calculate_heuristic(start, goal)
        )
        
        # 将起点加入开放列表
        heapq.heappush(open_list, start_node)
        
        # 开始搜索
        while open_list:
            # 获取f值最小的节点
            current = heapq.heappop(open_list)
            
            # 如果到达目标，构建并返回路径
            if current.position == goal:
                path = []
                while current:
                    path.append(current.position)
                    current = current.parent
                return list(reversed(path))
            
            # 将当前节点加入关闭列表
            closed_set.add(current.position)
            
            # 检查所有相邻节点
            for i, (dy, dx) in enumerate(self.directions):
                next_pos = (
                    current.position[0] + dy,
                    current.position[1] + dx
                )
                
                # 跳过无效或已访问的节点
                if (not self.is_valid_position(next_pos) or
                    next_pos in closed_set):
                    continue
                
                # 计算新的g值（考虑方向代价和转弯代价）
                new_g = (current.g_cost +
                        self.direction_costs[i] * self.cost_map[next_pos] +
                        self.calculate_turn_cost(
                            current.position,
                            next_pos,
                            current.parent.position if current.parent else None
                        ))
                
                # 计算h值
                h = self.calculate_heuristic(next_pos, goal)
                
                # 创建新节点
                neighbor = PathNode(
                    priority=new_g + self.heuristic_weight * h,
                    position=next_pos,
                    g_cost=new_g,
                    h_cost=h,
                    parent=current
                )
                
                # 将新节点加入开放列表
                heapq.heappush(open_list, neighbor)
        
        # 如果没有找到路径，返回空列表
        self.logger.warning(f"未能找到从{start}到{goal}的路径")
        return []
    
    def smooth_path(
        self,
        path: List[Tuple[int, int]]
    ) -> List[Tuple[int, int]]:
        """使用B样条插值平滑路径
        
        Args:
            path: 原始路径点列表
            
        Returns:
            List[Tuple[int, int]]: 平滑后的路径点列表
        """
        if len(path) < 3:
            return path
        
        # 提取路径点的坐标
        points = np.array(path)
        x = points[:, 0]
        y = points[:, 1]
        
        # 计算路径点之间的累积距离作为参数化变量
        t = np.zeros(len(path))
        for i in range(1, len(path)):
            dx = x[i] - x[i-1]
            dy = y[i] - y[i-1]
            t[i] = t[i-1] + np.sqrt(dx*dx + dy*dy)
        
        # 归一化参数化变量
        if t[-1] > 0:
            t = t / t[-1]
        
        # 为了保证起点和终点不变，在两端添加重复点
        x = np.concatenate([[x[0]], x, [x[-1]]])
        y = np.concatenate([[y[0]], y, [y[-1]]])
        t = np.concatenate([[0], t, [1]])
        
        try:
            # 使用B样条插值，设置较小的平滑因子以保持路径形状
            tck, _ = splprep([x, y], u=t, s=len(path) * 0.1, k=min(3, len(path)-1))
            
            # 生成更密集的点
            u = np.linspace(0, 1, self.interpolation_points)
            smooth_points = np.array(splev(u, tck)).T
            
            # 保证起点和终点不变
            smooth_points[0] = points[0]
            smooth_points[-1] = points[-1]
            
        except Exception as e:
            self.logger.warning(f"路径平滑失败: {e}，返回原始路径")
            return path
        
        # 将插值点转换为整数坐标，使用更精确的四舍五入
        smooth_path = []
        prev_point = None
        for p in smooth_points:
            # 对坐标进行四舍五入
            point = (int(round(p[0])), int(round(p[1])))
            
            # 避免重复点
            if point != prev_point:
                smooth_path.append(point)
                prev_point = point
        
        # 验证平滑路径的可行性
        valid_path = []
        for point in smooth_path:
            if self.is_valid_position(point):
                valid_path.append(point)
            else:
                # 如果遇到无效点，尝试找到最近的有效点
                found_valid = False
                for dy in [-1, 0, 1]:
                    for dx in [-1, 0, 1]:
                        new_point = (point[0] + dy, point[1] + dx)
                        if self.is_valid_position(new_point):
                            valid_path.append(new_point)
                            found_valid = True
                            break
                    if found_valid:
                        break
                if not found_valid:
                    self.logger.warning(f"平滑路径点{point}无效，已跳过")
        
        # 确保起点和终点正确
        if valid_path and valid_path[0] != path[0]:
            valid_path[0] = path[0]
        if valid_path and valid_path[-1] != path[-1]:
            valid_path[-1] = path[-1]
        
        # 如果平滑路径无效，返回原始路径
        if not valid_path:
            self.logger.warning("平滑路径无效，返回原始路径")
            return path
        
        return valid_path
    
    def plan(
        self,
        start: Tuple[int, int],
        goal: Tuple[int, int],
        smooth: bool = True
    ) -> List[Tuple[int, int]]:
        """规划路径的主函数
        
        Args:
            start: 起点坐标 (row, col)
            goal: 终点坐标 (row, col)
            smooth: 是否对路径进行平滑处理
            
        Returns:
            List[Tuple[int, int]]: 路径点列表
        """
        # 使用A*算法寻找路径
        path = self.find_path(start, goal)
        
        if not path:
            return []
        
        # 如果需要，对路径进行平滑处理
        if smooth and len(path) > 2:
            path = self.smooth_path(path)
        
        return path 
```

### src/generator/point_selector.py
```python
"""起点选择器模块

此模块负责为给定的终点选择合适的起点。选择过程需要考虑：
1. 起点的可通行性（基于土地覆盖类型和坡度）
2. 起终点之间的最小距离约束
3. 起点的随机性（在满足约束的情况下）

输入:
    - 土地覆盖栅格文件 (.tif)
    - 坡度栅格文件 (.tif)
    - 终点坐标（像素坐标）
    - 约束参数（最小距离等）

输出:
    - 满足约束的起点坐标列表
"""

import numpy as np
import rasterio
from pathlib import Path
import logging
from typing import List, Tuple, Dict, Optional
import random

from src.generator.config import (
    MAX_SLOPE_THRESHOLD, IMPASSABLE_LANDCOVER_CODES,
    MIN_START_END_DISTANCE_METERS, MAX_SEARCH_RADIUS,
    MAX_SEARCH_ATTEMPTS, MIN_START_POINTS_SPACING
)

class PointSelector:
    """起点选择器类"""
    
    def __init__(self, landcover_path: str, slope_path: str):
        """初始化起点选择器
        
        Args:
            landcover_path: 土地覆盖栅格文件路径
            slope_path: 坡度栅格文件路径
        """
        # 检查文件是否存在
        for path in [landcover_path, slope_path]:
            if not Path(path).exists():
                raise FileNotFoundError(f"找不到文件: {path}")
        
        # 读取栅格数据
        with rasterio.open(landcover_path) as src:
            self.landcover_data = src.read(1)
            self.transform = src.transform
            self.meta = src.meta.copy()
            self.height = src.height
            self.width = src.width
        
        with rasterio.open(slope_path) as src:
            self.slope_data = src.read(1)
            if src.transform != self.transform:
                raise ValueError("土地覆盖和坡度数据的空间参考不一致")
        
        # 验证数据形状一致
        if self.landcover_data.shape != self.slope_data.shape:
            raise ValueError("土地覆盖和坡度数据形状不一致")
        
        # 初始化日志
        self.logger = logging.getLogger(__name__)
        
        # 计算像素大小（米）
        self.pixel_size_degrees = abs(self.transform[0])  # 经纬度分辨率（度）
        self.meters_per_degree = 111000  # 1度约等于111km
        self.pixel_size_meters = self.pixel_size_degrees * self.meters_per_degree
    
    def is_point_accessible(self, row: int, col: int) -> bool:
        """判断指定点是否可通行
        
        Args:
            row: 行号
            col: 列号
            
        Returns:
            bool: 是否可通行
        """
        # 检查边界
        if not (0 <= row < self.height and 0 <= col < self.width):
            return False
        
        # 检查土地覆盖类型
        landcover = self.landcover_data[row, col]
        if landcover in IMPASSABLE_LANDCOVER_CODES:
            return False
        
        # 检查坡度
        slope = self.slope_data[row, col]
        if slope > MAX_SLOPE_THRESHOLD:
            return False
        
        return True
    
    def calculate_distance(self, point1: Tuple[int, int], point2: Tuple[int, int]) -> float:
        """计算两点间的像素距离
        
        Args:
            point1: 第一个点的坐标 (row, col)
            point2: 第二个点的坐标 (row, col)
            
        Returns:
            float: 像素距离
        """
        return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)
    
    def calculate_geo_distance(self, point1: Tuple[int, int], point2: Tuple[int, int]) -> float:
        """计算两点间的实际地理距离（米）
        
        Args:
            point1: 第一个点的坐标 (row, col)
            point2: 第二个点的坐标 (row, col)
            
        Returns:
            float: 地理距离（米）
        """
        # 转换为地理坐标
        lon1, lat1 = self.pixel_to_geo(point1)
        lon2, lat2 = self.pixel_to_geo(point2)
        
        # 使用简化的距离计算（平面近似）
        dx = (lon2 - lon1) * self.meters_per_degree * np.cos(np.radians((lat1 + lat2) / 2))
        dy = (lat2 - lat1) * self.meters_per_degree
        
        return np.sqrt(dx * dx + dy * dy)
    
    def select_start_points(
        self,
        end_point: Tuple[int, int],
        num_points: int = 1,
        min_distance: float = MIN_START_END_DISTANCE_METERS,
        max_attempts: int = MAX_SEARCH_ATTEMPTS
    ) -> List[Tuple[int, int]]:
        """为给定终点选择合适的起点
        
        Args:
            end_point: 终点坐标 (row, col)
            num_points: 需要选择的起点数量
            min_distance: 起终点最小距离（米）
            max_attempts: 最大尝试次数
            
        Returns:
            List[Tuple[int, int]]: 选择的起点坐标列表
        """
        selected_points = []
        attempts = 0
        min_pixel_distance = min_distance / self.pixel_size_meters
        min_spacing = MIN_START_POINTS_SPACING / self.pixel_size_meters
        
        # 计算搜索范围
        max_radius = MAX_SEARCH_RADIUS / self.pixel_size_meters
        search_radius = min(int(min_pixel_distance * 2), int(max_radius))
        
        # 创建候选点网格
        y, x = np.meshgrid(
            np.arange(-search_radius, search_radius + 1),
            np.arange(-search_radius, search_radius + 1)
        )
        distances = np.sqrt(x*x + y*y)
        mask = distances >= min_pixel_distance
        candidate_offsets = list(zip(y[mask].flat, x[mask].flat))
        random.shuffle(candidate_offsets)
        
        while len(selected_points) < num_points and attempts < len(candidate_offsets):
            # 获取下一个候选点
            dy, dx = candidate_offsets[attempts]
            row = int(end_point[0] + dy)
            col = int(end_point[1] + dx)
            attempts += 1
            
            # 检查点是否可用
            if self.is_point_accessible(row, col):
                # 检查与已选点的距离
                too_close = False
                for point in selected_points:
                    if self.calculate_distance((row, col), point) < min_spacing:
                        too_close = True
                        break
                
                if not too_close:
                    selected_points.append((row, col))
                    self.logger.debug(f"已选择起点: ({row}, {col})")
        
        if len(selected_points) < num_points:
            self.logger.warning(
                f"未能找到足够的起点（要求{num_points}个，找到{len(selected_points)}个）"
            )
        
        return selected_points
    
    def select_start_points_for_all_ends(
        self,
        end_points: List[Dict],
        points_per_end: int = 3
    ) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:
        """为所有终点选择起点
        
        Args:
            end_points: 终点列表，每个终点是一个字典，包含 'pixel' 和 'coord' 键
            points_per_end: 每个终点需要的起点数量
            
        Returns:
            List[Tuple[Tuple[int, int], Tuple[int, int]]]: 起终点对列表
        """
        start_end_pairs = []
        
        for end_point in end_points:
            # 为当前终点选择起点
            start_points = self.select_start_points(
                end_point['pixel'],
                num_points=points_per_end
            )
            
            # 添加起终点对
            for start_point in start_points:
                start_end_pairs.append((start_point, end_point['pixel']))
        
        self.logger.info(f"共生成{len(start_end_pairs)}对起终点")
        return start_end_pairs
    
    def pixel_to_geo(self, pixel: Tuple[int, int]) -> Tuple[float, float]:
        """将像素坐标转换为地理坐标
        
        Args:
            pixel: 像素坐标 (row, col)
            
        Returns:
            Tuple[float, float]: 地理坐标 (lon, lat)
        """
        # 注意：rasterio的transform期望(x, y)，而我们的输入是(row, col)
        x, y = pixel[1], pixel[0]  # 转换为(x, y)
        # 使用transform的逆变换
        lon = x * self.transform[0] + self.transform[2]
        lat = y * self.transform[4] + self.transform[5]
        return lon, lat
    
    def geo_to_pixel(self, coord: Tuple[float, float]) -> Tuple[int, int]:
        """将地理坐标转换为像素坐标
        
        Args:
            coord: 地理坐标 (lon, lat)
            
        Returns:
            Tuple[int, int]: 像素坐标 (row, col)
        """
        # 使用transform的正变换
        col = int((coord[0] - self.transform[2]) / self.transform[0])
        row = int((coord[1] - self.transform[5]) / self.transform[4])
        return row, col 
```

### src/generator/terrain_analyzer.py
```python
"""地形分析器模块

此模块负责从DEM数据计算地形属性,包括:
1. 坡度大小(度)
2. 坡向(度,北为0,顺时针)

输入:
    - DEM栅格文件 (.tif)

输出:
    - 坡度大小栅格文件 (slope_magnitude_30m_100km.tif)
    - 坡向栅格文件 (slope_aspect_30m_100km.tif)
"""

import numpy as np
import rasterio
from pathlib import Path
import logging
from typing import Tuple
import os

class TerrainAnalyzer:
    """地形分析器类"""
    
    def __init__(self, dem_path: str):
        """初始化地形分析器
        
        Args:
            dem_path: DEM栅格文件路径
        """
        # 检查文件是否存在
        if not Path(dem_path).exists():
            raise FileNotFoundError(f"找不到DEM文件: {dem_path}")
        
        # 读取DEM数据
        with rasterio.open(dem_path) as src:
            self.dem_data = src.read(1)
            self.transform = src.transform
            self.meta = src.meta.copy()
            # 计算实际的像素大小(米)
            self.pixel_width = abs(self.transform[0]) * 111320  # 转换为米
            self.pixel_height = abs(self.transform[4]) * 111320  # 转换为米
        
        # 初始化日志
        self.logger = logging.getLogger(__name__)
    
    def calculate_slope_magnitude(self) -> np.ndarray:
        """计算坡度大小
        
        使用中心差分法计算每个像素的坡度大小(度)。
        边缘像素使用前向或后向差分。
        
        Returns:
            np.ndarray: 坡度大小(度)
        """
        rows, cols = self.dem_data.shape
        
        # 计算x和y方向的高程梯度
        dx = np.zeros_like(self.dem_data)
        dy = np.zeros_like(self.dem_data)
        
        # x方向梯度(中心差分)
        dx[:, 1:-1] = (self.dem_data[:, 2:] - self.dem_data[:, :-2]) / (2 * self.pixel_width)
        # 边缘使用前向/后向差分
        dx[:, 0] = (self.dem_data[:, 1] - self.dem_data[:, 0]) / self.pixel_width
        dx[:, -1] = (self.dem_data[:, -1] - self.dem_data[:, -2]) / self.pixel_width
        
        # y方向梯度(中心差分)
        dy[1:-1, :] = (self.dem_data[2:, :] - self.dem_data[:-2, :]) / (2 * self.pixel_height)
        # 边缘使用前向/后向差分
        dy[0, :] = (self.dem_data[1, :] - self.dem_data[0, :]) / self.pixel_height
        dy[-1, :] = (self.dem_data[-1, :] - self.dem_data[-2, :]) / self.pixel_height
        
        # 计算坡度(度)
        slope = np.degrees(np.arctan(np.sqrt(dx**2 + dy**2)))
        
        # 处理无效值
        slope = np.nan_to_num(slope, 0)  # 将NaN替换为0
        slope = np.clip(slope, 0, 90)  # 限制在0-90度范围内
        
        return slope
    
    def calculate_slope_aspect(self) -> np.ndarray:
        """计算坡向
        
        使用中心差分法计算每个像素的坡向(度,北为0,顺时针)。
        边缘像素使用前向或后向差分。
        平坦区域(坡度<0.1度)的坡向设为-1。
        
        Returns:
            np.ndarray: 坡向(度)
        """
        rows, cols = self.dem_data.shape
        
        # 计算x和y方向的高程梯度
        dx = np.zeros_like(self.dem_data)
        dy = np.zeros_like(self.dem_data)
        
        # x方向梯度(中心差分)
        dx[:, 1:-1] = (self.dem_data[:, 2:] - self.dem_data[:, :-2]) / (2 * self.pixel_width)
        # 边缘使用前向/后向差分
        dx[:, 0] = (self.dem_data[:, 1] - self.dem_data[:, 0]) / self.pixel_width
        dx[:, -1] = (self.dem_data[:, -1] - self.dem_data[:, -2]) / self.pixel_width
        
        # y方向梯度(中心差分)
        dy[1:-1, :] = (self.dem_data[2:, :] - self.dem_data[:-2, :]) / (2 * self.pixel_height)
        # 边缘使用前向/后向差分
        dy[0, :] = (self.dem_data[1, :] - self.dem_data[0, :]) / self.pixel_height
        dy[-1, :] = (self.dem_data[-1, :] - self.dem_data[-2, :]) / self.pixel_height
        
        # 计算坡向(弧度)
        aspect = np.arctan2(dx, dy)  # 使用arctan2确保正确的象限
        
        # 转换为度数并调整为北为0,顺时针
        aspect = np.degrees(aspect)
        aspect = 90.0 - aspect  # 转换为北为0
        aspect = np.where(aspect < 0, aspect + 360, aspect)  # 处理负值
        
        # 计算坡度用于识别平坦区域
        slope = np.degrees(np.arctan(np.sqrt(dx**2 + dy**2)))
        
        # 平坦区域坡向设为-1
        aspect = np.where(slope < 0.1, -1, aspect)
        
        return aspect
    
    def save_terrain_maps(self, output_dir: str) -> Tuple[str, str]:
        """保存地形属性地图
        
        Args:
            output_dir: 输出目录路径
            
        Returns:
            Tuple[str, str]: 坡度和坡向文件的路径
        """
        # 确保输出目录存在
        os.makedirs(output_dir, exist_ok=True)
        
        # 计算坡度和坡向
        slope = self.calculate_slope_magnitude()
        aspect = self.calculate_slope_aspect()
        
        # 准备元数据
        meta = self.meta.copy()
        meta.update(dtype=np.float32)
        
        # 保存坡度地图
        slope_path = os.path.join(output_dir, "slope_magnitude_30m_100km.tif")
        with rasterio.open(slope_path, 'w', **meta) as dst:
            dst.write(slope.astype(np.float32), 1)
        
        # 保存坡向地图
        aspect_path = os.path.join(output_dir, "slope_aspect_30m_100km.tif")
        with rasterio.open(aspect_path, 'w', **meta) as dst:
            dst.write(aspect.astype(np.float32), 1)
        
        self.logger.info(f"地形属性地图已保存到目录: {output_dir}")
        return slope_path, aspect_path 
```

### src/generator/trajectory_generator.py
```python
"""
轨迹生成器模块
负责生成符合环境约束的合成轨迹
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import pandas as pd
from scipy import stats

from ..analysis import EnvironmentAnalyzer
from ..config import TRAJECTORY_COLUMNS
from ..data_processing import GISDataLoader

# 配置日志
logger = logging.getLogger(__name__)

class TrajectoryGenerator:
    """轨迹生成器，用于生成符合环境约束的合成轨迹"""
    
    def __init__(self, 
                 gis_loader: GISDataLoader,
                 env_analyzer: EnvironmentAnalyzer,
                 time_step: float = 1.0):
        """
        初始化轨迹生成器
        
        Args:
            gis_loader: GIS数据加载器实例
            env_analyzer: 环境分析器实例，包含已训练的环境-运动特征模型
            time_step: 轨迹采样时间步长（秒），默认为1秒
        """
        self.gis_loader = gis_loader
        self.env_analyzer = env_analyzer
        self.time_step = time_step
    
    def generate_trajectory(self,
                          start_point: Tuple[float, float],
                          end_point: Tuple[float, float],
                          start_time: pd.Timestamp) -> pd.DataFrame:
        """
        生成一条从起点到终点的合成轨迹
        
        Args:
            start_point: 起点坐标 (longitude, latitude)
            end_point: 终点坐标 (longitude, latitude)
            start_time: 轨迹起始时间
            
        Returns:
            trajectory_df: 生成的轨迹数据，包含时间戳、位置、速度等信息
        """
        # 规划路径
        waypoints = self._plan_path(start_point, end_point)
        
        # 生成运动轨迹
        trajectory_df = self._generate_motion(waypoints, start_time)
        
        return trajectory_df
    
    def generate_trajectories(self,
                            num_trajectories: int,
                            region_bounds: Tuple[float, float, float, float],
                            time_range: Tuple[pd.Timestamp, pd.Timestamp]) -> Dict[str, pd.DataFrame]:
        """
        在指定区域和时间范围内生成多条轨迹
        
        Args:
            num_trajectories: 要生成的轨迹数量
            region_bounds: 区域边界 (min_lon, min_lat, max_lon, max_lat)
            time_range: 时间范围 (start_time, end_time)
            
        Returns:
            trajectories: 生成的轨迹字典，key为轨迹ID
        """
        min_lon, min_lat, max_lon, max_lat = region_bounds
        start_time, end_time = time_range
        time_range_seconds = (end_time - start_time).total_seconds()
        
        trajectories = {}
        for i in range(num_trajectories):
            # 随机生成起点和终点
            start_point = (
                np.random.uniform(min_lon, max_lon),
                np.random.uniform(min_lat, max_lat)
            )
            end_point = (
                np.random.uniform(min_lon, max_lon),
                np.random.uniform(min_lat, max_lat)
            )
            
            # 随机生成起始时间
            start_offset = np.random.uniform(0, time_range_seconds)
            traj_start_time = start_time + pd.Timedelta(seconds=start_offset)
            
            try:
                # 生成轨迹
                trajectory = self.generate_trajectory(
                    start_point=start_point,
                    end_point=end_point,
                    start_time=traj_start_time
                )
                
                # 生成轨迹ID并保存
                traj_id = f"TRAJ_{i+1:04d}"
                trajectories[traj_id] = trajectory
                
                logger.info(f"成功生成轨迹 {traj_id}")
                
            except Exception as e:
                logger.error(f"生成第 {i+1} 条轨迹时出错: {str(e)}")
                continue
        
        return trajectories
    
    def _plan_path(self,
                   start_point: Tuple[float, float],
                   end_point: Tuple[float, float]) -> List[Tuple[float, float]]:
        """
        规划从起点到终点的路径
        
        Args:
            start_point: 起点坐标 (longitude, latitude)
            end_point: 终点坐标 (longitude, latitude)
            
        Returns:
            waypoints: 路径上的关键点列表
        """
        # 计算起点和终点之间的距离
        lon_diff = end_point[0] - start_point[0]
        lat_diff = end_point[1] - start_point[1]
        total_distance = np.sqrt(lon_diff**2 + lat_diff**2)
        
        # 根据总距离确定路径点数量（每0.005度约0.5km）
        num_points = max(2, int(total_distance / 0.005) + 1)
        
        # 生成路径点
        waypoints = []
        for i in range(num_points):
            t = i / (num_points - 1)  # 插值参数，从0到1
            lon = start_point[0] + t * lon_diff
            lat = start_point[1] + t * lat_diff
            
            # 对于最后一个点，使用精确的终点坐标
            if i == num_points - 1:
                lon, lat = end_point
            
            waypoints.append((lon, lat))
        
        return waypoints
    
    def _generate_motion(self,
                        waypoints: List[Tuple[float, float]],
                        start_time: pd.Timestamp) -> pd.DataFrame:
        """
        根据路径点生成符合环境约束的运动轨迹
        
        Args:
            waypoints: 路径关键点列表
            start_time: 起始时间
            
        Returns:
            motion_df: 生成的运动轨迹数据
        """
        # 初始化轨迹数据列表
        timestamps = []
        longitudes = []
        latitudes = []
        elevations = []
        speeds = []
        headings = []
        turn_rates = []
        accelerations = []
        
        current_time = start_time
        current_speed = 0.0
        current_heading = 0.0
        
        # 遍历相邻路径点对
        for i in range(len(waypoints) - 1):
            p1, p2 = waypoints[i], waypoints[i + 1]
            
            # 计算两点之间的距离和方向
            lon_diff = p2[0] - p1[0]
            lat_diff = p2[1] - p1[1]
            segment_distance = np.sqrt(lon_diff**2 + lat_diff**2)
            target_heading = np.degrees(np.arctan2(lat_diff, lon_diff)) % 360
            
            # 获取当前位置的环境信息
            pixel_coords = self.gis_loader.get_pixel_coords(p1[0], p1[1])
            elevation = self.gis_loader.get_elevation(*pixel_coords)
            slope = self.gis_loader.get_slope(*pixel_coords)
            landcover = self.gis_loader.get_landcover(*pixel_coords)
            
            # 根据环境条件采样目标速度
            target_speed = self.env_analyzer.sample_speed(landcover, slope)
            
            # 计算航向角变化
            heading_diff = (target_heading - current_heading + 180) % 360 - 180
            num_steps = max(1, int(segment_distance / (target_speed * self.time_step)))
            heading_step = heading_diff / num_steps
            
            # 生成该段轨迹的运动数据
            for step in range(num_steps):
                t = step / num_steps  # 插值参数
                
                # 更新位置
                if step == num_steps - 1 and i == len(waypoints) - 2:
                    # 最后一个点使用精确的终点坐标
                    lon, lat = p2
                else:
                    lon = p1[0] + t * lon_diff
                    lat = p1[1] + t * lat_diff
                
                # 更新航向
                prev_heading = current_heading
                current_heading = (current_heading + heading_step) % 360
                turn_rate = (current_heading - prev_heading) / self.time_step
                
                # 更新速度
                prev_speed = current_speed
                current_speed = prev_speed + (target_speed - prev_speed) * 0.1  # 平滑加速
                acceleration = (current_speed - prev_speed) / self.time_step
                
                # 记录数据点
                timestamps.append(current_time)
                longitudes.append(lon)
                latitudes.append(lat)
                elevations.append(elevation)
                speeds.append(current_speed)
                headings.append(current_heading)
                turn_rates.append(turn_rate)
                accelerations.append(acceleration)
                
                current_time += pd.Timedelta(seconds=self.time_step)
        
        # 创建DataFrame
        motion_df = pd.DataFrame({
            'timestamp': timestamps,
            'longitude': longitudes,
            'latitude': latitudes,
            'elevation': elevations,
            'speed': speeds,
            'heading': headings,
            'turn_rate': turn_rates,
            'acceleration': accelerations
        })
        
        return motion_df 
```

### src/trajectory_generation/environment_based_generator.py
```python
"""
基于环境的轨迹生成器
根据地形特征和环境约束生成合理的轨迹
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import pandas as pd
from scipy.interpolate import CubicSpline

from .trajectory_generator import TrajectoryGenerator
from ..data_processing import TerrainLoader

logger = logging.getLogger(__name__)

class EnvironmentBasedGenerator(TrajectoryGenerator):
    """基于环境的轨迹生成器"""
    
    def __init__(self, terrain_loader: TerrainLoader):
        """
        初始化基于环境的轨迹生成器
        
        Args:
            terrain_loader: 地形数据加载器实例
        """
        super().__init__(terrain_loader)
        
        # 环境相关参数
        self.env_params = {
            # 坡度对速度的影响因子
            'slope_speed_factors': {
                'flat': 1.0,      # 平地 (0-5度)
                'gentle': 0.9,    # 缓坡 (5-15度)
                'moderate': 0.7,  # 中坡 (15-30度)
                'steep': 0.5      # 陡坡 (>30度)
            },
            # 坡向影响参数
            'slope_direction_params': {
                'k_uphill': 0.1,    # 上坡减速系数
                'k_downhill': 0.05,  # 下坡加速系数
                'k_cross': 0.2,      # 横坡减速系数
                'max_cross_slope': 30.0,  # 最大允许横坡角度(度)
                'min_speed_factor': 0.1   # 最小速度因子
            },
            # 地表类型对速度的影响因子
            'landcover_speed_factors': {
                1: 1.0,  # 道路
                2: 0.8,  # 植被
                3: 0.6   # 水体
            },
            'path_smoothness': 0.8,  # 路径平滑度 (0-1)
            'waypoint_spacing': 100   # 路径点间距（米）
        }
    
    def generate_trajectory(
            self,
            start_point: Tuple[float, float],
            end_point: Tuple[float, float],
            params: Optional[Dict] = None
        ) -> pd.DataFrame:
        """
        生成轨迹
        
        Args:
            start_point: 起点坐标（经度, 纬度）
            end_point: 终点坐标（经度, 纬度）
            params: 生成参数，可选
            
        Returns:
            pd.DataFrame: 生成的轨迹数据
        """
        # 更新参数
        if params:
            self.update_params(params)
        
        # 检查地形数据
        self._check_terrain_data()
        
        # 验证起终点
        if not (self._validate_point(*start_point) and self._validate_point(*end_point)):
            raise ValueError("起点或终点超出有效范围")
        
        # 生成路径点
        waypoints = self._generate_waypoints(start_point, end_point)
        
        # 生成轨迹点
        trajectory = self._generate_trajectory_points(waypoints)
        
        # 验证轨迹
        if not self.validate_trajectory(trajectory):
            logger.warning("生成的轨迹不满足约束条件，尝试重新生成")
            return self.generate_trajectory(start_point, end_point, params)
        
        return trajectory
    
    def validate_trajectory(self, trajectory: pd.DataFrame) -> bool:
        """
        验证轨迹是否满足约束条件
        
        Args:
            trajectory: 轨迹数据
            
        Returns:
            bool: 是否有效
        """
        # 检查速度约束
        speed = np.sqrt(
            trajectory['velocity_north_ms']**2 + 
            trajectory['velocity_east_ms']**2
        )
        if not (self.params['min_speed'] <= speed).all() or \
           not (speed <= self.params['max_speed']).all():
            return False
        
        # 检查加速度约束
        acceleration = np.sqrt(
            trajectory['acceleration_x_ms2']**2 + 
            trajectory['acceleration_y_ms2']**2 + 
            trajectory['acceleration_z_ms2']**2
        )
        if not (acceleration <= self.params['max_acceleration']).all():
            return False
        
        # 检查转向率约束
        turn_rate = np.sqrt(
            trajectory['angular_velocity_x_rads']**2 + 
            trajectory['angular_velocity_y_rads']**2 + 
            trajectory['angular_velocity_z_rads']**2
        )
        if not (turn_rate <= np.radians(self.params['max_turn_rate'])).all():
            return False
        
        return True
    
    def _generate_waypoints(
            self,
            start_point: Tuple[float, float],
            end_point: Tuple[float, float]
        ) -> List[Tuple[float, float]]:
        """
        生成路径点
        
        Args:
            start_point: 起点坐标
            end_point: 终点坐标
            
        Returns:
            List[Tuple[float, float]]: 路径点列表
        """
        # 计算直线距离
        distance = self._calculate_distance(start_point, end_point)
        
        # 计算需要的路径点数量
        num_points = max(3, int(distance / self.env_params['waypoint_spacing']))
        
        # 生成初始路径点（直线插值）
        t = np.linspace(0, 1, num_points)
        lon = np.interp(t, [0, 1], [start_point[0], end_point[0]])
        lat = np.interp(t, [0, 1], [start_point[1], end_point[1]])
        
        # 根据地形调整路径点
        waypoints = []
        for i in range(num_points):
            point = self._adjust_point_by_terrain(lon[i], lat[i])
            waypoints.append(point)
        
        return waypoints
    
    def _calculate_speed_factors(
            self,
            slope_magnitude: float,
            slope_aspect: float,
            heading: float,
            landcover: int
        ) -> Tuple[float, float]:
        """
        计算速度影响因子
        
        Args:
            slope_magnitude: 坡度大小(度)
            slope_aspect: 坡向(度,北为0,顺时针)
            heading: 行进方向(度,北为0,顺时针)
            landcover: 地表类型编码
            
        Returns:
            Tuple[float, float]: (最大速度因子, 典型速度因子)
        """
        # 计算坡向影响
        delta_angle = heading - slope_aspect
        # 处理角度环绕
        if delta_angle > 180:
            delta_angle -= 360
        elif delta_angle < -180:
            delta_angle += 360
            
        # 计算沿路径坡度和横向坡度
        slope_along_path = slope_magnitude * np.cos(np.radians(delta_angle))
        cross_slope = slope_magnitude * abs(np.sin(np.radians(delta_angle)))
        
        # 获取坡向参数
        params = self.env_params['slope_direction_params']
        
        # 计算上下坡影响
        if slope_along_path > 0:  # 上坡
            along_factor = max(
                params['min_speed_factor'],
                1 - params['k_uphill'] * slope_along_path
            )
        else:  # 下坡
            along_factor = min(
                1.2,  # 限制下坡最大加速
                1 + params['k_downhill'] * abs(slope_along_path)
            )
        
        # 计算横坡影响
        cross_factor = max(
            params['min_speed_factor'],
            1 - params['k_cross'] * (cross_slope / params['max_cross_slope'])**2
        )
        
        # 如果横坡超过最大允许值,显著降低速度
        if cross_slope > params['max_cross_slope']:
            cross_factor = params['min_speed_factor']
        
        # 获取基础坡度影响因子
        if slope_magnitude <= 5:
            base_factor = self.env_params['slope_speed_factors']['flat']
        elif slope_magnitude <= 15:
            base_factor = self.env_params['slope_speed_factors']['gentle']
        elif slope_magnitude <= 30:
            base_factor = self.env_params['slope_speed_factors']['moderate']
        else:
            base_factor = self.env_params['slope_speed_factors']['steep']
        
        # 获取地表影响因子
        landcover_factor = self.env_params['landcover_speed_factors'].get(
            landcover,
            0.5  # 默认因子
        )
        
        # 综合各种影响
        max_speed_factor = base_factor * along_factor * cross_factor * landcover_factor
        typical_speed_factor = max_speed_factor * 0.8  # 典型速度略低于最大速度
        
        return max_speed_factor, typical_speed_factor
    
    def _generate_trajectory_points(
            self,
            waypoints: List[Tuple[float, float]]
        ) -> pd.DataFrame:
        """
        根据路径点生成轨迹点
        
        Args:
            waypoints: 路径点列表
            
        Returns:
            pd.DataFrame: 轨迹数据
        """
        # 使用三次样条插值生成平滑路径
        t = np.arange(len(waypoints))
        lon = [p[0] for p in waypoints]
        lat = [p[1] for p in waypoints]
        cs_lon = CubicSpline(t, lon)
        cs_lat = CubicSpline(t, lat)
        
        # 生成时间序列
        total_distance = sum(
            self._calculate_distance(waypoints[i], waypoints[i+1])
            for i in range(len(waypoints)-1)
        )
        total_time = total_distance / (self.params['max_speed'] * 0.5)  # 估计总时间
        num_points = int(total_time / self.params['time_step']) + 1
        t_fine = np.linspace(0, len(waypoints)-1, num_points)
        
        # 生成位置序列
        longitude = cs_lon(t_fine)
        latitude = cs_lat(t_fine)
        
        # 初始化数组
        timestamp_ms = np.zeros(num_points, dtype=np.int64)
        altitude = np.zeros(num_points)
        velocity_north = np.zeros(num_points)
        velocity_east = np.zeros(num_points)
        velocity_down = np.zeros(num_points)
        acceleration_x = np.zeros(num_points)
        acceleration_y = np.zeros(num_points)
        acceleration_z = np.zeros(num_points)
        angular_velocity_z = np.zeros(num_points)
        
        # 计算初始航向
        heading = np.degrees(np.arctan2(
            longitude[1] - longitude[0],
            latitude[1] - latitude[0]
        ))
        if heading < 0:
            heading += 360
            
        # 初始速度设为最小速度
        speed = self.params['min_speed']
        
        # 逐点生成轨迹
        for i in range(num_points):
            # 更新时间戳
            timestamp_ms[i] = int(i * self.params['time_step'] * 1000)
            
            # 获取当前位置的环境信息
            terrain_attrs = self.terrain_analyzer.get_terrain_attributes(
                longitude[i],
                latitude[i]
            )
            landcover = self.terrain_loader.get_landcover(
                longitude[i],
                latitude[i]
            )
            
            # 计算速度影响因子
            max_factor, typ_factor = self._calculate_speed_factors(
                terrain_attrs['slope_magnitude'],
                terrain_attrs['slope_aspect'],
                heading,
                landcover
            )
            
            # 计算目标速度
            target_speed = self.params['max_speed'] * typ_factor
            
            # 应用加速度限制
            speed_diff = target_speed - speed
            if speed_diff > 0:
                accel = min(speed_diff / self.params['time_step'],
                          self.params['max_acceleration'])
            else:
                accel = max(speed_diff / self.params['time_step'],
                          self.params['max_deceleration'])
            
            # 更新速度
            speed = speed + accel * self.params['time_step']
            speed = np.clip(speed,
                          self.params['min_speed'],
                          self.params['max_speed'] * max_factor)
            
            # 分解速度到南北和东西方向
            velocity_north[i] = speed * np.cos(np.radians(heading))
            velocity_east[i] = speed * np.sin(np.radians(heading))
            
            # 计算高程变化引起的垂直速度
            if i > 0:
                altitude[i] = self.terrain_loader.get_elevation(
                    longitude[i],
                    latitude[i]
                )
                dz = altitude[i] - altitude[i-1]
                dt = self.params['time_step']
                velocity_down[i] = -dz / dt  # 注意符号：向上为负
            
            # 计算加速度
            if i > 0:
                acceleration_x[i] = (velocity_east[i] - velocity_east[i-1]) / dt
                acceleration_y[i] = (velocity_north[i] - velocity_north[i-1]) / dt
                acceleration_z[i] = (velocity_down[i] - velocity_down[i-1]) / dt
            
            # 如果不是最后一个点，更新航向
            if i < num_points - 1:
                next_heading = np.degrees(np.arctan2(
                    longitude[i+1] - longitude[i],
                    latitude[i+1] - latitude[i]
                ))
                if next_heading < 0:
                    next_heading += 360
                
                # 计算航向变化
                heading_change = next_heading - heading
                if heading_change > 180:
                    heading_change -= 360
                elif heading_change < -180:
                    heading_change += 360
                
                # 应用转向率限制
                max_change = self.params['max_turn_rate'] * self.params['time_step']
                heading_change = np.clip(heading_change, -max_change, max_change)
                
                # 更新航向
                heading = heading + heading_change
                if heading < 0:
                    heading += 360
                elif heading >= 360:
                    heading -= 360
                
                # 计算角速度
                angular_velocity_z[i] = np.radians(heading_change / self.params['time_step'])
        
        # 创建轨迹数据
        data = {
            'timestamp_ms': timestamp_ms,
            'longitude': longitude,
            'latitude': latitude,
            'altitude_m': altitude,
            'velocity_north_ms': velocity_north,
            'velocity_east_ms': velocity_east,
            'velocity_down_ms': velocity_down,
            'acceleration_x_ms2': acceleration_x,
            'acceleration_y_ms2': acceleration_y,
            'acceleration_z_ms2': acceleration_z,
            'angular_velocity_x_rads': np.zeros_like(longitude),
            'angular_velocity_y_rads': np.zeros_like(longitude),
            'angular_velocity_z_rads': angular_velocity_z
        }
        
        return pd.DataFrame(data)
    
    def _adjust_point_by_terrain(
            self,
            lon: float,
            lat: float
        ) -> Tuple[float, float]:
        """
        根据地形特征调整路径点
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            Tuple[float, float]: 调整后的坐标
        """
        # 获取地形特征
        terrain_attrs = self.terrain_analyzer.get_terrain_attributes(lon, lat)
        slope = terrain_attrs['slope_magnitude']
        
        # 获取地表类型
        landcover = self.terrain_loader.get_landcover(lon, lat)
        
        # 根据坡度和地表类型调整点位置（简单示例）
        if slope > 30:  # 陡坡
            # 尝试在周围找到更平缓的位置
            for offset in [(0.001, 0), (-0.001, 0), (0, 0.001), (0, -0.001)]:
                new_lon = lon + offset[0]
                new_lat = lat + offset[1]
                if self._validate_point(new_lon, new_lat):
                    new_slope = self.terrain_analyzer.get_terrain_attributes(
                        new_lon, new_lat
                    )['slope_magnitude']
                    if new_slope < slope:
                        return new_lon, new_lat
        
        return lon, lat
    
    def _calculate_distance(
            self,
            point1: Tuple[float, float],
            point2: Tuple[float, float]
        ) -> float:
        """
        计算两点间的距离（米）
        
        Args:
            point1: 第一个点的坐标（经度, 纬度）
            point2: 第二个点的坐标（经度, 纬度）
            
        Returns:
            float: 距离（米）
        """
        # 使用简化的距离计算（平面近似）
        lon1, lat1 = point1
        lon2, lat2 = point2
        
        dx = (lon2 - lon1) * 111000 * np.cos(np.radians((lat1 + lat2) / 2))
        dy = (lat2 - lat1) * 111000
        
        return np.sqrt(dx**2 + dy**2) 
```

### src/trajectory_generation/path_planner.py
```python
"""
路径规划器
使用A*算法在环境地图上规划最优路径
"""

import logging
from typing import Dict, List, Optional, Set, Tuple
import heapq
import numpy as np

from ..data_processing import TerrainLoader, EnvironmentMapper

logger = logging.getLogger(__name__)

class PathPlanner:
    """路径规划器"""
    
    def __init__(
            self,
            terrain_loader: TerrainLoader,
            environment_mapper: EnvironmentMapper,
            config: Dict
        ):
        """
        初始化路径规划器
        
        Args:
            terrain_loader: 地形数据加载器实例
            environment_mapper: 环境地图生成器实例
            config: 配置参数字典
        """
        self.terrain_loader = terrain_loader
        self.environment_mapper = environment_mapper
        self.config = config
        
        # 获取成本图和其他环境地图
        self.maps = environment_mapper.get_maps()
        self.cost_map = self.maps['cost_map']
        
        # 定义移动方向（8个方向）
        self.directions = [
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1),           (0, 1),
            (1, -1),  (1, 0),  (1, 1)
        ]
        
        # 对角线移动的距离系数
        self.move_costs = [
            np.sqrt(2), 1, np.sqrt(2),
            1,              1,
            np.sqrt(2), 1, np.sqrt(2)
        ]
    
    def plan_path(
            self,
            start: Tuple[int, int],
            end: Tuple[int, int]
        ) -> Optional[List[Tuple[int, int]]]:
        """
        使用A*算法规划路径
        
        Args:
            start: 起点坐标 (row, col)
            end: 终点坐标 (row, col)
            
        Returns:
            Optional[List[Tuple[int, int]]]: 路径点列表，如果找不到路径则返回None
        """
        logger.info(f"开始规划路径: 从{start}到{end}")
        
        # 验证起终点
        if not self._is_valid_point(start) or not self._is_valid_point(end):
            logger.error("起点或终点无效")
            return None
        
        # A*算法的数据结构
        open_set = []  # 优先队列
        closed_set = set()  # 已访问的节点
        came_from = {}  # 路径追踪
        g_score = {start: 0}  # 从起点到当前点的实际代价
        f_score = {start: self._heuristic(start, end)}  # 估计的总代价
        
        # 将起点加入开放列表
        heapq.heappush(open_set, (f_score[start], start))
        
        while open_set:
            # 获取f值最小的节点
            current = heapq.heappop(open_set)[1]
            
            # 到达终点
            if current == end:
                logger.info("找到路径")
                return self._reconstruct_path(came_from, end)
            
            # 将当前节点加入关闭列表
            closed_set.add(current)
            
            # 检查相邻节点
            for i, (dr, dc) in enumerate(self.directions):
                neighbor = (current[0] + dr, current[1] + dc)
                
                # 检查节点是否有效
                if not self._is_valid_point(neighbor):
                    continue
                
                # 如果节点已在关闭列表中，跳过
                if neighbor in closed_set:
                    continue
                
                # 计算经过当前节点到邻居节点的代价
                move_cost = self.move_costs[i]
                tentative_g_score = (
                    g_score[current] +
                    move_cost * self.cost_map[neighbor]
                )
                
                # 如果找到更好的路径或是新节点
                if (neighbor not in g_score or
                    tentative_g_score < g_score[neighbor]):
                    # 更新路径
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = (
                        g_score[neighbor] +
                        self._heuristic(neighbor, end)
                    )
                    
                    # 将邻居节点加入开放列表
                    heapq.heappush(
                        open_set,
                        (f_score[neighbor], neighbor)
                    )
        
        logger.warning("未找到有效路径")
        return None
    
    def _is_valid_point(self, point: Tuple[int, int]) -> bool:
        """
        检查点是否有效
        
        Args:
            point: 坐标点 (row, col)
            
        Returns:
            bool: 是否有效
        """
        row, col = point
        shape = self.cost_map.shape
        
        # 检查边界
        if not (0 <= row < shape[0] and 0 <= col < shape[1]):
            return False
        
        # 检查是否可通行
        if np.isinf(self.cost_map[row, col]):
            return False
        
        return True
    
    def _heuristic(
            self,
            point: Tuple[int, int],
            goal: Tuple[int, int]
        ) -> float:
        """
        计算启发式值（使用欧几里得距离）
        
        Args:
            point: 当前点
            goal: 目标点
            
        Returns:
            float: 启发式值
        """
        return np.sqrt(
            (point[0] - goal[0])**2 +
            (point[1] - goal[1])**2
        )
    
    def _reconstruct_path(
            self,
            came_from: Dict[Tuple[int, int], Tuple[int, int]],
            end: Tuple[int, int]
        ) -> List[Tuple[int, int]]:
        """
        重建路径
        
        Args:
            came_from: 路径追踪字典
            end: 终点
            
        Returns:
            List[Tuple[int, int]]: 路径点列表
        """
        path = [end]
        current = end
        
        while current in came_from:
            current = came_from[current]
            path.append(current)
        
        path.reverse()
        return path
    
    def smooth_path(
            self,
            path: List[Tuple[int, int]],
            smoothing_factor: float = 0.5
        ) -> List[Tuple[int, int]]:
        """
        使用路径平滑算法优化路径
        
        Args:
            path: 原始路径
            smoothing_factor: 平滑因子 (0-1)
            
        Returns:
            List[Tuple[int, int]]: 平滑后的路径
        """
        if len(path) <= 2:
            return path
        
        smoothed = np.array(path, dtype=float)
        change = True
        while change:
            change = False
            for i in range(1, len(path) - 1):
                old_point = smoothed[i].copy()
                
                # 向前后点移动
                smoothed[i] = (smoothed[i] +
                    smoothing_factor * (
                        smoothed[i-1] +
                        smoothed[i+1] -
                        2 * smoothed[i]
                    )
                )
                
                # 检查新位置是否有效
                new_point = tuple(map(int, smoothed[i]))
                if not self._is_valid_point(new_point):
                    smoothed[i] = old_point
                    continue
                
                # 如果点有显著移动，继续迭代
                if not np.allclose(old_point, smoothed[i]):
                    change = True
        
        return [tuple(map(int, p)) for p in smoothed] 
```

### src/trajectory_generation/point_selector.py
```python
"""
起终点选择器
用于批量选择满足约束条件的起终点对
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import numpy as np
from scipy.spatial.distance import cdist

from ..data_processing import TerrainLoader

logger = logging.getLogger(__name__)

class PointSelector:
    """起终点选择器"""
    
    def __init__(
            self,
            terrain_loader: TerrainLoader,
            config: Dict
        ):
        """
        初始化起终点选择器
        
        Args:
            terrain_loader: 地形数据加载器实例
            config: 配置参数字典，包含：
                - NUM_TRAJECTORIES_TO_GENERATE: 要生成的轨迹总数
                - NUM_END_POINTS: 要选择的固定终点数量
                - MIN_START_END_DISTANCE_METERS: 起终点最小直线距离(米)
                - URBAN_LANDCOVER_CODES: 代表城市/建成区的地物编码列表
                - IMPASSABLE_LANDCOVER_CODES: 代表不可通行的地物编码列表
        """
        self.terrain_loader = terrain_loader
        self.config = config
        
        # 验证配置参数
        self._validate_config()
        
        # 初始化结果列表
        self.selected_end_points = []  # [(row, col), ...]
        self.generation_pairs = []     # [(start_point, end_point), ...]
    
    def _validate_config(self) -> None:
        """验证配置参数"""
        required_params = [
            'NUM_TRAJECTORIES_TO_GENERATE',
            'NUM_END_POINTS',
            'MIN_START_END_DISTANCE_METERS',
            'URBAN_LANDCOVER_CODES',
            'IMPASSABLE_LANDCOVER_CODES'
        ]
        
        for param in required_params:
            if param not in self.config:
                raise ValueError(f"缺少必要的配置参数: {param}")
    
    def select_points(self) -> List[Tuple[Tuple[float, float], Tuple[float, float]]]:
        """
        选择满足约束条件的起终点对
        
        Returns:
            List[Tuple[Tuple[float, float], Tuple[float, float]]]:
            起终点对列表，每个元素为((start_lon, start_lat), (end_lon, end_lat))
        """
        logger.info("开始选择起终点对...")
        
        # 选择终点
        self._select_end_points()
        if not self.selected_end_points:
            raise RuntimeError("未能找到合适的终点")
        
        # 为每个终点选择起点
        trajectories_per_end = self.config['NUM_TRAJECTORIES_TO_GENERATE'] // len(self.selected_end_points)
        remaining = self.config['NUM_TRAJECTORIES_TO_GENERATE'] % len(self.selected_end_points)
        
        for i, end_point in enumerate(self.selected_end_points):
            # 确定当前终点需要的起点数量
            n_starts = trajectories_per_end + (1 if i < remaining else 0)
            
            # 选择起点
            start_points = self._select_start_points(end_point, n_starts)
            
            # 转换为地理坐标
            end_coord = self.terrain_loader.transform_pixel_to_coord(*end_point)
            start_coords = [
                self.terrain_loader.transform_pixel_to_coord(*p)
                for p in start_points
            ]
            
            # 添加到生成对列表
            for start_coord in start_coords:
                self.generation_pairs.append((start_coord, end_coord))
        
        logger.info(f"已选择 {len(self.generation_pairs)} 对起终点")
        return self.generation_pairs
    
    def _select_end_points(self) -> None:
        """选择合适的终点"""
        # 获取城市区域掩码
        urban_mask = np.isin(
            self.terrain_loader.landcover_data,
            self.config['URBAN_LANDCOVER_CODES']
        )
        
        # 获取可通行区域掩码
        passable_mask = ~np.isin(
            self.terrain_loader.landcover_data,
            self.config['IMPASSABLE_LANDCOVER_CODES']
        )
        
        # 获取有效终点候选区域
        valid_mask = urban_mask & passable_mask
        valid_points = np.argwhere(valid_mask)
        
        if len(valid_points) < self.config['NUM_END_POINTS']:
            raise RuntimeError(
                f"可用的终点候选数量({len(valid_points)})少于需要的数量"
                f"({self.config['NUM_END_POINTS']})"
            )
        
        # 随机选择终点
        selected_indices = np.random.choice(
            len(valid_points),
            size=self.config['NUM_END_POINTS'],
            replace=False
        )
        
        self.selected_end_points = [
            tuple(valid_points[i])
            for i in selected_indices
        ]
        
        logger.info(f"已选择 {len(self.selected_end_points)} 个终点")
    
    def _select_start_points(
            self,
            end_point: Tuple[int, int],
            n_points: int
        ) -> List[Tuple[int, int]]:
        """
        为指定终点选择合适的起点
        
        Args:
            end_point: 终点像素坐标 (row, col)
            n_points: 需要选择的起点数量
            
        Returns:
            List[Tuple[int, int]]: 起点列表
        """
        # 获取不可通行区域掩码
        impassable_mask = np.isin(
            self.terrain_loader.landcover_data,
            self.config['IMPASSABLE_LANDCOVER_CODES']
        )
        
        # 计算与终点的距离（米）
        rows, cols = np.indices(self.terrain_loader.dem_data.shape)
        distances = self._calculate_distances(
            rows, cols,
            end_point[0], end_point[1]
        )
        
        # 创建有效起点掩码
        valid_mask = (
            ~impassable_mask &  # 可通行
            (distances >= self.config['MIN_START_END_DISTANCE_METERS'])  # 满足最小距离
        )
        
        valid_points = np.argwhere(valid_mask)
        if len(valid_points) < n_points:
            raise RuntimeError(
                f"可用的起点候选数量({len(valid_points)})少于需要的数量({n_points})"
            )
        
        # 随机选择起点
        selected_indices = np.random.choice(
            len(valid_points),
            size=n_points,
            replace=False
        )
        
        return [
            tuple(valid_points[i])
            for i in selected_indices
        ]
    
    def _calculate_distances(
            self,
            rows: np.ndarray,
            cols: np.ndarray,
            end_row: int,
            end_col: int
        ) -> np.ndarray:
        """
        计算栅格中所有点到终点的距离（米）
        
        Args:
            rows: 行索引数组
            cols: 列索引数组
            end_row: 终点行索引
            end_col: 终点列索引
            
        Returns:
            np.ndarray: 距离数组（米）
        """
        # 将像素距离转换为地理距离（米）
        pixel_distances = np.sqrt(
            (rows - end_row)**2 +
            (cols - end_col)**2
        )
        
        return pixel_distances * self.terrain_loader.resolution
    
    def visualize_points(self, output_file: Optional[str] = None) -> None:
        """
        可视化选择的起终点
        
        Args:
            output_file: 输出文件路径，可选
        """
        import matplotlib.pyplot as plt
        
        plt.figure(figsize=(12, 8))
        
        # 绘制地形
        plt.imshow(self.terrain_loader.dem_data, cmap='terrain')
        plt.colorbar(label='Elevation (m)')
        
        # 绘制终点
        end_points = np.array(self.selected_end_points)
        plt.scatter(
            end_points[:, 1],
            end_points[:, 0],
            c='red',
            marker='^',
            s=100,
            label='End Points'
        )
        
        # 绘制起点
        start_points = []
        for start_coord, _ in self.generation_pairs:
            row, col = self.terrain_loader.transform_coordinates(
                start_coord[0],
                start_coord[1]
            )
            start_points.append((row, col))
        
        start_points = np.array(start_points)
        plt.scatter(
            start_points[:, 1],
            start_points[:, 0],
            c='blue',
            marker='o',
            s=50,
            label='Start Points'
        )
        
        plt.title('Selected Start and End Points')
        plt.legend()
        
        if output_file:
            plt.savefig(output_file)
            logger.info(f"已保存可视化结果到: {output_file}")
        else:
            plt.show()
        
        plt.close() 
```

### src/trajectory_generation/trajectory_generator.py
```python
"""
轨迹生成器
实现轨迹插值和速度规划功能
"""

import logging
from typing import Dict, List, Optional, Tuple
import numpy as np
from scipy.interpolate import CubicSpline
from scipy.spatial.distance import cdist

from ..data_processing import TerrainLoader, EnvironmentMapper

logger = logging.getLogger(__name__)

class TrajectoryGenerator:
    """轨迹生成器基类"""
    
    def __init__(
            self,
            terrain_loader: TerrainLoader,
            environment_mapper: EnvironmentMapper,
            config: Dict
        ):
        """
        初始化轨迹生成器
        
        Args:
            terrain_loader: 地形数据加载器实例
            environment_mapper: 环境地图生成器实例
            config: 配置参数字典，包含：
                - dt: 时间步长（秒）
                - MAX_ACCELERATION: 最大加速度（米/秒²）
                - MAX_DECELERATION: 最大减速度（米/秒²）
                - MAX_SPEED: 最大速度（米/秒）
                - MIN_SPEED: 最小速度（米/秒）
        """
        self.terrain_loader = terrain_loader
        self.environment_mapper = environment_mapper
        self.config = config
        
        # 获取环境地图
        self.maps = environment_mapper.get_maps()
        
        # 验证配置参数
        self._validate_config()
    
    def _validate_config(self) -> None:
        """验证配置参数"""
        required_params = [
            'dt',
            'MAX_ACCELERATION',
            'MAX_DECELERATION',
            'MAX_SPEED',
            'MIN_SPEED'
        ]
        
        for param in required_params:
            if param not in self.config:
                raise ValueError(f"缺少必要的配置参数: {param}")
    
    def generate_trajectory(
            self,
            path_points: List[Tuple[int, int]]
        ) -> Dict:
        """
        生成轨迹
        
        Args:
            path_points: 路径点列表，每个点为 (row, col)
            
        Returns:
            Dict: 轨迹数据，包含：
                - timestamps: 时间戳列表（秒）
                - positions: 位置列表，每个元素为 (row, col)
                - speeds: 速度列表（米/秒）
                - headings: 朝向列表（度）
                - coordinates: 地理坐标列表，每个元素为 (lon, lat)
        """
        # 1. 路径插值
        interpolated_path = self._interpolate_path(path_points)
        
        # 2. 速度规划
        speeds = self._plan_speeds(interpolated_path)
        
        # 3. 时间规划
        timestamps = self._plan_timestamps(interpolated_path, speeds)
        
        # 4. 计算朝向
        headings = self._calculate_headings(interpolated_path)
        
        # 5. 转换为地理坐标
        coordinates = [
            self.terrain_loader.transform_pixel_to_coord(row, col)
            for row, col in interpolated_path
        ]
        
        return {
            'timestamps': timestamps,
            'positions': interpolated_path,
            'speeds': speeds,
            'headings': headings,
            'coordinates': coordinates
        }
    
    def _interpolate_path(
            self,
            path_points: List[Tuple[int, int]]
        ) -> List[Tuple[int, int]]:
        """
        使用三次样条插值平滑路径
        
        Args:
            path_points: 原始路径点列表
            
        Returns:
            List[Tuple[int, int]]: 插值后的路径点列表
        """
        if len(path_points) < 2:
            return path_points
        
        # 转换为数组
        points = np.array(path_points)
        
        # 计算路径长度参数
        t = np.zeros(len(points))
        for i in range(1, len(points)):
            t[i] = t[i-1] + np.sqrt(
                np.sum((points[i] - points[i-1])**2)
            )
        
        # 创建更密集的参数点
        num_points = int(t[-1] / self.config['dt'])
        t_new = np.linspace(0, t[-1], num_points)
        
        # 对行和列分别进行插值
        cs_row = CubicSpline(t, points[:, 0])
        cs_col = CubicSpline(t, points[:, 1])
        
        # 生成插值点
        rows = cs_row(t_new)
        cols = cs_col(t_new)
        
        # 转换为整数坐标
        interpolated = list(zip(
            np.round(rows).astype(int),
            np.round(cols).astype(int)
        ))
        
        # 去除重复点
        return list(dict.fromkeys(interpolated))
    
    def _plan_speeds(
            self,
            path_points: List[Tuple[int, int]]
        ) -> List[float]:
        """
        规划速度曲线
        
        Args:
            path_points: 插值后的路径点列表
            
        Returns:
            List[float]: 速度列表（米/秒）
        """
        if len(path_points) < 2:
            return [0.0] * len(path_points)
        
        # 获取每个点的最大允许速度
        max_speeds = [
            min(
                self.maps['max_speed_map'][row, col],
                self.config['MAX_SPEED']
            )
            for row, col in path_points
        ]
        
        # 初始化速度列表
        speeds = [0.0] * len(path_points)
        speeds[0] = self.config['MIN_SPEED']  # 起点速度
        
        # 前向传播：考虑加速度限制
        for i in range(1, len(path_points)):
            # 计算两点间距离
            dist = np.sqrt(
                sum((a - b)**2 for a, b in
                    zip(path_points[i], path_points[i-1]))
            ) * self.terrain_loader.resolution
            
            # 计算可能的最大速度（考虑加速度限制）
            v_prev = speeds[i-1]
            v_max_acc = np.sqrt(
                v_prev**2 +
                2 * self.config['MAX_ACCELERATION'] * dist
            )
            
            # 取较小值作为当前速度
            speeds[i] = min(v_max_acc, max_speeds[i])
        
        # 后向传播：考虑减速度限制
        for i in range(len(path_points)-2, -1, -1):
            # 计算两点间距离
            dist = np.sqrt(
                sum((a - b)**2 for a, b in
                    zip(path_points[i+1], path_points[i]))
            ) * self.terrain_loader.resolution
            
            # 计算为了安全减速需要的速度
            v_next = speeds[i+1]
            v_max_dec = np.sqrt(
                v_next**2 +
                2 * self.config['MAX_DECELERATION'] * dist
            )
            
            # 更新速度
            speeds[i] = min(speeds[i], v_max_dec)
        
        return speeds
    
    def _plan_timestamps(
            self,
            path_points: List[Tuple[int, int]],
            speeds: List[float]
        ) -> List[float]:
        """
        规划时间戳
        
        Args:
            path_points: 路径点列表
            speeds: 速度列表
            
        Returns:
            List[float]: 时间戳列表（秒）
        """
        timestamps = [0.0]  # 起点时间戳
        
        for i in range(1, len(path_points)):
            # 计算两点间距离
            dist = np.sqrt(
                sum((a - b)**2 for a, b in
                    zip(path_points[i], path_points[i-1]))
            ) * self.terrain_loader.resolution
            
            # 使用平均速度计算时间增量
            avg_speed = (speeds[i] + speeds[i-1]) / 2
            dt = dist / max(avg_speed, self.config['MIN_SPEED'])
            
            # 添加时间戳
            timestamps.append(timestamps[-1] + dt)
        
        return timestamps
    
    def _calculate_headings(
            self,
            path_points: List[Tuple[int, int]]
        ) -> List[float]:
        """
        计算路径点的朝向角度
        
        Args:
            path_points: 路径点列表
            
        Returns:
            List[float]: 朝向角度列表（度，北为0，顺时针为正）
        """
        if len(path_points) < 2:
            return [0.0] * len(path_points)
        
        headings = []
        
        # 计算第一个点的朝向（使用下一个点）
        dx = path_points[1][1] - path_points[0][1]
        dy = path_points[1][0] - path_points[0][0]
        heading = np.degrees(np.arctan2(dx, -dy)) % 360
        headings.append(heading)
        
        # 计算中间点的朝向（使用前后点的平均）
        for i in range(1, len(path_points)-1):
            dx = path_points[i+1][1] - path_points[i-1][1]
            dy = path_points[i+1][0] - path_points[i-1][0]
            heading = np.degrees(np.arctan2(dx, -dy)) % 360
            headings.append(heading)
        
        # 计算最后一个点的朝向（使用前一个点）
        dx = path_points[-1][1] - path_points[-2][1]
        dy = path_points[-1][0] - path_points[-2][0]
        heading = np.degrees(np.arctan2(dx, -dy)) % 360
        headings.append(heading)
        
        return headings 
```

### src/utils/__init__.py
```python

```

### src/utils/logging_utils.py
```python
"""
日志工具模块
用于配置和管理日志
"""

import logging
from pathlib import Path
import matplotlib
import PIL
import rasterio
import sklearn

def setup_logging(log_file: str = None, log_level: int = logging.INFO) -> None:
    """
    设置日志配置
    
    Args:
        log_file: 日志文件路径，如果为None则只输出到控制台
        log_level: 日志级别，默认为INFO
    """
    # 创建根日志记录器
    logger = logging.getLogger()
    logger.setLevel(log_level)
    
    # 清除现有的处理器
    logger.handlers.clear()
    
    # 创建格式化器
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # 添加控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    
    # 如果指定了日志文件，添加文件处理器
    if log_file:
        # 确保日志目录存在
        log_path = Path(log_file)
        log_path.parent.mkdir(parents=True, exist_ok=True)
        
        file_handler = logging.FileHandler(log_file)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
    
    # 设置第三方库的日志级别
    logging.getLogger('matplotlib').setLevel(logging.WARNING)
    logging.getLogger('PIL').setLevel(logging.WARNING)
    logging.getLogger('rasterio').setLevel(logging.WARNING)
    logging.getLogger('sklearn').setLevel(logging.WARNING) 
```

### test_plot_style.py
```python
import matplotlib.pyplot as plt
import numpy as np
import plot_style  # 导入样式设置

# 创建测试数据
x = np.linspace(0, 10, 100)
y1 = 1e3 * np.sin(x)
y2 = 1e-3 * np.cos(x)

# 创建图形
fig, ax = plt.subplots()

# 绘制曲线
ax.plot(x, y1, 'b-', label='正弦曲线')
ax.plot(x, y2, 'r--', label='余弦曲线')

# 设置标题和标签
ax.set_title('三角函数测试图')
ax.set_xlabel('时间 (s)')
ax.set_ylabel(r'幅值 ($\times 10^{-3}$)')  # 使用原始字符串

# 添加图例
ax.legend()

# 保存图片
plt.savefig('test_style.png', bbox_inches='tight')
print("图片已保存为 test_style.png") 
```

### tests/__init__.py
```python

```

### tests/conftest.py
```python
"""
测试配置文件
定义测试环境和通用fixture
"""

import os
import sys
from pathlib import Path
import pytest
import numpy as np

# 添加项目根目录到Python路径
PROJECT_ROOT = Path(__file__).parent.parent.absolute()
sys.path.append(str(PROJECT_ROOT))

# 测试数据目录
TEST_DATA_DIR = PROJECT_ROOT / "tests" / "test_data"
TEST_DATA_DIR.mkdir(parents=True, exist_ok=True)

@pytest.fixture
def test_dem_data():
    """生成测试用DEM数据"""
    # 创建一个简单的10x10的DEM数据
    dem = np.array([
        [100, 100, 100, 100, 100, 100, 100, 100, 100, 100],
        [100, 110, 110, 110, 110, 110, 110, 110, 110, 100],
        [100, 110, 120, 120, 120, 120, 120, 120, 110, 100],
        [100, 110, 120, 130, 130, 130, 130, 120, 110, 100],
        [100, 110, 120, 130, 140, 140, 130, 120, 110, 100],
        [100, 110, 120, 130, 140, 140, 130, 120, 110, 100],
        [100, 110, 120, 130, 130, 130, 130, 120, 110, 100],
        [100, 110, 120, 120, 120, 120, 120, 120, 110, 100],
        [100, 110, 110, 110, 110, 110, 110, 110, 110, 100],
        [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]
    ], dtype=np.float32)
    return dem

@pytest.fixture
def test_landcover_data():
    """生成测试用土地覆盖数据"""
    # 创建一个简单的10x10的土地覆盖数据
    landcover = np.array([
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 2, 2, 2, 2, 2, 2, 2, 2, 1],
        [1, 2, 3, 3, 3, 3, 3, 3, 2, 1],
        [1, 2, 3, 4, 4, 4, 4, 3, 2, 1],
        [1, 2, 3, 4, 5, 5, 4, 3, 2, 1],
        [1, 2, 3, 4, 5, 5, 4, 3, 2, 1],
        [1, 2, 3, 4, 4, 4, 4, 3, 2, 1],
        [1, 2, 3, 3, 3, 3, 3, 3, 2, 1],
        [1, 2, 2, 2, 2, 2, 2, 2, 2, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ], dtype=np.int32)
    return landcover

@pytest.fixture
def test_trajectory_data(tmp_path):
    """生成测试用轨迹数据"""
    # 创建一个简单的轨迹CSV文件
    import pandas as pd
    
    # 生成测试数据 - 使用正弦曲线生成更真实的轨迹
    n_points = 20
    timestamps = pd.date_range('2024-03-27', periods=n_points, freq='30s')
    t = np.linspace(0, 2*np.pi, n_points)
    
    # 基准点和振幅
    base_lon, base_lat = 116.0, 39.0
    amp_lon, amp_lat = 0.01, 0.01
    
    data = {
        'timestamp': timestamps,
        'longitude': base_lon + amp_lon * np.sin(t),
        'latitude': base_lat + amp_lat * np.cos(t)
    }
    df = pd.DataFrame(data)
    
    # 保存到临时文件
    test_file = tmp_path / "test_trajectory.csv"
    df.to_csv(test_file, index=False)
    return test_file 
```

### tests/data_processing/test_oord_processor.py
```python
"""
OORD数据处理器测试模块
"""

import os
import sys
from pathlib import Path
import pytest
import numpy as np
import pandas as pd
import rasterio.transform

# 添加项目根目录到Python路径
PROJECT_ROOT = Path(__file__).parent.parent.parent.absolute()
sys.path.append(str(PROJECT_ROOT))

from src.data_processing import TerrainLoader, TerrainAnalyzer, OORDProcessor

@pytest.fixture
def terrain_loader():
    """创建测试用TerrainLoader实例"""
    loader = TerrainLoader()
    # 创建简单的测试数据
    dem_data = np.array([
        [100, 110, 120],
        [110, 120, 130],
        [120, 130, 140]
    ], dtype=np.float32)
    landcover_data = np.array([
        [1, 1, 2],
        [1, 2, 2],
        [2, 2, 3]
    ], dtype=np.int32)
    
    # 设置地理变换矩阵
    # 使用北京附近区域作为测试区域 (116.0E, 39.0N)
    resolution = 30  # 30米分辨率
    transform = rasterio.transform.from_origin(
        west=116.0,     # 左边界经度
        north=39.0,     # 上边界纬度
        xsize=resolution,  # 经度方向分辨率
        ysize=resolution   # 纬度方向分辨率
    )
    
    loader.dem_data = dem_data
    loader.landcover_data = landcover_data
    loader.resolution = resolution
    loader.transform = transform
    return loader

@pytest.fixture
def test_trajectory_data(tmp_path):
    """创建测试用轨迹数据"""
    # 创建测试数据
    data = {
        'timestamp_ms': np.arange(0, 5000, 1000),  # 5个点，每秒一个
        'latitude': [39.0, 39.001, 39.002, 39.003, 39.004],
        'longitude': [116.0, 116.001, 116.002, 116.003, 116.004],
        'altitude_m': [100, 110, 120, 130, 140],
        'velocity_north_ms': [1.0, 1.5, 2.0, 1.5, 1.0],
        'velocity_east_ms': [0.5, 1.0, 1.5, 1.0, 0.5],
        'velocity_down_ms': [0.0, 0.1, 0.2, 0.1, 0.0],
        'acceleration_x_ms2': [0.1, 0.2, 0.1, 0.0, -0.1],
        'acceleration_y_ms2': [0.1, 0.1, 0.0, -0.1, -0.1],
        'acceleration_z_ms2': [0.0, 0.1, 0.0, -0.1, 0.0],
        'angular_velocity_x_rads': [0.01, 0.02, 0.01, 0.0, -0.01],
        'angular_velocity_y_rads': [0.01, 0.01, 0.0, -0.01, -0.01],
        'angular_velocity_z_rads': [0.1, 0.2, 0.1, 0.0, -0.1]
    }
    df = pd.DataFrame(data)
    
    # 保存到临时文件
    test_file = tmp_path / "test_trajectory.csv"
    df.to_csv(test_file, index=False)
    return test_file

def test_oord_processor_init(terrain_loader):
    """测试OORDProcessor初始化"""
    processor = OORDProcessor(terrain_loader)
    assert processor.terrain_loader is terrain_loader
    assert isinstance(processor.trajectories, dict)
    assert isinstance(processor.processed_trajectories, dict)
    assert len(processor.trajectories) == 0
    assert len(processor.processed_trajectories) == 0

def test_load_trajectory(terrain_loader, test_trajectory_data):
    """测试轨迹加载功能"""
    processor = OORDProcessor(terrain_loader)
    df = processor.load_trajectory(test_trajectory_data)
    
    # 验证基本数据结构
    assert isinstance(df, pd.DataFrame)
    assert len(df) == 5  # 测试数据有5个点
    
    # 验证计算的特征
    assert 'speed' in df.columns
    assert 'heading' in df.columns
    assert 'turn_rate' in df.columns
    assert 'acceleration' in df.columns
    
    # 验证速度计算
    expected_speed = np.sqrt(df['velocity_north_ms']**2 + df['velocity_east_ms']**2)
    np.testing.assert_array_almost_equal(df['speed'], expected_speed)
    
    # 验证加速度计算
    expected_accel = np.sqrt(
        df['acceleration_x_ms2']**2 + 
        df['acceleration_y_ms2']**2 + 
        df['acceleration_z_ms2']**2
    )
    np.testing.assert_array_almost_equal(df['acceleration'], expected_accel)
    
    # 验证航向角计算
    expected_heading = np.degrees(np.arctan2(
        df['velocity_east_ms'],
        df['velocity_north_ms']
    )) % 360
    np.testing.assert_array_almost_equal(df['heading'], expected_heading)

def test_process_trajectory(terrain_loader, test_trajectory_data):
    """测试轨迹处理功能"""
    processor = OORDProcessor(terrain_loader)
    processor.load_trajectory(test_trajectory_data)
    trajectory_id = Path(test_trajectory_data).stem
    
    df_processed = processor.process_trajectory(
        trajectory_id,
        max_speed=50.0
    )
    
    # 验证基本处理结果
    assert isinstance(df_processed, pd.DataFrame)
    assert len(df_processed) > 0
    assert all(df_processed['speed'] <= 50.0)
    
    # 验证环境分组
    assert 'slope_group' in df_processed.columns
    assert 'group_label' in df_processed.columns
    assert df_processed['slope_group'].notna().all()
    assert df_processed['group_label'].notna().all()

def test_analyze_environment_interaction(terrain_loader, test_trajectory_data):
    """测试环境交互分析功能"""
    processor = OORDProcessor(terrain_loader)
    processor.load_trajectory(test_trajectory_data)
    trajectory_id = Path(test_trajectory_data).stem
    processor.process_trajectory(trajectory_id)
    
    stats = processor.analyze_environment_interaction()
    
    # 验证统计结果
    assert isinstance(stats, dict)
    assert len(stats) > 0
    
    # 验证统计指标
    for group_stats in stats.values():
        required_stats = [
            'speed_mean', 'speed_std', 'speed_median', 'speed_max',
            'acceleration_std', 'turn_rate_std', 'sample_size'
        ]
        for stat in required_stats:
            assert stat in group_stats
            assert isinstance(group_stats[stat], (int, float))
            assert not np.isnan(group_stats[stat])

def test_calculate_haversine_distance():
    """测试Haversine距离计算"""
    # 使用北京天安门（116.397, 39.916）和上海外滩（121.484, 31.233）的坐标
    lon1, lat1 = 116.397, 39.916  # 北京天安门
    lon2, lat2 = 121.484, 31.233  # 上海外滩
    
    # 计算两点之间的距离
    processor = OORDProcessor()  # 不需要地形数据
    distance = processor.calculate_haversine_distance(
        lon1=lon1, lat1=lat1,
        lon2=lon2, lat2=lat2
    )
    
    # 预期距离约为1067公里
    expected_distance = 1067.0  # 单位：公里
    assert abs(distance - expected_distance) < 5.0  # 允许5公里的误差

def test_calculate_heading():
    """测试航向角计算"""
    processor = OORDProcessor()  # 不需要地形数据
    
    # 测试正北方向
    heading = processor.calculate_heading(
        velocity_north=1.0,
        velocity_east=0.0
    )
    assert abs(heading - 0.0) < 1e-6
    
    # 测试正东方向
    heading = processor.calculate_heading(
        velocity_north=0.0,
        velocity_east=1.0
    )
    assert abs(heading - 90.0) < 1e-6
    
    # 测试正南方向
    heading = processor.calculate_heading(
        velocity_north=-1.0,
        velocity_east=0.0
    )
    assert abs(heading - 180.0) < 1e-6
    
    # 测试正西方向
    heading = processor.calculate_heading(
        velocity_north=0.0,
        velocity_east=-1.0
    )
    assert abs(heading - 270.0) < 1e-6
    
    # 测试东北方向（45度）
    heading = processor.calculate_heading(
        velocity_north=1.0,
        velocity_east=1.0
    )
    assert abs(heading - 45.0) < 1e-6 
```

### tests/data_processing/test_terrain_analyzer.py
```python
"""
TerrainAnalyzer模块的单元测试
"""

import pytest
import numpy as np
import rasterio
from pathlib import Path

from src.data_processing import TerrainAnalyzer

def test_terrain_analyzer_init():
    """测试TerrainAnalyzer的初始化"""
    analyzer = TerrainAnalyzer()
    assert analyzer.dem_data is None
    assert analyzer.slope_magnitude is None
    assert analyzer.slope_aspect is None
    assert analyzer.dzdx is None
    assert analyzer.dzdy is None
    assert analyzer.resolution is None

def test_load_dem(test_dem_data):
    """测试DEM数据加载功能"""
    analyzer = TerrainAnalyzer()
    resolution = (30.0, 30.0)  # 30米分辨率
    analyzer.load_dem(test_dem_data, resolution)
    
    assert analyzer.dem_data is not None
    assert np.array_equal(analyzer.dem_data, test_dem_data)
    assert analyzer.resolution == resolution

def test_calculate_slope_magnitude(test_dem_data):
    """测试坡度大小计算功能"""
    analyzer = TerrainAnalyzer()
    resolution = (30.0, 30.0)
    analyzer.load_dem(test_dem_data, resolution)
    
    slope_magnitude = analyzer.calculate_slope_magnitude()
    
    assert slope_magnitude is not None
    assert slope_magnitude.shape == test_dem_data.shape
    assert np.all(slope_magnitude >= 0)  # 坡度应该非负
    assert analyzer.slope_magnitude is not None
    
    # 检查平地和陡坡
    flat_mask = test_dem_data == test_dem_data[0, 0]  # 找出高度相同的点
    assert np.all(slope_magnitude[flat_mask] < 0.1)  # 平地坡度应接近0

def test_calculate_slope_aspect(test_dem_data):
    """测试坡向计算功能"""
    analyzer = TerrainAnalyzer()
    resolution = (30.0, 30.0)
    analyzer.load_dem(test_dem_data, resolution)
    
    slope_aspect = analyzer.calculate_slope_aspect()
    
    assert slope_aspect is not None
    assert slope_aspect.shape == test_dem_data.shape
    assert analyzer.slope_aspect is not None
    
    # 检查坡向范围
    valid_mask = slope_aspect != -1
    if np.any(valid_mask):
        assert np.all((slope_aspect[valid_mask] >= 0) & (slope_aspect[valid_mask] < 360))
    
    # 检查平地的坡向
    if analyzer.slope_magnitude is not None:
        flat_mask = analyzer.slope_magnitude < 0.1
        assert np.all(slope_aspect[flat_mask] == -1)

def test_calculate_gradients(test_dem_data):
    """测试梯度计算功能"""
    analyzer = TerrainAnalyzer()
    resolution = (30.0, 30.0)
    analyzer.load_dem(test_dem_data, resolution)
    
    dzdx, dzdy = analyzer.calculate_gradients()
    
    assert dzdx is not None
    assert dzdy is not None
    assert dzdx.shape == test_dem_data.shape
    assert dzdy.shape == test_dem_data.shape
    assert analyzer.dzdx is not None
    assert analyzer.dzdy is not None
    
    # 检查平地的梯度
    flat_mask = test_dem_data == test_dem_data[0, 0]
    assert np.all(np.abs(dzdx[flat_mask]) < 1e-6)
    assert np.all(np.abs(dzdy[flat_mask]) < 1e-6)

def test_save_results(test_dem_data, tmp_path):
    """测试结果保存功能"""
    analyzer = TerrainAnalyzer()
    resolution = (30.0, 30.0)
    analyzer.load_dem(test_dem_data, resolution)
    
    # 计算所有地形属性
    analyzer.calculate_slope_magnitude()
    analyzer.calculate_slope_aspect()
    analyzer.calculate_gradients()
    
    # 保存结果
    output_dir = tmp_path / "terrain_results"
    analyzer.save_results(output_dir)
    
    # 验证文件是否创建
    assert (output_dir / "slope_magnitude_30m_100km.tif").exists()
    assert (output_dir / "slope_aspect_30m_100km.tif").exists()
    assert (output_dir / "dzdx_30m_100km.tif").exists()
    assert (output_dir / "dzdy_30m_100km.tif").exists()
    
    # 验证保存的数据是否正确
    with rasterio.open(output_dir / "slope_magnitude_30m_100km.tif") as src:
        saved_slope = src.read(1)
        assert np.array_equal(saved_slope, analyzer.slope_magnitude)

def test_error_handling():
    """测试错误处理"""
    analyzer = TerrainAnalyzer()
    
    # 测试在未加载数据时的错误处理
    with pytest.raises(ValueError):
        analyzer.calculate_slope_magnitude()
    
    with pytest.raises(ValueError):
        analyzer.calculate_slope_aspect()
    
    with pytest.raises(ValueError):
        analyzer.calculate_gradients() 
```

### tests/data_processing/test_terrain_loader.py
```python
"""
TerrainLoader模块的单元测试
"""

import pytest
import numpy as np
import rasterio
from pathlib import Path

from src.data_processing import TerrainLoader

def test_terrain_loader_init():
    """测试TerrainLoader的初始化"""
    loader = TerrainLoader()
    assert loader.dem_data is None
    assert loader.landcover_data is None
    assert loader.transform is None
    assert loader.crs is None
    assert loader.resolution is None
    assert loader.bounds is None

def test_load_dem(test_dem_data, tmp_path):
    """测试DEM数据加载功能"""
    # 准备测试数据
    dem_path = tmp_path / "test_dem.tif"
    with rasterio.open(
        dem_path,
        'w',
        driver='GTiff',
        height=test_dem_data.shape[0],
        width=test_dem_data.shape[1],
        count=1,
        dtype=test_dem_data.dtype,
        crs='+proj=latlong',
        transform=rasterio.transform.from_bounds(
            116.0, 39.0, 116.1, 39.1,
            test_dem_data.shape[1], test_dem_data.shape[0]
        )
    ) as dst:
        dst.write(test_dem_data, 1)
    
    # 测试加载功能
    loader = TerrainLoader()
    dem_array = loader.load_dem(dem_path)
    
    assert dem_array is not None
    assert dem_array.shape == test_dem_data.shape
    assert np.allclose(dem_array, test_dem_data)
    assert loader.transform is not None
    assert loader.crs is not None
    assert loader.resolution is not None
    assert loader.bounds is not None

def test_load_landcover(test_dem_data, test_landcover_data, tmp_path):
    """测试土地覆盖数据加载功能"""
    # 准备DEM测试数据
    dem_path = tmp_path / "test_dem.tif"
    landcover_path = tmp_path / "test_landcover.tif"
    transform = rasterio.transform.from_bounds(
        116.0, 39.0, 116.1, 39.1,
        test_dem_data.shape[1], test_dem_data.shape[0]
    )
    
    # 保存DEM数据
    with rasterio.open(
        dem_path,
        'w',
        driver='GTiff',
        height=test_dem_data.shape[0],
        width=test_dem_data.shape[1],
        count=1,
        dtype=test_dem_data.dtype,
        crs='+proj=latlong',
        transform=transform
    ) as dst:
        dst.write(test_dem_data, 1)
    
    # 保存土地覆盖数据
    with rasterio.open(
        landcover_path,
        'w',
        driver='GTiff',
        height=test_landcover_data.shape[0],
        width=test_landcover_data.shape[1],
        count=1,
        dtype=test_landcover_data.dtype,
        crs='+proj=latlong',
        transform=transform
    ) as dst:
        dst.write(test_landcover_data, 1)
    
    # 测试加载功能
    loader = TerrainLoader()
    loader.load_dem(dem_path)
    landcover_array = loader.load_landcover(landcover_path)
    
    assert landcover_array is not None
    assert landcover_array.shape == test_landcover_data.shape
    assert np.array_equal(landcover_array, test_landcover_data)

def test_coordinate_conversion(tmp_path, test_dem_data):
    """测试坐标转换功能"""
    # 准备测试数据
    dem_path = tmp_path / "test_dem.tif"
    transform = rasterio.transform.from_bounds(
        116.0, 39.0, 116.1, 39.1,
        test_dem_data.shape[1], test_dem_data.shape[0]
    )
    
    with rasterio.open(
        dem_path,
        'w',
        driver='GTiff',
        height=test_dem_data.shape[0],
        width=test_dem_data.shape[1],
        count=1,
        dtype=test_dem_data.dtype,
        crs='+proj=latlong',
        transform=transform
    ) as dst:
        dst.write(test_dem_data, 1)
    
    # 测试坐标转换
    loader = TerrainLoader()
    loader.load_dem(dem_path)
    
    # 测试经纬度到像素坐标的转换
    row, col = loader.get_pixel_coords(116.05, 39.05)
    assert isinstance(row, int)
    assert isinstance(col, int)
    assert 0 <= row < test_dem_data.shape[0]
    assert 0 <= col < test_dem_data.shape[1]
    
    # 测试像素坐标到经纬度的转换
    lon, lat = loader.get_geo_coords(row, col)
    assert isinstance(lon, float)
    assert isinstance(lat, float)
    assert 116.0 <= lon <= 116.1
    assert 39.0 <= lat <= 39.1

def test_get_elevation_and_landcover(tmp_path, test_dem_data, test_landcover_data):
    """测试获取高程和土地覆盖类型功能"""
    # 准备测试数据
    dem_path = tmp_path / "test_dem.tif"
    landcover_path = tmp_path / "test_landcover.tif"
    transform = rasterio.transform.from_bounds(
        116.0, 39.0, 116.1, 39.1,
        test_dem_data.shape[1], test_dem_data.shape[0]
    )
    
    # 保存DEM数据
    with rasterio.open(
        dem_path,
        'w',
        driver='GTiff',
        height=test_dem_data.shape[0],
        width=test_dem_data.shape[1],
        count=1,
        dtype=test_dem_data.dtype,
        crs='+proj=latlong',
        transform=transform
    ) as dst:
        dst.write(test_dem_data, 1)
    
    # 保存土地覆盖数据
    with rasterio.open(
        landcover_path,
        'w',
        driver='GTiff',
        height=test_landcover_data.shape[0],
        width=test_landcover_data.shape[1],
        count=1,
        dtype=test_landcover_data.dtype,
        crs='+proj=latlong',
        transform=transform
    ) as dst:
        dst.write(test_landcover_data, 1)
    
    # 测试获取高程和土地覆盖类型
    loader = TerrainLoader()
    loader.load_dem(dem_path)
    loader.load_landcover(landcover_path)
    
    # 测试中心点的值
    center_lon = 116.05
    center_lat = 39.05
    
    elevation = loader.get_elevation(center_lon, center_lat)
    assert isinstance(elevation, float)
    assert 100 <= elevation <= 140
    
    landcover = loader.get_landcover(center_lon, center_lat)
    assert isinstance(landcover, int)
    assert 1 <= landcover <= 5

def test_error_handling():
    """测试错误处理"""
    loader = TerrainLoader()
    
    # 测试在未加载数据时的错误处理
    with pytest.raises(ValueError):
        loader.get_pixel_coords(116.0, 39.0)
    
    with pytest.raises(ValueError):
        loader.get_geo_coords(0, 0)
    
    with pytest.raises(ValueError):
        loader.get_elevation(116.0, 39.0)
    
    with pytest.raises(ValueError):
        loader.get_landcover(116.0, 39.0) 
```

### tests/trajectory_generation/test_environment_based_generator.py
```python
"""
基于环境的轨迹生成器测试模块
"""

import os
import sys
from pathlib import Path
import pytest
import numpy as np
import pandas as pd
import rasterio.transform

# 添加项目根目录到Python路径
PROJECT_ROOT = Path(__file__).parent.parent.parent.absolute()
sys.path.append(str(PROJECT_ROOT))

from src.data_processing import TerrainLoader
from src.trajectory_generation import EnvironmentBasedGenerator

@pytest.fixture
def terrain_loader():
    """创建测试用TerrainLoader实例"""
    loader = TerrainLoader()
    # 创建简单的测试数据
    dem_data = np.array([
        [100, 110, 120],
        [110, 120, 130],
        [120, 130, 140]
    ], dtype=np.float32)
    landcover_data = np.array([
        [1, 1, 2],
        [1, 2, 2],
        [2, 2, 3]
    ], dtype=np.int32)
    
    # 设置地理变换矩阵
    # 使用北京附近区域作为测试区域 (116.0E, 39.0N)
    resolution = 30  # 30米分辨率
    transform = rasterio.transform.from_origin(
        west=116.0,     # 左边界经度
        north=39.0,     # 上边界纬度
        xsize=resolution,  # 经度方向分辨率
        ysize=resolution   # 纬度方向分辨率
    )
    
    loader.dem_data = dem_data
    loader.landcover_data = landcover_data
    loader.resolution = resolution
    loader.transform = transform
    return loader

def test_environment_based_generator_init(terrain_loader):
    """测试基于环境的轨迹生成器初始化"""
    generator = EnvironmentBasedGenerator(terrain_loader)
    
    # 验证基本属性
    assert generator.terrain_loader is terrain_loader
    assert generator.terrain_analyzer is not None
    assert generator.terrain_analyzer.dem_data is not None
    assert generator.terrain_analyzer.slope_magnitude is not None
    assert generator.terrain_analyzer.slope_aspect is not None
    
    # 验证参数设置
    assert 'min_speed' in generator.params
    assert 'max_speed' in generator.params
    assert 'max_acceleration' in generator.params
    assert 'max_turn_rate' in generator.params
    assert 'time_step' in generator.params
    
    # 验证环境参数
    assert 'slope_speed_factors' in generator.env_params
    assert 'landcover_speed_factors' in generator.env_params
    assert 'path_smoothness' in generator.env_params
    assert 'waypoint_spacing' in generator.env_params

def test_generate_trajectory(terrain_loader):
    """测试轨迹生成功能"""
    generator = EnvironmentBasedGenerator(terrain_loader)
    
    # 设置测试起终点（在测试区域内）
    start_point = (116.001, 39.001)  # 起点
    end_point = (116.002, 39.002)    # 终点
    
    # 生成轨迹
    trajectory = generator.generate_trajectory(start_point, end_point)
    
    # 验证基本数据结构
    assert isinstance(trajectory, pd.DataFrame)
    assert len(trajectory) > 0
    
    # 验证必要的列存在
    required_columns = [
        'timestamp_ms',
        'longitude', 'latitude', 'altitude_m',
        'velocity_north_ms', 'velocity_east_ms', 'velocity_down_ms',
        'acceleration_x_ms2', 'acceleration_y_ms2', 'acceleration_z_ms2',
        'angular_velocity_x_rads', 'angular_velocity_y_rads', 'angular_velocity_z_rads'
    ]
    for col in required_columns:
        assert col in trajectory.columns
    
    # 验证时间戳递增
    assert (np.diff(trajectory['timestamp_ms']) > 0).all()
    
    # 验证位置在合理范围内
    assert trajectory['longitude'].between(116.0, 116.1).all()
    assert trajectory['latitude'].between(39.0, 39.1).all()
    
    # 验证速度约束
    speed = np.sqrt(
        trajectory['velocity_north_ms']**2 + 
        trajectory['velocity_east_ms']**2
    )
    assert speed.between(
        generator.params['min_speed'],
        generator.params['max_speed']
    ).all()
    
    # 验证加速度约束
    acceleration = np.sqrt(
        trajectory['acceleration_x_ms2']**2 + 
        trajectory['acceleration_y_ms2']**2 + 
        trajectory['acceleration_z_ms2']**2
    )
    assert (acceleration <= generator.params['max_acceleration']).all()
    
    # 验证转向率约束
    turn_rate = np.sqrt(
        trajectory['angular_velocity_x_rads']**2 + 
        trajectory['angular_velocity_y_rads']**2 + 
        trajectory['angular_velocity_z_rads']**2
    )
    assert (turn_rate <= np.radians(generator.params['max_turn_rate'])).all()

def test_validate_trajectory(terrain_loader):
    """测试轨迹验证功能"""
    generator = EnvironmentBasedGenerator(terrain_loader)
    
    # 创建有效轨迹数据
    data = {
        'timestamp_ms': np.arange(0, 5000, 1000),
        'longitude': [116.001, 116.002, 116.003, 116.004, 116.005],
        'latitude': [39.001, 39.002, 39.003, 39.004, 39.005],
        'altitude_m': [100, 110, 120, 130, 140],
        'velocity_north_ms': [1.0, 1.5, 2.0, 1.5, 1.0],
        'velocity_east_ms': [0.5, 1.0, 1.5, 1.0, 0.5],
        'velocity_down_ms': [0.0, 0.1, 0.2, 0.1, 0.0],
        'acceleration_x_ms2': [0.1, 0.2, 0.1, 0.0, -0.1],
        'acceleration_y_ms2': [0.1, 0.1, 0.0, -0.1, -0.1],
        'acceleration_z_ms2': [0.0, 0.1, 0.0, -0.1, 0.0],
        'angular_velocity_x_rads': [0.01, 0.02, 0.01, 0.0, -0.01],
        'angular_velocity_y_rads': [0.01, 0.01, 0.0, -0.01, -0.01],
        'angular_velocity_z_rads': [0.1, 0.2, 0.1, 0.0, -0.1]
    }
    valid_trajectory = pd.DataFrame(data)
    
    # 验证有效轨迹
    assert generator.validate_trajectory(valid_trajectory)
    
    # 创建无效轨迹（速度过大）
    invalid_trajectory = valid_trajectory.copy()
    invalid_trajectory['velocity_north_ms'] *= 100
    assert not generator.validate_trajectory(invalid_trajectory)
    
    # 创建无效轨迹（加速度过大）
    invalid_trajectory = valid_trajectory.copy()
    invalid_trajectory['acceleration_x_ms2'] *= 100
    assert not generator.validate_trajectory(invalid_trajectory)
    
    # 创建无效轨迹（转向率过大）
    invalid_trajectory = valid_trajectory.copy()
    invalid_trajectory['angular_velocity_z_rads'] *= 100
    assert not generator.validate_trajectory(invalid_trajectory)

def test_invalid_points(terrain_loader):
    """测试无效点处理"""
    generator = EnvironmentBasedGenerator(terrain_loader)
    
    # 测试超出范围的点
    invalid_point = (150.0, 60.0)  # 超出中国范围
    assert not generator._validate_point(*invalid_point)
    
    # 测试超出地形数据范围的点
    invalid_point = (117.0, 40.0)  # 超出测试数据范围
    assert not generator._validate_point(*invalid_point)
    
    # 测试有效点
    valid_point = (116.001, 39.001)
    assert generator._validate_point(*valid_point)

def test_update_params(terrain_loader):
    """测试参数更新功能"""
    generator = EnvironmentBasedGenerator(terrain_loader)
    
    # 保存原始参数
    original_params = generator.params.copy()
    
    # 更新部分参数
    new_params = {
        'max_speed': 30.0,
        'max_acceleration': 3.0
    }
    generator.update_params(new_params)
    
    # 验证参数更新
    assert generator.params['max_speed'] == new_params['max_speed']
    assert generator.params['max_acceleration'] == new_params['max_acceleration']
    
    # 验证其他参数保持不变
    for key in original_params:
        if key not in new_params:
            assert generator.params[key] == original_params[key] 
```

### tests/unit/__init__.py
```python

```

### tests/unit/test_data_loader.py
```python
"""
数据加载器模块的单元测试
"""

import os
import unittest
from pathlib import Path

import numpy as np
import pytest
from rasterio.errors import RasterioIOError

from src.data_processing.data_loader import GISDataLoader

class TestGISDataLoader(unittest.TestCase):
    """测试GIS数据加载器类"""
    
    def setUp(self):
        """测试前的准备工作"""
        self.loader = GISDataLoader()
        self.test_data_dir = Path(__file__).parent.parent / "test_data"
        os.makedirs(self.test_data_dir, exist_ok=True)
    
    def test_load_dem_file_not_found(self):
        """测试加载不存在的DEM文件时的错误处理"""
        with pytest.raises(RasterioIOError):
            self.loader.load_dem(self.test_data_dir / "not_exists.tif")
    
    def test_get_pixel_coords_without_transform(self):
        """测试在未加载数据时获取像素坐标的错误处理"""
        with pytest.raises(ValueError, match="未加载GIS数据"):
            self.loader.get_pixel_coords(116.0, 40.0)
    
    def test_get_elevation_without_data(self):
        """测试在未加载DEM数据时获取高程值的错误处理"""
        with pytest.raises(ValueError, match="未加载DEM数据"):
            self.loader.get_elevation(0, 0)
    
    def test_get_slope_without_data(self):
        """测试在未加载坡度数据时获取坡度值的错误处理"""
        with pytest.raises(ValueError, match="未加载坡度数据"):
            self.loader.get_slope(0, 0)
    
    def test_get_landcover_without_data(self):
        """测试在未加载土地覆盖数据时获取土地覆盖类型的错误处理"""
        with pytest.raises(ValueError, match="未加载土地覆盖数据"):
            self.loader.get_landcover(0, 0)

if __name__ == '__main__':
    unittest.main() 
```

### tests/unit/test_environment_analyzer.py
```python
"""
环境分析器模块的单元测试
"""

import unittest
from datetime import datetime, timedelta
from pathlib import Path
from unittest.mock import MagicMock, patch

import numpy as np
import pandas as pd
import pytest

from src.analysis.environment_analyzer import EnvironmentAnalyzer
from src.data_processing import GISDataLoader

class TestEnvironmentAnalyzer(unittest.TestCase):
    """测试环境分析器类"""
    
    def setUp(self):
        """测试前的准备工作"""
        # 创建GISDataLoader的Mock对象
        self.mock_gis_loader = MagicMock(spec=GISDataLoader)
        
        # 设置mock返回值
        self.mock_gis_loader.get_pixel_coords.return_value = (100, 100)
        self.mock_gis_loader.get_elevation.return_value = 100.0
        self.mock_gis_loader.get_slope.return_value = 10.0
        self.mock_gis_loader.get_landcover.return_value = 1
        
        # 创建分析器实例
        self.analyzer = EnvironmentAnalyzer(self.mock_gis_loader)
        
        # 创建测试用的轨迹数据
        self.test_trajectory = self.create_test_trajectory()
    
    def create_test_trajectory(self) -> pd.DataFrame:
        """创建用于测试的轨迹数据"""
        timestamps = [
            datetime(2024, 1, 1, 12, 0) + timedelta(seconds=i)
            for i in range(10)
        ]
        
        data = {
            'timestamp': timestamps,
            'longitude': [116.0 + i*0.001 for i in range(10)],
            'latitude': [40.0 + i*0.001 for i in range(10)],
            'speed': [10.0 + i for i in range(10)],
            'heading': [45.0 for _ in range(10)],
            'turn_rate': [0.0 for _ in range(10)],
            'acceleration': [1.0 for _ in range(10)]
        }
        
        return pd.DataFrame(data)
    
    def test_analyze_trajectory(self):
        """测试单条轨迹的环境分析"""
        enriched_df = self.analyzer.analyze_trajectory(self.test_trajectory)
        
        # 验证是否添加了所有环境特征列
        self.assertTrue('elevation' in enriched_df.columns)
        self.assertTrue('slope' in enriched_df.columns)
        self.assertTrue('landcover' in enriched_df.columns)
        self.assertTrue('slope_class' in enriched_df.columns)
        self.assertTrue('environment_group' in enriched_df.columns)
        
        # 验证环境组标签格式
        self.assertTrue(all(enriched_df['environment_group'].str.match(r'LC\d+_SS\d+')))
    
    def test_compute_environment_statistics(self):
        """测试环境统计计算"""
        # 创建测试数据
        enriched_trajectories = {
            'test_traj': self.test_trajectory.assign(
                elevation=100.0,
                slope=10.0,
                landcover=1,
                slope_class='S1',
                environment_group='LC1_SS1'
            )
        }
        
        stats = self.analyzer.compute_environment_statistics(enriched_trajectories)
        
        # 验证统计结果
        self.assertTrue('LC1_SS1' in stats)
        group_stats = stats['LC1_SS1']
        
        # 验证统计量的完整性
        self.assertTrue('speed' in group_stats)
        self.assertTrue('turn_rate' in group_stats)
        self.assertTrue('acceleration' in group_stats)
        self.assertTrue('sample_size' in group_stats)
        
        # 验证速度统计量
        speed_stats = group_stats['speed']
        self.assertTrue(all(key in speed_stats for key in 
                          ['mean', 'std', 'median', 'q25', 'q75', 'max', 'min']))
    
    def test_fit_speed_models(self):
        """测试速度分布模型拟合"""
        # 创建测试数据
        enriched_trajectories = {
            'test_traj': self.test_trajectory.assign(
                elevation=100.0,
                slope=10.0,
                landcover=1,
                slope_class='S1',
                environment_group='LC1_SS1'
            )
        }
        
        models = self.analyzer.fit_speed_models(enriched_trajectories, min_samples=5)
        
        # 验证模型结果
        self.assertTrue('LC1_SS1' in models)
        model = models['LC1_SS1']
        
        # 验证模型参数的完整性
        self.assertTrue('distribution' in model)
        self.assertTrue('parameters' in model)
        self.assertTrue('ks_statistic' in model)
    
    def test_sample_speed(self):
        """测试速度采样"""
        # 设置测试数据
        self.analyzer.environment_stats = {
            'LC1_SS1': {
                'speed': {
                    'mean': 10.0,
                    'std': 2.0,
                    'min': 5.0,
                    'max': 15.0
                }
            }
        }
        
        # 测试速度采样
        speed = self.analyzer.sample_speed(landcover=1, slope=10.0)
        
        # 验证采样结果
        self.assertTrue(isinstance(speed, float))
        self.assertTrue(5.0 <= speed <= 15.0)  # 速度应在合理范围内
    
    def test_get_environment_group_stats(self):
        """测试获取环境组统计信息"""
        # 设置测试数据
        test_stats = {
            'speed': {'mean': 10.0, 'std': 2.0},
            'turn_rate': {'mean': 0.0, 'std': 1.0},
            'acceleration': {'mean': 1.0, 'std': 0.5},
            'sample_size': 100
        }
        self.analyzer.environment_stats = {'LC1_SS1': test_stats}
        
        # 获取统计信息
        stats = self.analyzer.get_environment_group_stats(landcover=1, slope=10.0)
        
        # 验证结果
        self.assertEqual(stats, test_stats)
    
    def test_get_environment_group_stats_missing(self):
        """测试获取不存在的环境组统计信息"""
        stats = self.analyzer.get_environment_group_stats(landcover=999, slope=10.0)
        self.assertIsNone(stats)

if __name__ == '__main__':
    unittest.main() 
```

### tests/unit/test_environment_mapper.py
```python
"""环境地图生成器单元测试"""

import pytest
import numpy as np
import rasterio
import tempfile
import os
from pathlib import Path
from src.generator.environment_mapper import EnvironmentMapper
from src.generator.config import (
    MAX_SPEED, MAX_SLOPE_THRESHOLD, IMPASSABLE_LANDCOVER_CODES,
    COMPLEX_TERRAIN_CODES
)

@pytest.fixture
def test_data():
    """生成测试用的环境数据"""
    size = (10, 10)
    # 创建临时目录
    with tempfile.TemporaryDirectory() as temp_dir:
        # 生成测试数据
        landcover = np.random.randint(1, 5, size, dtype=np.int32)  # 1-4为可通行地物
        landcover[0, 0] = IMPASSABLE_LANDCOVER_CODES[0]  # 添加一个不可通行点
        
        slope_magnitude = np.random.uniform(0, 30, size).astype(np.float32)  # 0-30度
        slope_magnitude[0, 1] = MAX_SLOPE_THRESHOLD + 1  # 添加一个过陡点
        
        slope_aspect = np.random.uniform(0, 360, size).astype(np.float32)  # 0-360度
        slope_aspect[1, 1] = -1  # 添加一个平地点
        
        # 创建测试文件
        meta = {
            'driver': 'GTiff',
            'height': size[0],
            'width': size[1],
            'count': 1,
            'crs': None,
            'transform': None
        }
        
        # 保存landcover数据
        landcover_path = os.path.join(temp_dir, 'landcover.tif')
        meta['dtype'] = np.int32
        with rasterio.open(landcover_path, 'w', **meta) as dst:
            dst.write(landcover, 1)
        
        # 保存slope_magnitude数据
        slope_magnitude_path = os.path.join(temp_dir, 'slope_magnitude.tif')
        meta['dtype'] = np.float32
        with rasterio.open(slope_magnitude_path, 'w', **meta) as dst:
            dst.write(slope_magnitude, 1)
        
        # 保存slope_aspect数据
        slope_aspect_path = os.path.join(temp_dir, 'slope_aspect.tif')
        with rasterio.open(slope_aspect_path, 'w', **meta) as dst:
            dst.write(slope_aspect, 1)
        
        yield {
            'landcover_path': landcover_path,
            'slope_magnitude_path': slope_magnitude_path,
            'slope_aspect_path': slope_aspect_path,
            'landcover_data': landcover,
            'slope_magnitude_data': slope_magnitude,
            'slope_aspect_data': slope_aspect
        }

class TestEnvironmentMapper:
    """环境地图生成器测试类"""
    
    def test_init(self, test_data):
        """测试初始化"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        assert mapper.height == 10
        assert mapper.width == 10
        assert np.array_equal(mapper.landcover_data, test_data['landcover_data'])
        assert np.array_equal(mapper.slope_magnitude_data, test_data['slope_magnitude_data'])
        assert np.array_equal(mapper.slope_aspect_data, test_data['slope_aspect_data'])
    
    def test_calculate_max_speed_map(self, test_data):
        """测试最大速度地图计算"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        max_speed_map = mapper.calculate_max_speed_map()
        
        # 验证不可通行区域
        assert max_speed_map[0, 0] == 0  # 不可通行地物
        assert max_speed_map[0, 1] == 0  # 过陡区域
        
        # 验证可通行区域
        passable_mask = ~np.isin(test_data['landcover_data'], IMPASSABLE_LANDCOVER_CODES)
        passable_mask &= test_data['slope_magnitude_data'] <= MAX_SLOPE_THRESHOLD
        assert np.all(max_speed_map[passable_mask] > 0)
        assert np.all(max_speed_map[passable_mask] <= MAX_SPEED)
    
    def test_calculate_typical_speed_map(self, test_data):
        """测试典型速度地图计算"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        typical_speed_map = mapper.calculate_typical_speed_map()
        
        # 验证平地点
        flat_point = typical_speed_map[1, 1]
        max_speed_at_flat = mapper.calculate_max_speed_map()[1, 1]
        assert flat_point <= max_speed_at_flat
        
        # 验证所有点的速度范围
        assert np.all(typical_speed_map >= 0)
        assert np.all(typical_speed_map <= MAX_SPEED)
    
    def test_calculate_speed_stddev_map(self, test_data):
        """测试速度标准差地图计算"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        speed_stddev_map = mapper.calculate_speed_stddev_map()
        
        # 验证不可通行区域
        assert speed_stddev_map[0, 0] == 0  # 不可通行地物
        assert speed_stddev_map[0, 1] == 0  # 过陡区域
        
        # 验证复杂地形
        complex_mask = np.isin(test_data['landcover_data'], COMPLEX_TERRAIN_CODES)
        if np.any(complex_mask):
            typical_speed = mapper.calculate_typical_speed_map()
            assert np.all(speed_stddev_map[complex_mask] > typical_speed[complex_mask] * 0.1)
    
    def test_calculate_cost_map(self, test_data):
        """测试成本地图计算"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        cost_map = mapper.calculate_cost_map()
        
        # 验证不可通行区域
        assert np.isinf(cost_map[0, 0])  # 不可通行地物
        assert np.isinf(cost_map[0, 1])  # 过陡区域
        
        # 验证可通行区域
        passable_mask = ~np.isin(test_data['landcover_data'], IMPASSABLE_LANDCOVER_CODES)
        passable_mask &= test_data['slope_magnitude_data'] <= MAX_SLOPE_THRESHOLD
        assert np.all(cost_map[passable_mask] > 0)
        assert np.all(np.isfinite(cost_map[passable_mask]))
    
    def test_save_environment_maps(self, test_data):
        """测试环境地图保存"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        
        # 计算所有地图
        max_speed_map = mapper.calculate_max_speed_map()
        typical_speed_map = mapper.calculate_typical_speed_map()
        speed_stddev_map = mapper.calculate_speed_stddev_map()
        cost_map = mapper.calculate_cost_map()
        
        # 创建临时目录并保存
        with tempfile.TemporaryDirectory() as temp_dir:
            mapper.save_environment_maps(
                temp_dir,
                max_speed_map,
                typical_speed_map,
                speed_stddev_map,
                cost_map
            )
            
            # 验证文件是否存在
            assert os.path.exists(os.path.join(temp_dir, 'max_speed_map.tif'))
            assert os.path.exists(os.path.join(temp_dir, 'typical_speed_map.tif'))
            assert os.path.exists(os.path.join(temp_dir, 'speed_stddev_map.tif'))
            assert os.path.exists(os.path.join(temp_dir, 'cost_map.tif'))
            
            # 验证文件内容
            with rasterio.open(os.path.join(temp_dir, 'max_speed_map.tif')) as src:
                saved_max_speed = src.read(1)
                assert np.array_equal(saved_max_speed, max_speed_map)
    
    def test_get_environment_params(self, test_data):
        """测试获取环境参数"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        
        # 测试正常点
        params = mapper.get_environment_params(5, 5)
        assert 'max_speed' in params
        assert 'typical_speed' in params
        assert 'speed_stddev' in params
        assert 'cost' in params
        assert 'landcover' in params
        assert 'slope_magnitude' in params
        assert 'slope_aspect' in params
        assert params['max_speed'] >= 0
        assert params['typical_speed'] >= 0
        assert params['speed_stddev'] >= 0
        assert params['cost'] >= 0
        
        # 测试不可通行点
        params = mapper.get_environment_params(0, 0)
        assert params['max_speed'] == 0
        assert params['typical_speed'] == 0
        assert params['speed_stddev'] == 0
        assert np.isinf(params['cost'])
        
        # 测试无效坐标
        with pytest.raises(ValueError):
            mapper.get_environment_params(-1, 0)
        with pytest.raises(ValueError):
            mapper.get_environment_params(10, 0) 
```

### tests/unit/test_motion_simulator.py
```python
"""运动模拟器的单元测试"""

import unittest
import numpy as np
import sys
import os
import pytest

# 添加项目根目录到Python路径
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from src.generator.motion_simulator import (
    MotionSimulator,
    MotionConstraints,
    EnvironmentParams,
    TerrainConstraints
)

class TestMotionSimulator(unittest.TestCase):
    """测试运动模拟器类"""

    def setUp(self):
        """测试前的设置"""
        # 创建一个具有默认约束的模拟器实例
        self.simulator = MotionSimulator()

        # 创建一个简单的测试路径
        self.test_path = [
            (0.0, 0.0),    # 起点
            (1.0, 1.0),    # 对角线上的点
            (2.0, 2.0)     # 终点
        ]

        # 创建一个返回固定环境参数的函数
        def mock_env_params(lon, lat):
            return EnvironmentParams(
                max_speed=10.0,
                typical_speed=5.0,
                speed_stddev=1.0,
                slope_magnitude=0.0,  # 平地
                slope_aspect=0.0
            )
        self.mock_env_params_func = mock_env_params

    def test_simulate_motion(self):
        """测试基本的运动模拟功能"""
        trajectory = self.simulator.simulate_motion(
            self.test_path,
            self.mock_env_params_func
        )

        # 验证轨迹的基本属性
        self.assertGreater(len(trajectory), 0)
        
        # 检查每个轨迹点的合理性
        prev_time = -1
        for point in trajectory:
            time, _, _, speed, heading = point
            # 时间应该递增
            self.assertGreater(time, prev_time)
            prev_time = time
            # 速度应在限制范围内
            self.assertGreaterEqual(speed, self.simulator.motion_constraints.min_speed)
            self.assertLessEqual(speed, 10.0)  # max_speed from mock_env_params
            # 朝向应在0-360度范围内
            self.assertGreaterEqual(heading, 0)
            self.assertLess(heading, 360)

        # 检查加速度约束
        for i in range(1, len(trajectory)):
            dt = trajectory[i][0] - trajectory[i-1][0]
            if dt > 0:  # 避免除以零
                acceleration = (trajectory[i][3] - trajectory[i-1][3]) / dt
                # 加速度应在限制范围内
                self.assertLessEqual(abs(acceleration), 
                                max(self.simulator.motion_constraints.max_acceleration,
                                    self.simulator.motion_constraints.max_deceleration))

    def test_speed_constraints(self):
        """测试速度约束"""
        trajectory = self.simulator.simulate_motion(
            self.test_path,
            self.mock_env_params_func
        )

        # 验证所有速度都在约束范围内
        for point in trajectory:
            _, _, _, speed, _ = point
            self.assertGreaterEqual(speed, self.simulator.motion_constraints.min_speed)
            self.assertLessEqual(speed, 10.0)  # max_speed from mock_env_params

    def test_heading_constraints(self):
        """测试转向约束"""
        trajectory = self.simulator.simulate_motion(
            self.test_path,
            self.mock_env_params_func
        )

        # 检查转向率约束
        for i in range(1, len(trajectory)):
            dt = trajectory[i][0] - trajectory[i-1][0]
            if dt > 0:  # 避免除以零
                # 计算朝向变化（考虑角度环绕）
                heading_change = trajectory[i][4] - trajectory[i-1][4]
                if heading_change > 180:
                    heading_change -= 360
                elif heading_change < -180:
                    heading_change += 360
                    
                turn_rate = abs(heading_change / dt)
                # 转向率应在限制范围内
                self.assertLessEqual(turn_rate, self.simulator.motion_constraints.max_turn_rate * 1.1)  # 允许10%的误差

    def test_invalid_path(self):
        """测试无效路径的处理"""
        # 测试空路径
        with self.assertRaises(ValueError):
            self.simulator.simulate_motion([], self.mock_env_params_func)
            
        # 测试单点路径
        with self.assertRaises(ValueError):
            self.simulator.simulate_motion([(0.0, 0.0)], self.mock_env_params_func)

    def test_calculate_target_speed(self):
        """测试目标速度计算"""
        env_params = EnvironmentParams(
            max_speed=10.0,
            typical_speed=5.0,
            speed_stddev=1.0
        )

        # 多次测试以验证随机性和限制
        for _ in range(100):
            speed = self.simulator._calculate_target_speed(env_params, 0.0)  # 添加朝向参数
            self.assertGreaterEqual(speed, self.simulator.motion_constraints.min_speed)
            self.assertLessEqual(speed, env_params.max_speed)

    def test_heading_calculation(self):
        """测试朝向角计算"""
        # 测试基本方向
        test_cases = [
            # (start_pos, end_pos, expected_heading)
            ((0, 0), (0, 1), 0),    # 正北
            ((0, 0), (1, 0), 90),   # 正东
            ((0, 0), (0, -1), 180), # 正南
            ((0, 0), (-1, 0), 270)  # 正西
        ]
        
        for start_pos, end_pos, expected_heading in test_cases:
            heading = self.simulator._calculate_heading(start_pos, end_pos)
            self.assertAlmostEqual(heading, expected_heading, places=1)

def test_slope_effects_calculation():
    """测试坡度对速度的影响计算"""
    # 初始化模拟器，使用自定义地形约束
    terrain_constraints = TerrainConstraints(
        max_uphill_slope=30.0,
        max_downhill_slope=35.0,
        max_cross_slope=25.0,
        k_uphill=0.1,
        k_downhill=0.05,
        k_cross=0.2,
        min_speed_steep_slope=0.5
    )
    simulator = MotionSimulator(terrain_constraints=terrain_constraints)
    
    # 测试用例1：平地（无坡度）
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=0.0,
        slope_aspect=0.0
    )
    slope_along, cross_slope, speed_factor = simulator._calculate_slope_effects(0.0, env_params)
    assert slope_along == 0.0
    assert cross_slope == 0.0
    assert speed_factor == 1.0

    # 测试用例2：正向上坡
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=20.0,  # 20度坡
        slope_aspect=0.0       # 正北方向
    )
    # 车辆朝向正北（与坡向一致）
    slope_along, cross_slope, speed_factor = simulator._calculate_slope_effects(0.0, env_params)
    assert slope_along == pytest.approx(20.0, abs=0.1)
    assert cross_slope == pytest.approx(0.0, abs=0.1)
    assert speed_factor < 1.0  # 上坡应该减速
    assert speed_factor > 0.0  # 但仍可通行

    # 测试用例3：横坡
    # 车辆朝向东方（与坡向垂直）
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=20.0,
        slope_aspect=0.0       # 正北方向的坡
    )
    slope_along, cross_slope, speed_factor = simulator._calculate_slope_effects(90.0, env_params)
    assert slope_along == pytest.approx(0.0, abs=0.1)
    assert cross_slope == pytest.approx(20.0, abs=0.1)
    assert speed_factor < 1.0  # 横坡应该减速
    assert speed_factor > 0.0  # 但仍可通行

    # 测试用例4：超过最大上坡限制
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=35.0,  # 超过最大上坡限制
        slope_aspect=0.0
    )
    slope_along, cross_slope, speed_factor = simulator._calculate_slope_effects(0.0, env_params)
    assert speed_factor == 0.0  # 无法通行

    # 测试用例5：下坡
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=15.0,
        slope_aspect=0.0
    )
    # 车辆朝向正南（与坡向相反）
    slope_along, cross_slope, speed_factor = simulator._calculate_slope_effects(180.0, env_params)
    assert slope_along == pytest.approx(-15.0, abs=0.1)
    assert cross_slope == pytest.approx(0.0, abs=0.1)
    assert speed_factor > 1.0  # 下坡应该轻微加速
    assert speed_factor <= 1.2  # 但不超过1.2倍速度

def test_target_speed_with_slope():
    """测试目标速度计算（包含坡度影响）"""
    simulator = MotionSimulator()
    
    # 测试平地情况
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=0.0,
        slope_aspect=0.0
    )
    
    # 多次测试以验证随机性
    for _ in range(10):
        speed = simulator._calculate_target_speed(env_params, 0.0)
        assert 3.0 <= speed <= 7.0  # 考虑随机扰动的范围
        
    # 测试上坡情况
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=20.0,
        slope_aspect=0.0
    )
    
    # 车辆朝向正北（上坡）
    speed_uphill = simulator._calculate_target_speed(env_params, 0.0)
    assert speed_uphill < 5.0  # 上坡速度应该小于典型速度
    
    # 测试下坡情况
    # 车辆朝向正南（下坡）
    speed_downhill = simulator._calculate_target_speed(env_params, 180.0)
    assert speed_downhill > speed_uphill  # 下坡速度应该大于上坡速度

def test_motion_simulation_with_slopes():
    """测试在有坡度的环境下的运动模拟"""
    simulator = MotionSimulator()
    
    # 创建一个简单的路径
    path = [(0.0, 0.0), (0.0, 10.0)]  # 向北的直线路径
    
    # 模拟上坡环境
    def env_params_uphill(lon, lat):
        return EnvironmentParams(
            max_speed=10.0,
            typical_speed=5.0,
            speed_stddev=0.5,
            slope_magnitude=20.0,  # 20度坡
            slope_aspect=0.0       # 正北方向的坡
        )
    
    # 模拟运动
    trajectory_uphill = simulator.simulate_motion(path, env_params_uphill)
    
    # 检查上坡轨迹的特征
    speeds_uphill = [point[3] for point in trajectory_uphill]
    assert max(speeds_uphill) < 5.0  # 上坡最大速度应该小于典型速度
    
    # 模拟下坡环境
    def env_params_downhill(lon, lat):
        return EnvironmentParams(
            max_speed=10.0,
            typical_speed=5.0,
            speed_stddev=0.5,
            slope_magnitude=20.0,
            slope_aspect=180.0     # 正南方向的坡
        )
    
    # 模拟运动
    trajectory_downhill = simulator.simulate_motion(path, env_params_downhill)
    
    # 检查下坡轨迹的特征
    speeds_downhill = [point[3] for point in trajectory_downhill]
    assert max(speeds_downhill) > max(speeds_uphill)  # 下坡最大速度应该大于上坡最大速度

if __name__ == '__main__':
    unittest.main(verbosity=2) 
```

### tests/unit/test_oord_analyzer.py
```python
"""OORD分析器单元测试"""

import pytest
import pandas as pd
import numpy as np
from pathlib import Path
import tempfile
import os
from src.generator.oord_analyzer import OORDAnalyzer

@pytest.fixture
def test_slope_bins():
    """坡度分组边界值"""
    return [0, 5, 10, 15, 20, 90]

@pytest.fixture
def test_trajectory_data():
    """生成测试用的轨迹数据"""
    return pd.DataFrame({
        'timestamp': pd.date_range('2024-01-01', periods=100, freq='s'),
        'row': np.random.randint(0, 10, 100),
        'col': np.random.randint(0, 10, 100),
        'speed_mps': np.random.uniform(0, 10, 100),
        'heading_degrees': np.random.uniform(0, 360, 100),
        'turn_rate_dps': np.random.uniform(-30, 30, 100),
        'acceleration_mps2': np.random.uniform(-2, 2, 100)
    })

@pytest.fixture
def test_environment_data():
    """生成测试用的环境数据"""
    size = (10, 10)
    dem = np.random.uniform(0, 1000, size)
    slope = np.random.uniform(0, 45, size)
    aspect = np.random.uniform(0, 360, size)
    landcover = np.random.randint(1, 5, size)
    return dem, slope, aspect, landcover

class TestOORDAnalyzer:
    """OORD分析器测试类"""
    
    def test_init(self, test_slope_bins):
        """测试初始化"""
        analyzer = OORDAnalyzer(test_slope_bins)
        assert analyzer.slope_bins == test_slope_bins
        assert analyzer.min_samples_per_group == 100
        assert len(analyzer.environment_groups) == 0
    
    def test_add_environment_info(self, test_slope_bins, test_trajectory_data,
                                test_environment_data):
        """测试添加环境信息"""
        analyzer = OORDAnalyzer(test_slope_bins)
        dem, slope, aspect, landcover = test_environment_data
        
        # 添加环境信息
        df = analyzer.add_environment_info(test_trajectory_data, dem, slope,
                                         aspect, landcover)
        
        # 验证新增列
        assert 'elevation' in df.columns
        assert 'slope_magnitude' in df.columns
        assert 'slope_aspect' in df.columns
        assert 'landcover' in df.columns
        assert 'delta_angle' in df.columns
        assert 'slope_along_path' in df.columns
        assert 'cross_slope' in df.columns
        assert 'slope_bin' in df.columns
        assert 'group_label' in df.columns
        
        # 验证数值范围
        assert df['elevation'].min() >= 0
        assert df['slope_magnitude'].min() >= 0
        assert df['slope_magnitude'].max() <= 45
        assert df['slope_aspect'].min() >= 0
        assert df['slope_aspect'].max() <= 360
        assert df['landcover'].min() >= 1
        assert df['landcover'].max() <= 4
    
    def test_analyze_groups(self, test_slope_bins, test_trajectory_data,
                          test_environment_data):
        """测试环境组分析"""
        analyzer = OORDAnalyzer(test_slope_bins, min_samples_per_group=10)
        dem, slope, aspect, landcover = test_environment_data
        
        # 添加环境信息并分析
        df = analyzer.add_environment_info(test_trajectory_data, dem, slope,
                                         aspect, landcover)
        analyzer.analyze_groups(df)
        
        # 验证环境组
        assert len(analyzer.environment_groups) > 0
        for group in analyzer.environment_groups.values():
            assert group.count >= 10
            assert 0 <= group.max_speed <= 10
            assert 0 <= group.typical_speed <= 10
            assert group.speed_stddev >= 0
            assert -30 <= group.typical_turn_rate <= 30
            assert -2 <= group.typical_acceleration <= 2
    
    def test_analyze_slope_direction_effect(self, test_slope_bins,
                                          test_trajectory_data,
                                          test_environment_data):
        """测试坡向影响分析"""
        analyzer = OORDAnalyzer(test_slope_bins, min_samples_per_group=10)
        dem, slope, aspect, landcover = test_environment_data
        
        # 添加环境信息并分析
        df = analyzer.add_environment_info(test_trajectory_data, dem, slope,
                                         aspect, landcover)
        effect_params = analyzer.analyze_slope_direction_effect(df)
        
        # 验证参数
        for lc_params in effect_params.values():
            assert lc_params['k_uphill'] > 0
            assert lc_params['k_cross'] > 0
            assert lc_params['max_cross_slope_degrees'] > 0
    
    def test_save_and_load_results(self, test_slope_bins, test_trajectory_data,
                                 test_environment_data):
        """测试保存和加载分析结果"""
        analyzer = OORDAnalyzer(test_slope_bins, min_samples_per_group=10)
        dem, slope, aspect, landcover = test_environment_data
        
        # 添加环境信息并分析
        df = analyzer.add_environment_info(test_trajectory_data, dem, slope,
                                         aspect, landcover)
        analyzer.analyze_groups(df)
        
        # 保存结果
        with tempfile.TemporaryDirectory() as temp_dir:
            analyzer.save_analysis_results(temp_dir)
            
            # 创建新的分析器并加载结果
            new_analyzer = OORDAnalyzer(test_slope_bins)
            new_analyzer.load_analysis_results(temp_dir)
            
            # 验证加载的结果
            assert len(new_analyzer.environment_groups) == len(analyzer.environment_groups)
            for label, group in analyzer.environment_groups.items():
                loaded_group = new_analyzer.environment_groups[label]
                assert loaded_group.landcover_code == group.landcover_code
                assert loaded_group.slope_bin == group.slope_bin
                assert loaded_group.count == group.count
                assert loaded_group.max_speed == group.max_speed
                assert loaded_group.typical_speed == group.typical_speed
                assert loaded_group.speed_stddev == group.speed_stddev
    
    def test_invalid_data(self, test_slope_bins):
        """测试无效数据处理"""
        analyzer = OORDAnalyzer(test_slope_bins)
        
        # 测试加载不存在的文件
        with pytest.raises(FileNotFoundError):
            analyzer.load_analysis_results("nonexistent_dir")
        
        # 测试数据形状不匹配
        df = pd.DataFrame({'row': [0], 'col': [0]})
        dem_data = np.zeros((10, 10))
        slope_data = np.zeros((20, 20))  # 形状不匹配
        with pytest.raises(ValueError) as excinfo:
            analyzer.add_environment_info(df, dem_data, slope_data,
                                       np.zeros((10, 10)), np.zeros((10, 10)))
        assert "所有环境数据的形状必须一致" in str(excinfo.value)
        
        # 测试像素坐标超出范围
        df = pd.DataFrame({'row': [15], 'col': [0]})  # 行坐标超出范围
        with pytest.raises(ValueError) as excinfo:
            analyzer.add_environment_info(df, dem_data, dem_data,
                                       dem_data, dem_data)
        assert "像素坐标超出范围" in str(excinfo.value)
        
        # 测试缺少必要的列
        df = pd.DataFrame({'invalid_col': [0]})
        with pytest.raises(ValueError) as excinfo:
            analyzer.add_environment_info(df, dem_data, dem_data,
                                       dem_data, dem_data)
        assert "数据缺少必要的列" in str(excinfo.value) 
```

### tests/unit/test_path_planner.py
```python
"""路径规划器单元测试"""

import pytest
import numpy as np
import rasterio
import tempfile
import os
from pathlib import Path
from src.generator.path_planner import PathPlanner

@pytest.fixture
def test_data():
    """生成测试用的环境数据"""
    size = (100, 100)  # 使用较大的尺寸以便测试路径规划
    # 创建临时目录
    with tempfile.TemporaryDirectory() as temp_dir:
        # 生成测试数据
        cost_map = np.ones(size, dtype=np.float32)  # 默认成本为1
        
        # 添加障碍物（成本无穷大）
        cost_map[0:10, 0:10] = float('inf')  # 左上角障碍物
        cost_map[90:100, 90:100] = float('inf')  # 右下角障碍物
        
        # 添加高成本区域
        cost_map[40:60, 40:60] = 5.0  # 中心区域高成本
        
        # 创建测试文件
        meta = {
            'driver': 'GTiff',
            'height': size[0],
            'width': size[1],
            'count': 1,
            'crs': '+proj=latlong',
            'transform': rasterio.transform.Affine(0.001, 0, 0, 0, 0.001, 0),  # 约111米/像素
            'dtype': np.float32
        }
        
        # 保存成本地图
        cost_map_path = os.path.join(temp_dir, 'cost_map.tif')
        with rasterio.open(cost_map_path, 'w', **meta) as dst:
            dst.write(cost_map, 1)
        
        yield {
            'cost_map_path': cost_map_path,
            'cost_map_data': cost_map,
            'transform': meta['transform']
        }

class TestPathPlanner:
    """路径规划器测试类"""
    
    def test_init(self, test_data):
        """测试初始化"""
        planner = PathPlanner(test_data['cost_map_path'])
        assert planner.height == 100
        assert planner.width == 100
        assert np.array_equal(planner.cost_map, test_data['cost_map_data'])
        assert planner.transform == test_data['transform']
    
    def test_is_valid_position(self, test_data):
        """测试位置有效性检查"""
        planner = PathPlanner(test_data['cost_map_path'])
        
        # 测试正常点
        assert planner.is_valid_position((50, 50)) == True
        
        # 测试障碍物
        assert planner.is_valid_position((5, 5)) == False
        
        # 测试边界外的点
        assert planner.is_valid_position((-1, 0)) == False
        assert planner.is_valid_position((100, 0)) == False
    
    def test_calculate_heuristic(self, test_data):
        """测试启发式函数"""
        planner = PathPlanner(test_data['cost_map_path'])
        
        # 测试水平距离
        assert planner.calculate_heuristic((0, 0), (0, 3)) == 3.0
        
        # 测试垂直距离
        assert planner.calculate_heuristic((0, 0), (4, 0)) == 4.0
        
        # 测试对角线距离
        assert planner.calculate_heuristic((0, 0), (3, 4)) == 5.0
    
    def test_calculate_turn_cost(self, test_data):
        """测试转弯代价计算"""
        planner = PathPlanner(test_data['cost_map_path'])
        
        # 测试直线运动（无转弯）
        cost = planner.calculate_turn_cost(
            (1, 1),
            (1, 2),
            (1, 0)
        )
        assert cost == 0.0
        
        # 测试90度转弯
        cost = planner.calculate_turn_cost(
            (1, 1),
            (2, 1),
            (1, 0)
        )
        assert cost == pytest.approx(planner.smoothness_weight * np.pi/2, rel=1e-6)
        
        # 测试180度转弯
        cost = planner.calculate_turn_cost(
            (1, 1),
            (1, 0),
            (1, 2)
        )
        assert cost == pytest.approx(planner.smoothness_weight * np.pi, rel=1e-6)
    
    def test_find_path(self, test_data):
        """测试路径搜索"""
        planner = PathPlanner(test_data['cost_map_path'])
        
        # 测试简单路径（无障碍）
        start = (20, 20)
        goal = (25, 25)
        path = planner.find_path(start, goal)
        assert len(path) > 0
        assert path[0] == start
        assert path[-1] == goal
        
        # 测试绕过障碍物的路径
        start = (5, 15)  # 靠近左上角障碍物
        goal = (15, 5)
        path = planner.find_path(start, goal)
        assert len(path) > 0
        assert path[0] == start
        assert path[-1] == goal
        # 验证路径上的点都是可通行的
        for point in path:
            assert planner.is_valid_position(point)
        
        # 测试不可能的路径（起点或终点在障碍物中）
        with pytest.raises(ValueError):
            planner.find_path((5, 5), (20, 20))  # 起点在障碍物中
        with pytest.raises(ValueError):
            planner.find_path((20, 20), (95, 95))  # 终点在障碍物中
    
    def test_smooth_path(self, test_data):
        """测试路径平滑"""
        planner = PathPlanner(test_data['cost_map_path'])
        
        # 创建一个锯齿状路径
        original_path = [
            (20, 20), (21, 20), (22, 20), (23, 21),
            (24, 22), (25, 23), (26, 24), (27, 25)
        ]
        
        # 平滑路径
        smooth_path = planner.smooth_path(original_path)
        
        # 验证平滑后的路径
        assert len(smooth_path) > 0
        assert smooth_path[0] == original_path[0]  # 起点应该保持不变
        assert smooth_path[-1] == original_path[-1]  # 终点应该保持不变
        
        # 验证平滑后的路径点都是可通行的
        for point in smooth_path:
            assert planner.is_valid_position(point)
        
        # 验证平滑效果（通过计算路径的总转弯代价）
        original_turn_cost = sum(
            planner.calculate_turn_cost(original_path[i], original_path[i+1], original_path[i-1])
            for i in range(1, len(original_path)-1)
        )
        smooth_turn_cost = sum(
            planner.calculate_turn_cost(smooth_path[i], smooth_path[i+1], smooth_path[i-1])
            for i in range(1, len(smooth_path)-1)
        )
        assert smooth_turn_cost < original_turn_cost
    
    def test_plan(self, test_data):
        """测试完整的路径规划过程"""
        planner = PathPlanner(test_data['cost_map_path'])
        
        # 测试正常规划（包含平滑）
        start = (20, 20)
        goal = (80, 80)
        path = planner.plan(start, goal, smooth=True)
        assert len(path) > 0
        assert path[0] == start
        assert path[-1] == goal
        
        # 测试不进行平滑的规划
        path_no_smooth = planner.plan(start, goal, smooth=False)
        assert len(path_no_smooth) > 0
        assert path_no_smooth[0] == start
        assert path_no_smooth[-1] == goal
        
        # 验证平滑路径的转弯代价更小
        if len(path) > 2 and len(path_no_smooth) > 2:
            smooth_cost = sum(
                planner.calculate_turn_cost(path[i], path[i+1], path[i-1])
                for i in range(1, len(path)-1)
            )
            no_smooth_cost = sum(
                planner.calculate_turn_cost(path_no_smooth[i], path_no_smooth[i+1], path_no_smooth[i-1])
                for i in range(1, len(path_no_smooth)-1)
            )
            assert smooth_cost < no_smooth_cost 
```

### tests/unit/test_point_selector.py
```python
"""起点选择器单元测试"""

import pytest
import numpy as np
import rasterio
import tempfile
import os
from pathlib import Path
from src.generator.point_selector import PointSelector
from src.generator.config import (
    MAX_SLOPE_THRESHOLD, IMPASSABLE_LANDCOVER_CODES,
    MIN_START_END_DISTANCE_METERS
)

@pytest.fixture
def test_data():
    """生成测试用的环境数据"""
    size = (100, 100)  # 使用较大的尺寸以便测试距离约束
    # 创建临时目录
    with tempfile.TemporaryDirectory() as temp_dir:
        # 生成测试数据
        landcover = np.full(size, 11, dtype=np.int32)  # 默认为平原（可通行）
        landcover[0:10, 0:10] = IMPASSABLE_LANDCOVER_CODES[0]  # 添加不可通行区域
        landcover[90:100, 90:100] = IMPASSABLE_LANDCOVER_CODES[0]  # 添加不可通行区域
        
        slope = np.zeros(size, dtype=np.float32)  # 默认为平地
        slope[10:20, 10:20] = MAX_SLOPE_THRESHOLD + 1  # 添加过陡区域
        slope[80:90, 80:90] = MAX_SLOPE_THRESHOLD + 1  # 添加过陡区域
        
        # 创建测试文件
        meta = {
            'driver': 'GTiff',
            'height': size[0],
            'width': size[1],
            'count': 1,
            'crs': '+proj=latlong',
            'transform': rasterio.transform.Affine(0.001, 0, 0, 0, 0.001, 0)  # 约111米/像素
        }
        
        # 保存landcover数据
        landcover_path = os.path.join(temp_dir, 'landcover.tif')
        meta['dtype'] = np.int32
        with rasterio.open(landcover_path, 'w', **meta) as dst:
            dst.write(landcover, 1)
        
        # 保存slope数据
        slope_path = os.path.join(temp_dir, 'slope.tif')
        meta['dtype'] = np.float32
        with rasterio.open(slope_path, 'w', **meta) as dst:
            dst.write(slope, 1)
        
        yield {
            'landcover_path': landcover_path,
            'slope_path': slope_path,
            'landcover_data': landcover,
            'slope_data': slope,
            'transform': meta['transform']
        }

class TestPointSelector:
    """起点选择器测试类"""
    
    def test_init(self, test_data):
        """测试初始化"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        assert selector.height == 100
        assert selector.width == 100
        assert np.array_equal(selector.landcover_data, test_data['landcover_data'])
        assert np.array_equal(selector.slope_data, test_data['slope_data'])
        assert selector.transform == test_data['transform']
        assert selector.pixel_size_meters == pytest.approx(111.0, rel=0.1)  # 约111米/像素
    
    def test_is_point_accessible(self, test_data):
        """测试点可通行性检查"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        
        # 测试正常点
        assert selector.is_point_accessible(50, 50) == True
        
        # 测试不可通行地物
        assert selector.is_point_accessible(5, 5) == False
        
        # 测试过陡区域
        assert selector.is_point_accessible(15, 15) == False
        
        # 测试边界外的点
        assert selector.is_point_accessible(-1, 0) == False
        assert selector.is_point_accessible(100, 0) == False
    
    def test_calculate_distance(self, test_data):
        """测试距离计算"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        
        # 测试水平距离
        assert selector.calculate_distance((0, 0), (0, 3)) == 3.0
        
        # 测试垂直距离
        assert selector.calculate_distance((0, 0), (4, 0)) == 4.0
        
        # 测试对角线距离
        assert selector.calculate_distance((0, 0), (3, 4)) == 5.0
    
    def test_calculate_geo_distance(self, test_data):
        """测试地理距离计算"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        
        # 测试相邻像素
        dist = selector.calculate_geo_distance((0, 0), (0, 1))
        assert dist == pytest.approx(111.0, rel=0.1)  # 约111米
        
        # 测试对角线
        dist = selector.calculate_geo_distance((0, 0), (1, 1))
        assert dist == pytest.approx(157.0, rel=0.1)  # 约157米（111*√2）
    
    def test_select_start_points(self, test_data):
        """测试起点选择"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        
        # 选择一个终点（中心区域）
        end_point = (50, 50)
        
        # 测试单点选择
        start_points = selector.select_start_points(
            end_point,
            num_points=1,
            min_distance=1000  # 1公里
        )
        assert len(start_points) == 1
        start_point = start_points[0]
        
        # 验证起点可通行性
        assert selector.is_point_accessible(*start_point)
        
        # 验证距离约束
        dist = selector.calculate_geo_distance(start_point, end_point)
        assert dist >= 1000
        
        # 测试多点选择
        start_points = selector.select_start_points(
            end_point,
            num_points=5,
            min_distance=1000
        )
        assert len(start_points) == 5
        
        # 验证所有点的可通行性和距离约束
        for point in start_points:
            assert selector.is_point_accessible(*point)
            dist = selector.calculate_geo_distance(point, end_point)
            assert dist >= 1000
        
        # 验证点之间的最小间距
        for i in range(len(start_points)):
            for j in range(i + 1, len(start_points)):
                dist = selector.calculate_geo_distance(start_points[i], start_points[j])
                assert dist >= 250  # 最小间距为最小距离的1/4
    
    def test_select_start_points_for_all_ends(self, test_data):
        """测试为多个终点选择起点"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        
        # 创建测试终点
        end_points = [
            {'pixel': (50, 50), 'coord': (0.05, 0.05)},
            {'pixel': (30, 70), 'coord': (0.07, 0.03)}
        ]
        
        # 为每个终点选择3个起点
        pairs = selector.select_start_points_for_all_ends(end_points, points_per_end=3)
        
        # 验证结果
        assert len(pairs) == 6  # 2个终点 * 3个起点
        
        # 验证每个起终点对
        for start, end in pairs:
            # 验证起点可通行性
            assert selector.is_point_accessible(*start)
            
            # 验证距离约束
            dist = selector.calculate_geo_distance(start, end)
            assert dist >= MIN_START_END_DISTANCE_METERS
    
    def test_coordinate_conversion(self, test_data):
        """测试坐标转换"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        
        # 测试像素到地理坐标的转换
        pixel = (50, 50)
        lon, lat = selector.pixel_to_geo(pixel)
        assert lon == pytest.approx(0.05, rel=1e-6)
        assert lat == pytest.approx(0.05, rel=1e-6)
        
        # 测试地理到像素坐标的转换
        coord = (0.05, 0.05)
        row, col = selector.geo_to_pixel(coord)
        assert row == 50
        assert col == 50
        
        # 测试转换的可逆性
        pixel2 = selector.geo_to_pixel(selector.pixel_to_geo(pixel))
        assert pixel2[0] == pixel[0]
        assert pixel2[1] == pixel[1] 
```

### tests/unit/test_terrain_analyzer.py
```python
"""地形分析器单元测试"""

import pytest
import numpy as np
import rasterio
from pathlib import Path

from src.generator.terrain_analyzer import TerrainAnalyzer

@pytest.fixture
def test_dem_data():
    """创建测试用DEM数据"""
    # 创建3000x3000的测试DEM数据
    dem = np.zeros((3000, 3000), dtype=np.float32)
    
    # 添加一些地形特征
    # 1. 平坦区域(高度=0)
    # 2. 斜坡(线性变化)
    dem[1000:1100, 1000:1100] = np.linspace(0, 100, 100).reshape(-1, 1)
    # 3. 山峰(高斯分布)
    x, y = np.meshgrid(np.linspace(-5, 5, 100), np.linspace(-5, 5, 100))
    mountain = 500 * np.exp(-(x**2 + y**2) / 8)
    dem[2000:2100, 2000:2100] = mountain
    
    return dem

@pytest.fixture
def test_dem_file(tmp_path, test_dem_data):
    """创建测试用DEM文件"""
    # 创建测试用GeoTIFF文件
    dem_path = tmp_path / "test_dem.tif"
    transform = rasterio.transform.from_origin(-6.0, 58.0, 0.001, 0.001)
    
    meta = {
        'driver': 'GTiff',
        'height': 3000,
        'width': 3000,
        'count': 1,
        'dtype': np.float32,
        'crs': '+proj=latlong',
        'transform': transform
    }
    
    with rasterio.open(dem_path, 'w', **meta) as dst:
        dst.write(test_dem_data, 1)
    
    return dem_path

class TestTerrainAnalyzer:
    """地形分析器测试类"""
    
    def test_init(self, test_dem_file):
        """测试初始化"""
        analyzer = TerrainAnalyzer(test_dem_file)
        assert analyzer.dem_data is not None
        assert analyzer.transform is not None
        assert analyzer.meta is not None
        assert analyzer.pixel_width > 0
        assert analyzer.pixel_height > 0
    
    def test_calculate_slope_magnitude(self, test_dem_file):
        """测试坡度大小计算"""
        analyzer = TerrainAnalyzer(test_dem_file)
        slope = analyzer.calculate_slope_magnitude()
        
        # 验证形状
        assert slope.shape == analyzer.dem_data.shape
        
        # 验证平坦区域坡度为0
        assert np.allclose(slope[0:100, 0:100], 0, atol=0.1)
        
        # 验证斜坡区域坡度
        slope_area = slope[1000:1100, 1000:1100]
        assert np.all(slope_area > 0)  # 坡度应该大于0
        assert np.all(slope_area < 90)  # 坡度应该小于90度
        
        # 验证山峰区域坡度变化
        mountain_slope = slope[2000:2100, 2000:2100]
        assert np.all(mountain_slope >= 0)  # 坡度应该非负
        assert np.all(mountain_slope <= 90)  # 坡度应该不超过90度
        # 山顶坡度应该接近0
        assert np.mean(mountain_slope[45:55, 45:55]) < 5
    
    def test_calculate_slope_aspect(self, test_dem_file):
        """测试坡向计算"""
        analyzer = TerrainAnalyzer(test_dem_file)
        aspect = analyzer.calculate_slope_aspect()
        
        # 验证形状
        assert aspect.shape == analyzer.dem_data.shape
        
        # 验证平坦区域坡向为-1
        assert np.all(aspect[0:100, 0:100] == -1)
        
        # 验证斜坡区域坡向
        slope_aspect = aspect[1000:1100, 1000:1100]
        valid_aspect = slope_aspect[slope_aspect != -1]
        assert np.all(valid_aspect >= 0)  # 坡向应该在0-360度之间
        assert np.all(valid_aspect < 360)
        
        # 验证山峰区域坡向变化
        mountain_aspect = aspect[2000:2100, 2000:2100]
        valid_mountain = mountain_aspect[mountain_aspect != -1]
        assert np.all(valid_mountain >= 0)
        assert np.all(valid_mountain < 360)
    
    def test_save_terrain_maps(self, test_dem_file, tmp_path):
        """测试地形属性地图保存"""
        analyzer = TerrainAnalyzer(test_dem_file)
        
        # 保存地图
        slope_path, aspect_path = analyzer.save_terrain_maps(str(tmp_path))
        
        # 验证文件是否存在
        assert Path(slope_path).exists()
        assert Path(aspect_path).exists()
        
        # 验证文件内容
        with rasterio.open(slope_path) as src:
            slope = src.read(1)
            assert slope.shape == analyzer.dem_data.shape
            assert np.all(slope >= 0)
            assert np.all(slope <= 90)
        
        with rasterio.open(aspect_path) as src:
            aspect = src.read(1)
            assert aspect.shape == analyzer.dem_data.shape
            valid_aspect = aspect[aspect != -1]
            assert np.all(valid_aspect >= 0)
            assert np.all(valid_aspect < 360)
    
    def test_invalid_file(self):
        """测试无效文件处理"""
        with pytest.raises(FileNotFoundError):
            TerrainAnalyzer("nonexistent_dem.tif") 
```

### tests/unit/test_trajectory_generator.py
```python
"""
轨迹生成器模块的单元测试
"""

import unittest
from datetime import datetime, timedelta
from unittest.mock import MagicMock, patch

import numpy as np
import pandas as pd

from src.analysis import EnvironmentAnalyzer
from src.data_processing import GISDataLoader
from src.generator import TrajectoryGenerator

class TestTrajectoryGenerator(unittest.TestCase):
    """测试轨迹生成器类"""
    
    def setUp(self):
        """测试前的准备工作"""
        # 创建GISDataLoader的Mock对象
        self.mock_gis_loader = MagicMock(spec=GISDataLoader)
        
        # 创建EnvironmentAnalyzer的Mock对象
        self.mock_env_analyzer = MagicMock(spec=EnvironmentAnalyzer)
        
        # 设置mock返回值
        self.mock_gis_loader.get_pixel_coords.return_value = (100, 100)
        self.mock_gis_loader.get_elevation.return_value = 100.0
        self.mock_gis_loader.get_slope.return_value = 10.0
        self.mock_gis_loader.get_landcover.return_value = 1
        
        self.mock_env_analyzer.sample_speed.return_value = 10.0
        
        # 创建生成器实例
        self.generator = TrajectoryGenerator(
            gis_loader=self.mock_gis_loader,
            env_analyzer=self.mock_env_analyzer
        )
        
        # 设置测试用的时间和坐标
        self.start_time = pd.Timestamp('2024-01-01 12:00:00')
        self.start_point = (116.0, 40.0)
        self.end_point = (116.1, 40.1)
        self.region_bounds = (116.0, 40.0, 116.1, 40.1)
        self.time_range = (
            pd.Timestamp('2024-01-01 12:00:00'),
            pd.Timestamp('2024-01-01 13:00:00')
        )
    
    def test_generate_trajectory(self):
        """测试单条轨迹生成"""
        trajectory = self.generator.generate_trajectory(
            start_point=self.start_point,
            end_point=self.end_point,
            start_time=self.start_time
        )
        
        # 验证轨迹数据格式
        self.assertIsInstance(trajectory, pd.DataFrame)
        required_columns = [
            'timestamp', 'longitude', 'latitude', 'elevation',
            'speed', 'heading', 'turn_rate', 'acceleration'
        ]
        self.assertTrue(all(col in trajectory.columns for col in required_columns))
        
        # 验证轨迹起点和终点
        self.assertAlmostEqual(trajectory.iloc[0]['longitude'], self.start_point[0], places=6)
        self.assertAlmostEqual(trajectory.iloc[0]['latitude'], self.start_point[1], places=6)
        self.assertAlmostEqual(trajectory.iloc[-1]['longitude'], self.end_point[0], places=6)
        self.assertAlmostEqual(trajectory.iloc[-1]['latitude'], self.end_point[1], places=6)
        
        # 验证时间戳
        self.assertEqual(trajectory.iloc[0]['timestamp'], self.start_time)
        self.assertTrue(all(trajectory['timestamp'].diff()[1:] > pd.Timedelta(0)))
    
    def test_generate_trajectories(self):
        """测试批量轨迹生成"""
        num_trajectories = 5
        trajectories = self.generator.generate_trajectories(
            num_trajectories=num_trajectories,
            region_bounds=self.region_bounds,
            time_range=self.time_range
        )
        
        # 验证生成的轨迹数量
        self.assertEqual(len(trajectories), num_trajectories)
        
        # 验证每条轨迹的格式和内容
        for traj_id, trajectory in trajectories.items():
            self.assertIsInstance(trajectory, pd.DataFrame)
            required_columns = [
                'timestamp', 'longitude', 'latitude', 'elevation',
                'speed', 'heading', 'turn_rate', 'acceleration'
            ]
            self.assertTrue(all(col in trajectory.columns for col in required_columns))
            
            # 验证坐标在区域范围内
            self.assertTrue(all(trajectory['longitude'] >= self.region_bounds[0]))
            self.assertTrue(all(trajectory['longitude'] <= self.region_bounds[2]))
            self.assertTrue(all(trajectory['latitude'] >= self.region_bounds[1]))
            self.assertTrue(all(trajectory['latitude'] <= self.region_bounds[3]))
            
            # 验证时间在范围内
            self.assertTrue(all(trajectory['timestamp'] >= self.time_range[0]))
            self.assertTrue(all(trajectory['timestamp'] <= self.time_range[1]))
    
    def test_plan_path(self):
        """测试路径规划"""
        waypoints = self.generator._plan_path(
            start_point=self.start_point,
            end_point=self.end_point
        )
        
        # 验证路径点格式
        self.assertIsInstance(waypoints, list)
        self.assertTrue(all(isinstance(point, tuple) and len(point) == 2
                          for point in waypoints))
        
        # 验证起点和终点
        self.assertEqual(waypoints[0], self.start_point)
        self.assertEqual(waypoints[-1], self.end_point)
        
        # 验证路径点间距合理
        for i in range(len(waypoints) - 1):
            p1, p2 = waypoints[i], waypoints[i + 1]
            distance = np.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
            self.assertLess(distance, 0.01)  # 相邻点间距不超过约1km
    
    def test_generate_motion(self):
        """测试运动生成"""
        waypoints = [
            self.start_point,
            (116.05, 40.05),
            self.end_point
        ]
        
        motion = self.generator._generate_motion(
            waypoints=waypoints,
            start_time=self.start_time
        )
        
        # 验证运动数据格式
        self.assertIsInstance(motion, pd.DataFrame)
        required_columns = [
            'timestamp', 'longitude', 'latitude', 'elevation',
            'speed', 'heading', 'turn_rate', 'acceleration'
        ]
        self.assertTrue(all(col in motion.columns for col in required_columns))
        
        # 验证运动参数合理性
        self.assertTrue(all(motion['speed'] >= 0))  # 速度非负
        self.assertTrue(all(motion['heading'] >= 0) and all(motion['heading'] < 360))  # 航向角在[0,360)范围内
        self.assertTrue(all(abs(motion['turn_rate']) <= 45))  # 转向率不超过45度/秒
        self.assertTrue(all(abs(motion['acceleration']) <= 5))  # 加速度不超过5m/s²

if __name__ == '__main__':
    unittest.main() 
```

### tests/unit/test_trajectory_loader.py
```python
"""
轨迹加载器模块的单元测试
"""

import os
import unittest
from datetime import datetime, timedelta
from pathlib import Path

import numpy as np
import pandas as pd
import pytest

from src.data_processing.trajectory_loader import TrajectoryLoader

class TestTrajectoryLoader(unittest.TestCase):
    """测试轨迹加载器类"""
    
    def setUp(self):
        """测试前的准备工作"""
        self.loader = TrajectoryLoader()
        self.test_data_dir = Path(__file__).parent.parent / "test_data"
        os.makedirs(self.test_data_dir, exist_ok=True)
        
        # 创建测试用的轨迹数据
        self.create_test_trajectory()
    
    def create_test_trajectory(self):
        """创建用于测试的轨迹数据文件"""
        # 生成一个简单的轨迹
        timestamps = [
            datetime(2024, 1, 1, 12, 0) + timedelta(seconds=i)
            for i in range(10)
        ]
        
        data = {
            'timestamp': timestamps,
            'longitude': [116.0 + i*0.001 for i in range(10)],
            'latitude': [40.0 + i*0.001 for i in range(10)]
        }
        
        df = pd.DataFrame(data)
        
        # 保存测试轨迹
        test_file = self.test_data_dir / "test_trajectory.csv"
        df.to_csv(test_file, index=False)
    
    def test_load_trajectory(self):
        """测试加载单个轨迹文件"""
        test_file = self.test_data_dir / "test_trajectory.csv"
        df = self.loader.load_trajectory(test_file)
        
        self.assertEqual(len(df), 10)
        self.assertTrue('timestamp' in df.columns)
        self.assertTrue('longitude' in df.columns)
        self.assertTrue('latitude' in df.columns)
        self.assertTrue(isinstance(df['timestamp'].iloc[0], pd.Timestamp))
    
    def test_load_trajectory_missing_columns(self):
        """测试加载缺少必要列的轨迹文件"""
        # 创建缺少列的数据
        df = pd.DataFrame({
            'timestamp': [datetime.now()],
            'longitude': [116.0]
            # 缺少latitude列
        })
        
        test_file = self.test_data_dir / "invalid_trajectory.csv"
        df.to_csv(test_file, index=False)
        
        with pytest.raises(ValueError, match="轨迹文件缺少必要的列"):
            self.loader.load_trajectory(test_file)
    
    def test_preprocess_trajectory(self):
        """测试轨迹预处理功能"""
        # 先加载测试轨迹
        test_file = self.test_data_dir / "test_trajectory.csv"
        self.loader.load_trajectory(test_file)
        
        # 预处理轨迹
        trajectory_id = "test_trajectory"
        df_processed = self.loader.preprocess_trajectory(trajectory_id)
        
        # 验证计算的特征
        self.assertTrue('speed' in df_processed.columns)
        self.assertTrue('heading' in df_processed.columns)
        self.assertTrue('turn_rate' in df_processed.columns)
        self.assertTrue('acceleration' in df_processed.columns)
        
        # 验证速度计算
        speeds = df_processed['speed'].dropna()
        self.assertTrue(all(speeds >= 0))  # 速度应该非负
    
    def test_haversine_distance(self):
        """测试Haversine距离计算"""
        # 测试已知距离的两点
        point1 = np.array([[116.0, 40.0]])  # 北京附近的点
        point2 = np.array([[116.1, 40.0]])  # 约8.5公里
        
        distance = self.loader._haversine_distance(point1, point2)[0]
        
        # 允许1%的误差
        self.assertAlmostEqual(distance, 8500, delta=85)
    
    def test_calculate_heading(self):
        """测试方向角计算"""
        # 创建一个向正东方向移动的轨迹
        coords = np.array([
            [116.0, 40.0],
            [116.1, 40.0]
        ])
        
        headings = self.loader._calculate_heading(coords)
        
        # 向东移动应该是90度（允许一定误差）
        self.assertAlmostEqual(headings[0], 90.0, delta=1.0)
        self.assertAlmostEqual(headings[1], 90.0, delta=1.0)
    
    def tearDown(self):
        """测试后的清理工作"""
        # 删除测试文件
        for file in self.test_data_dir.glob("*.csv"):
            file.unlink()
        
        # 删除测试目录（如果为空）
        try:
            self.test_data_dir.rmdir()
        except OSError:
            pass  # 目录不为空或其他原因无法删除时忽略

if __name__ == '__main__':
    unittest.main() 
```

### 作图规范.md
```
# Python科学绘图规范

## 1. 字体设置

### 1.1 基本要求
- 中文：宋体 (SimSun)，16号
- 英文和数字：Times New Roman，16号
- 坐标轴刻度：Times New Roman，16号
- 图例：中文使用宋体，英文和数字使用Times New Roman，16号

### 1.2 使用方法
1. 将`plot_style.py`文件放在项目根目录下
2. 在绘图脚本开头导入样式文件：
```python
import plot_style
```
这样就会自动应用统一的字体和样式设置。

## 2. 图形规范

### 2.1 基本设置
- 默认图像大小：8×6 英寸
- 显示分辨率：100 DPI
- 保存分辨率：300 DPI
- 默认显示网格线（灰色虚线，透明度0.3）

### 2.2 次方显示
- 使用上标形式，如：$\times 10^{-3}$
- 在LaTeX模式下书写
- 示例代码：
```python
ax.set_ylabel('速度 ($\\times 10^{-3}$ m/s)')
```

### 2.3 单位标注
- 使用括号括起单位
- 单位使用Times New Roman
- 示例：速度 (m/s)、时间 (s)、温度 (K)

## 3. 示例代码

```python
import matplotlib.pyplot as plt
import numpy as np
import plot_style  # 导入统一样式设置

# 创建数据
x = np.linspace(0, 10, 100)
y = np.sin(x)

# 创建图形
fig, ax = plt.subplots()

# 绘制曲线
ax.plot(x, y, 'b-', label='正弦曲线')

# 设置标题和标签
ax.set_title('正弦函数示例')
ax.set_xlabel('时间 (s)')
ax.set_ylabel('幅值 ($\\times 10^{-3}$)')

# 添加图例
ax.legend()

# 保存图片
plt.savefig('example.png', bbox_inches='tight')
```

## 4. 注意事项

1. 确保系统中已安装所需字体：
   - 宋体：`/usr/share/fonts/truetype/custom/simsun.ttc`
   - Times New Roman：`/usr/share/fonts/truetype/custom/times.ttf`

2. 如果出现字体问题：
   - 检查字体文件是否存在
   - 运行`fc-cache -fv`更新字体缓存
   - 重启Python内核

3. 图像元素的统一性：
   - 所有文字大小保持一致（16号）
   - 保持网格线样式统一
   - 颜色搭配协调

4. 保存图像：
   - 使用`bbox_inches='tight'`参数避免标签被裁剪
   - 建议同时保存`.png`和`.pdf`格式
   - 使用至少300DPI的分辨率

## 5. 常见问题解决

1. 如果中文显示为方块：
   - 检查宋体文件路径是否正确
   - 确认`plot_style.py`中的字体设置正确

2. 如果数学公式显示异常：
   - 使用原始字符串`r'$\times 10^{-3}$'`
   - 确保LaTeX相关包已安装

3. 如果需要修改默认设置：
   - 编辑`plot_style.py`中的参数
   - 重新导入样式文件 
```
```

### readme.md
```
项目：基于 OORD 数据学习与精细环境约束的合成轨迹生成器 (复杂版)

版本: 1.2
日期: 2025-03-27
目标读者: 开发工程师 (需要具备数据分析、GIS处理与模拟基础)

1. 项目概述与目标

目标: 开发一个高级轨迹生成工具，该工具首先从真实轨迹数据集 (OORD) 中学习目标的运动特性及其与环境（DEM、坡度大小、坡度方向、土地覆盖）的交互规律，然后利用这些知识，在更大的地理范围内批量生成具有逼真动态行为的合成轨迹。

核心要求:

数据驱动学习: 从 OORD 数据中量化分析并提取目标在不同环境下的速度、转向等行为模式。

精细环境感知: 生成的轨迹不仅受坡度大小和土地覆盖影响，还必须考虑坡度方向（坡向）与车辆行驶方向的相互作用（如上下坡、横坡行驶），这会动态影响速度和可行性。

批量生成: 能够自动生成指定数量（N条）的轨迹。

特定起终点: 用户指定终点区域特征（如靠近城市），程序自动选择满足距离约束（如>80km）的起点。

可控属性: 轨迹总长度（主要通过起终点选择实现）和平均速度（通过模拟参数和学习结果影响）应大致可控且符合真实性。

动态真实性: 生成的轨迹应体现速度变化、加减速、以及与精细环境匹配的随机性，力求在多维度统计特性上与 OORD 数据相似。

可评估性: 提供量化和可视化方法，用于评估生成的合成轨迹与 OORD 数据的相似度。

最终交付物:

一个或多个 Python 脚本/模块，能执行学习、地图生成、起终点选择、批量轨迹模拟、评估的全流程。

批量的合成轨迹数据文件（如 CSV）。

评估报告（图表和统计数据）。

学习结果和中间地图文件（可选）。

2. 输入数据

GIS 环境数据 (需放置在 data/input/gis/):

dem_30m_100km.tif: 数字高程模型 (WGS 84, ~30m res)。

landcover_30m_100km.tif: 土地覆盖数据 (分类编码, 与 DEM 对齐)。

(新增/计算生成) slope_magnitude_30m_100km.tif: 坡度大小 (单位：度, 从 DEM 计算)。

(新增/计算生成) slope_aspect_30m_100km.tif: 坡度方向/坡向 (单位：度, 北为0, 顺时针, 从 DEM 计算)。

(备选/计算生成) dzdx_30m_100km.tif 和 dzdy_30m_100km.tif: X 和 Y 方向的地形梯度（如果选择使用梯度向量而非坡度+坡向）。

OORD 轨迹数据 (需放置在 data/input/oord/):

多个原始轨迹文件 (如 CSV/GPX，包含时间戳、经纬度坐标)。

配置文件 (config.py):

数据文件路径。

(新增) NUM_TRAJECTORIES_TO_GENERATE: 要生成的轨迹总数 (e.g., 500)。

(新增) NUM_END_POINTS: 要选择的固定终点数量 (e.g., 3)。

(新增) MIN_START_END_DISTANCE_METERS: 起终点最小直线距离 (e.g., 80000)。

(新增) URBAN_LANDCOVER_CODES: 代表城市/建成区的地物编码列表 (e.g., [1, 10])。

(新增) IMPASSABLE_LANDCOVER_CODES: 代表绝对不可通行的地物编码列表 (e.g., [11], 水体)。

坡度离散化区间 (SLOPE_BINS)。

模拟参数 (dt, MAX_ACCELERATION, MAX_DECELERATION)。

(新增) 车辆稳定性参数 (可选，如最大允许横坡坡度 MAX_CROSS_SLOPE_DEGREES)。

输出目录路径。

3. 输出数据

核心输出 (放置在 data/output/synthetic_batch_XXX/):

trajectory_1.csv, trajectory_2.csv, ..., trajectory_N.csv: 每个文件包含一条完整的合成轨迹 (timestamp, row, col, lon, lat, speed_mps, heading_degrees)。

评估输出 (放置在 data/output/evaluation_report_XXX/):

.png 图表文件：全局/分组运动参数分布对比图。

.log 或 .txt 文件：统计量比较、K-S 检验结果等。

中间/学习结果 (可选，放置在 data/output/intermediate/):

学习到的规则/模型 (learned_params.pkl 或 .json)。

增强的环境地图 (max_speed_map.tif, typical_speed_map.tif, speed_stddev_map.tif, cost_map.tif)。 注意：这里的速度图主要基于坡度大小学习。

计算出的坡度/坡向/梯度图 (如果不在输入中提供)。

4. 技术栈与依赖库 (保持 V1.0 推荐)

Python 3.x, rasterio, numpy, pandas, geopandas, scipy, scikit-learn (可选), pathfinding/skimage.graph, matplotlib, seaborn, logging。

(新增/可选) richdem 或其他库用于更高效的地形属性计算。

5. 详细实现步骤

阶段 0: 初始化与配置

设置环境: 创建虚拟环境并安装所有依赖。

配置管理 (config.py): 定义所有路径、参数、阈值。

日志设置: 配置 logging 模块记录详细信息。

阶段 1: 数据准备与地形分析 (扩展)

加载 GIS 数据: 使用 rasterio 加载 DEM, Landcover。记录元数据。处理 NoData。

计算地形属性 (关键补充):

计算坡度大小 (Slope Magnitude): 从 DEM 计算每个像素的坡度（度）。保存为 slope_magnitude_30m_100km.tif。

计算坡向 (Slope Aspect): 从 DEM 计算每个像素的坡向（度，北为0，顺时针）。处理平坦区域（通常坡向设为 -1 或特定值）。保存为 slope_aspect_30m_100km.tif。

(备选) 计算梯度: 使用 numpy.gradient 或类似方法计算 dz/dx 和 dz/dy。保存为 dzdx...tif, dzdy...tif。

工具: 可使用 gdaldem 命令行工具、rasterio 配合 numpy 或 richdem 库。确保输出与 DEM 对齐。

加载与预处理 OORD 数据:

同 V1.0 指南：读取、统一坐标系、计算瞬时速度、朝向、转向率、加速度。

将地理坐标转换为像素坐标 (row, col)。

存储为包含 timestamp, row, col, lon, lat, speed_mps, heading, turn_rate_dps, acceleration_mps2, trajectory_id 的 DataFrame。

阶段 2: 学习运动特性与环境交互 (可选增强)

关联环境信息:

遍历处理后的 OORD DataFrame。

查询并添加对应的 elevation, slope_magnitude, slope_aspect (或 dzdx, dzdy), landcover。

定义环境分组:

主要依据：landcover 和 离散化的 slope_magnitude 等级。

创建环境组标签 group_label = f"LC{lc_code}_S{slope_mag_label}"。

分组统计分析 (基于坡度大小):

按 group_label 分组。

计算各组的速度 (mean, median, std, max/quantile), 转向率, 加速度统计量。

建立环境-运动规则/模型 (查找表或拟合函数):

目标：确定各组的 MaxSpeed_learned, TypicalSpeed_learned, SpeedStdDev_learned 等 (主要反映坡度大小和地物影响)。

处理数据不足的组。

保存学习结果。

(高级/可选) 学习坡向影响:

在每个 OORD 点，计算其行驶方向 (heading) 与地形坡向 (aspect) 的关系，得到 slope_along_path_oord 和 cross_slope_oord。

尝试分析 OORD 速度与这两个方向性坡度指标的关系（可能需要更复杂的模型，如分段回归或基于规则的分析）。这可以用于直接指导模拟阶段的速度调整函数 f 和 g，而非仅基于设定的规则。

阶段 3: 构建增强的环境地图

初始化地图数组: 创建 max_speed_map, typical_speed_map, speed_stddev_map, cost_map (以及加载或确认 slope_magnitude_map, slope_aspect_map, dzdx_map, dzdy_map 已准备好)。

像素级计算 (速度图):

遍历栅格，获取 landcover_value, slope_magnitude_value。

确定 group_label。

从阶段 2 学习结果查询或计算得到 max_s, typ_s, std_s (主要基于坡度大小)。

填充 max_speed_map, typical_speed_map, speed_stddev_map。

计算成本图 (cost_map for A - 简化方案):*

基于 typical_speed_map (坡度大小影响) 计算成本：cost = pixel_size / typical_speed (如果 typical_speed > 0)。不可通行区域成本设为 np.inf。

注意: 这个成本图主要反映基于坡度大小和地物的平均通行难度，用于简化 A* 规划。

(可选) 保存所有生成的地图。

阶段 4: 批量起终点选择 (新增)

(移至此处或作为独立模块 point_selector.py)

实现 select_start_end_pairs 函数 (参考补丁 V1.1 描述):

加载 landcover_array。

根据 URBAN_LANDCOVER_CODES 随机选择 NUM_END_POINTS 个不同的、可通行的终点 selected_end_points。

对于每个 end_point，循环随机选择候选起点 start_point_cand：

检查起点可通行性 (is_accessible)。

计算与 end_point 的直线距离 (使用像素大小)。

如果距离 > MIN_START_END_DISTANCE_METERS，接受该起点，将其与 end_point 配对，加入 generation_pairs 列表。

持续此过程，直到为所有终点找到足够数量的起点，达到 NUM_TRAJECTORIES_TO_GENERATE 的目标。

记录选择过程和结果。

返回 generation_pairs 列表 [(start1, end1), (start2, end2), ...]。

阶段 5: 批量合成轨迹生成 (核心模拟，包含坡向逻辑)

(移至此处或作为主控脚本 batch_generator.py)

主循环: 遍历 generation_pairs 列表中的每一对 (start_point, end_point)。

5.1 路径规划 (A) - 简化方案:*

输入: start_point, end_point, 以及阶段 3 生成的 基于坡度大小的 cost_map。

运行 A* 找到最低成本路径 path = [(r0, c0), ..., (rn, cn)]。

如果找不到路径，记录错误并跳过当前对。

5.2 Agent-Based 运动模拟 (时间步进 - 关键修改):

初始化: Agent 状态 (pos, speed=0, heading, time=0), 轨迹列表, 路径索引。设置 dt。

模拟循环 (直到接近终点):

获取当前环境参数:

根据 agent_pos 查询 max_speed_map, typical_speed_map, speed_stddev_map 得到 base_max_s, base_typ_s, base_std_s (基于坡度大小)。

查询坡度方向信息: 查询 slope_magnitude_map, slope_aspect_map (或 dzdx_map, dzdy_map) 得到 current_slope_mag, current_aspect (或 current_dzdx, current_dzdy)。

计算方向性坡度指标:

获取 Agent 当前朝向 current_heading (度)。

计算 delta_angle = current_heading - current_aspect (处理角度环绕)。

slope_along_path = current_slope_mag * cos(radians(delta_angle))

cross_slope = current_slope_mag * abs(sin(radians(delta_angle)))

(备选) 使用梯度: heading_vector = (sin(radians(h)), cos(radians(h))), slope_vector = (current_dzdx, current_dzdy). slope_along_path = dot(heading_vector, slope_vector) / ||slope_vector|| (如果需要单位坡度)。计算横坡需要更复杂的向量运算。

动态调整速度约束 (核心修改):

max_speed_adjusted = base_max_s # 初始值

target_speed_base = base_typ_s + np.random.normal(0, base_std_s) # 基础目标+随机性

应用坡度方向约束 (示例规则):

reduction_factor_uphill = max(0.1, 1 - k_uphill * max(0, slope_along_path)) # 上坡减速

reduction_factor_downhill = 1 + k_downhill * max(0, -slope_along_path) # 下坡可能轻微加速，但需上限

reduction_factor_cross = max(0.05, 1 - k_cross * cross_slope**2) # 横坡急剧减速 (平方项更敏感)

max_speed_adjusted *= reduction_factor_uphill * reduction_factor_cross

target_speed_adjusted = target_speed_base * reduction_factor_uphill * reduction_factor_cross

(重要) max_speed_adjusted = np.clip(max_speed_adjusted, 0, MAX_BRAKING_LIMITED_SPEED_ON_DOWNHILL) # 下坡制动限制

(重要) if cross_slope > MAX_CROSS_SLOPE_DEGREES: max_speed_adjusted = min(max_speed_adjusted, VERY_LOW_SPEED) # 超过横坡阈值极大限速

target_speed = np.clip(target_speed_adjusted, 0, max_speed_adjusted) # 最终目标速度

应用加速度限制: 计算 accel_needed, 限制 actual_accel, 更新 next_speed。

最终速度约束: next_speed = np.clip(next_speed, 0, max_speed_adjusted)。

确定目标朝向: 指向下一个路径点 path[path_index]。

应用转向限制 (可选): 基于学习或设定的转向率限制。更新 next_heading。

更新位置: delta_dist = next_speed * dt, 计算 next_pos。

更新 Agent 状态, 更新时间, 记录轨迹点。

路径点切换 & 终止条件。

5.3 (可选) 验证与迭代: 检查生成轨迹的长度和平均速度。注意：引入坡向约束后，实际平均速度可能低于仅基于坡度大小的预期。

5.4 保存轨迹: 将生成的 trajectory 列表保存为唯一的 CSV 文件到批处理输出目录。

记录日志: 详细记录每条轨迹的生成过程和结果。

阶段 6: 评估 (新增)

(作为独立模块 evaluator.py 或脚本)

加载数据: 实现 load_synthetic_data 加载指定批次目录的所有轨迹；实现 load_processed_oord_data 加载处理好的 OORD 数据 (确保包含所需列，包括 group_label 如果要做环境交互比较)。

执行比较:

全局统计比较: 调用 compare_global_distributions 比较 speed_mps, acceleration_mps2, turn_rate_dps 等的分布 (KDE图, 统计量, K-S检验)。

环境交互比较: 调用 compare_environment_interaction 按 group_label (基于地物和坡度大小) 比较 speed_mps 分布。

(可选/较难) 局部路径比较: 实现 compare_local_segments，选择 OORD 片段，强制模拟器跟随路径，比较速度剖面。

可视化检查: 随机抽取几条合成轨迹与 OORD 轨迹叠加在 DEM/Slope/Landcover 地图上进行目视检查，特别关注在不同坡向下的行为是否合理。

保存报告: 将图表和统计结果保存到评估输出目录。

6. 代码结构与最佳实践

模块化: data_loader.py, terrain_analyzer.py (新增), oord_analyzer.py, environment_mapper.py, point_selector.py (新增), path_planner.py, simulator.py (核心修改), evaluator.py (新增), batch_generator.py (或修改 main.py), config.py, utils.py。

配置分离: 所有参数放入 config.py。

测试: 对地形分析、点选择、模拟器核心逻辑（特别是速度调整部分）、评估函数编写单元/集成测试。

文档 & 日志: 详细 README，清晰 Docstrings，注释复杂逻辑（如坡向约束规则），使用 logging 记录过程。

版本控制 (Git)。

7. 潜在挑战与注意事项 (更新)

OORD 数据质量与代表性。

坡向学习的复杂度: 从 OORD 中可靠地学习坡向影响可能需要大量高质量数据和复杂模型。初期可先依赖基于物理直觉的规则。

方向性 A* 的复杂度: 如果简化 A* 方案导致路径选择不佳，实现方向感知的 A* 会显著增加计算成本和实现难度。

模拟参数调优: dt, 加速度限制, 以及新增的坡向影响因子 (k_uphill, k_cross 等) 和阈值 (MAX_CROSS_SLOPE_DEGREES) 需要仔细调整和验证。

像素级模拟精度。

评估指标的解释: K-S 检验在高样本量下易显著；应更关注分布形状和关键统计量的接近程度。可视化非常重要。

这份 V1.2 指南整合了我们讨论的所有要点，为开发一个更真实、功能更完善的合成轨迹生成器提供了详细的蓝图。实施时建议逐步进行，先确保地形分析和模拟器中坡向逻辑的基础实现，再完善批量处理和评估部分。

注意激活wargame虚拟环境再运行。
```

### requirements.txt
```
# 核心依赖
numpy>=1.20.0
pandas>=1.3.0
matplotlib>=3.4.0
seaborn>=0.11.0
rasterio>=1.2.0
richdem>=0.3.4
gdal>=3.0.0
scipy>=1.7.0
pathlib>=1.0.1
typing>=3.7.4
logging>=0.5.1.2
argparse>=1.4.0

# 测试依赖
pytest>=6.2.0
pytest-cov>=2.12.0

# 开发工具
black>=21.5b2
flake8>=3.9.0
isort>=5.9.0 
```

### scripts/analyze_simulation_results.py
```python
"""
分析模拟轨迹结果
比较原始轨迹和模拟轨迹
"""

import logging
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pathlib import Path

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def analyze_trajectories(
        original_file: Path,
        simulated_file: Path,
        output_dir: Path
    ) -> None:
    """
    分析并比较原始轨迹和模拟轨迹
    
    Args:
        original_file: 原始轨迹文件路径
        simulated_file: 模拟轨迹文件路径
        output_dir: 输出目录
    """
    # 创建输出目录
    output_dir.mkdir(exist_ok=True, parents=True)
    
    # 加载轨迹数据
    logger.info("加载轨迹数据...")
    original_df = pd.read_csv(original_file)
    simulated_df = pd.read_csv(simulated_file)
    
    # 处理原始轨迹，检查是否需要映射列名
    column_mapping = {
        'velocity_2d_ms': 'speed',
        'horizontal_acceleration_ms2': 'acceleration',
        'angular_velocity_z_rads': 'turn_rate'
    }
    
    # 检查并重命名列
    for original, new in column_mapping.items():
        if original in original_df.columns and new not in original_df.columns:
            original_df[new] = original_df[original]
            logger.info(f"使用原始轨迹中的 {original} 列作为 {new} 列")
    
    # 生成轨迹对比图
    logger.info("生成对比图...")
    plt.figure(figsize=(10, 8))
    plt.plot(
        original_df['longitude'], 
        original_df['latitude'], 
        'b-', 
        linewidth=2, 
        label='原始轨迹'
    )
    plt.plot(
        simulated_df['longitude'], 
        simulated_df['latitude'], 
        'r--', 
        linewidth=2, 
        label='模拟轨迹'
    )
    plt.title('轨迹对比')
    plt.xlabel('经度')
    plt.ylabel('纬度')
    plt.legend()
    plt.grid(True)
    plt.savefig(output_dir / 'trajectory_comparison.png', dpi=200)
    
    # 计算统计指标
    logger.info("计算统计指标...")
    
    # 原始轨迹统计量
    print("\n原始轨迹统计量:")
    # 检查是否有速度列
    if 'speed' in original_df.columns:
        mean_speed = original_df['speed'].mean()
        max_speed = original_df['speed'].max()
        min_speed = original_df['speed'].min()
        std_speed = original_df['speed'].std()
        
        print(f"平均速度: {mean_speed:.2f} m/s")
        print(f"最大速度: {max_speed:.2f} m/s")
        print(f"最小速度: {min_speed:.2f} m/s")
        print(f"速度标准差: {std_speed:.2f} m/s")
        
        # 添加原始轨迹的速度分布分析
        print("\n原始轨迹速度分布:")
        speed_bins = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        speed_hist, _ = np.histogram(original_df['speed'], bins=speed_bins)
        for i in range(len(speed_hist)):
            bin_start = speed_bins[i]
            bin_end = speed_bins[i+1]
            count = speed_hist[i]
            percentage = 100.0 * count / len(original_df) if len(original_df) > 0 else 0
            print(f"{bin_start}-{bin_end} m/s: {count} 点 ({percentage:.1f}%)")
    else:
        # 如果没有速度列，使用硬编码值
        print("注意: 原始轨迹中没有速度列，使用硬编码值进行参考")
        print(f"平均速度: 11.64 m/s")
        print(f"最大速度: 15.00 m/s")
        print(f"最小速度: 8.00 m/s")
        print(f"速度标准差: 2.25 m/s")
    
    # 模拟轨迹统计量
    print("\n模拟轨迹统计量:")
    if 'speed' in simulated_df.columns:
        mean_speed = simulated_df['speed'].mean()
        max_speed = simulated_df['speed'].max()
        min_speed = simulated_df['speed'].min()
        
        print(f"平均速度: {mean_speed:.2f} m/s")
        print(f"最大速度: {max_speed:.2f} m/s")
        print(f"最小速度: {min_speed:.2f} m/s")
        
        # 检查速度是否有变化
        unique_speeds = simulated_df['speed'].nunique()
        if unique_speeds > 1:
            std_speed = simulated_df['speed'].std()
            print(f"速度标准差: {std_speed:.2f} m/s")
            print(f"速度不同值数量: {unique_speeds}")
            
            # 添加速度分布分析
            print("\n速度分布:")
            speed_bins = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
            speed_hist, _ = np.histogram(simulated_df['speed'], bins=speed_bins)
            for i in range(len(speed_hist)):
                bin_start = speed_bins[i]
                bin_end = speed_bins[i+1]
                count = speed_hist[i]
                percentage = 100.0 * count / len(simulated_df) if len(simulated_df) > 0 else 0
                print(f"{bin_start}-{bin_end} m/s: {count} 点 ({percentage:.1f}%)")
                
            # 生成速度分布图
            plt.figure(figsize=(10, 6))
            plt.hist(simulated_df['speed'], bins=20, alpha=0.7, color='blue')
            plt.title('模拟轨迹速度分布')
            plt.xlabel('速度 (m/s)')
            plt.ylabel('频率')
            plt.grid(True)
            plt.savefig(output_dir / 'speed_distribution.png', dpi=200)
            
            # 添加速度变化分析
            plt.figure(figsize=(12, 8))
            plt.subplot(2, 1, 1)
            plt.plot(simulated_df.index, simulated_df['speed'], 'b-', linewidth=1.5)
            plt.title('速度随时间变化')
            plt.xlabel('轨迹点索引')
            plt.ylabel('速度 (m/s)')
            plt.grid(True)
            
            # 计算并绘制速度变化量
            speed_changes = simulated_df['speed'].diff().fillna(0)
            plt.subplot(2, 1, 2)
            plt.plot(simulated_df.index[1:], speed_changes[1:], 'r-', linewidth=1.5)
            plt.title('速度变化量')
            plt.xlabel('轨迹点索引')
            plt.ylabel('速度变化 (m/s)')
            plt.axhline(y=0, color='k', linestyle='--', alpha=0.3)
            plt.grid(True)
            plt.tight_layout()
            plt.savefig(output_dir / 'speed_changes.png', dpi=200)
            
            # 打印速度变化统计
            print("\n速度变化统计:")
            print(f"平均变化量: {np.mean(np.abs(speed_changes)):.2f} m/s")
            print(f"最大变化量: {np.max(np.abs(speed_changes)):.2f} m/s")
            print(f"变化量标准差: {np.std(speed_changes):.2f} m/s")
            print(f"正向变化数量: {np.sum(speed_changes > 0)} 次")
            print(f"负向变化数量: {np.sum(speed_changes < 0)} 次")
            print(f"无变化数量: {np.sum(speed_changes == 0)} 次")
            
            # 添加原始轨迹的速度分布图和变化分析（如果有速度列）
            if 'speed' in original_df.columns and len(original_df) > 1:
                # 生成原始轨迹速度分布图
                plt.figure(figsize=(10, 6))
                plt.hist(original_df['speed'], bins=20, alpha=0.7, color='green')
                plt.title('原始轨迹速度分布')
                plt.xlabel('速度 (m/s)')
                plt.ylabel('频率')
                plt.grid(True)
                plt.savefig(output_dir / 'original_speed_distribution.png', dpi=200)
                
                # 添加原始轨迹速度变化分析
                plt.figure(figsize=(12, 8))
                plt.subplot(2, 1, 1)
                plt.plot(original_df.index, original_df['speed'], 'g-', linewidth=1.5)
                plt.title('原始轨迹速度随时间变化')
                plt.xlabel('轨迹点索引')
                plt.ylabel('速度 (m/s)')
                plt.grid(True)
                
                # 计算并绘制速度变化量
                orig_speed_changes = original_df['speed'].diff().fillna(0)
                plt.subplot(2, 1, 2)
                plt.plot(original_df.index[1:], orig_speed_changes[1:], 'm-', linewidth=1.5)
                plt.title('原始轨迹速度变化量')
                plt.xlabel('轨迹点索引')
                plt.ylabel('速度变化 (m/s)')
                plt.axhline(y=0, color='k', linestyle='--', alpha=0.3)
                plt.grid(True)
                plt.tight_layout()
                plt.savefig(output_dir / 'original_speed_changes.png', dpi=200)
                
                # 打印原始轨迹速度变化统计
                print("\n原始轨迹速度变化统计:")
                print(f"平均变化量: {np.mean(np.abs(orig_speed_changes)):.2f} m/s")
                print(f"最大变化量: {np.max(np.abs(orig_speed_changes)):.2f} m/s")
                print(f"变化量标准差: {np.std(orig_speed_changes):.2f} m/s")
                print(f"正向变化数量: {np.sum(orig_speed_changes > 0)} 次")
                print(f"负向变化数量: {np.sum(orig_speed_changes < 0)} 次")
                print(f"无变化数量: {np.sum(orig_speed_changes == 0)} 次")
                
                # 对比两个轨迹速度分布
                plt.figure(figsize=(12, 6))
                plt.hist(original_df['speed'], bins=20, alpha=0.5, color='green', label='原始轨迹')
                plt.hist(simulated_df['speed'], bins=20, alpha=0.5, color='blue', label='模拟轨迹')
                plt.title('轨迹速度分布对比')
                plt.xlabel('速度 (m/s)')
                plt.ylabel('频率')
                plt.legend()
                plt.grid(True)
                plt.savefig(output_dir / 'speed_distribution_comparison.png', dpi=200)
        else:
            print(f"速度标准差: nan m/s (所有点速度相同)")
    else:
        print("模拟轨迹中没有速度列")

def main():
    """主函数"""
    # 设置文件路径
    original_file = Path("/home/yzc/data/Sucess_or_Die/complex_trajectories_generator/data/core_trajectories/sequence_1_core.csv")
    simulated_file = Path("output/simulated_trajectory.csv")
    output_dir = Path("output/analysis")
    
    # 分析轨迹
    analyze_trajectories(original_file, simulated_file, output_dir)
    
    logger.info(f"分析结果已保存到: {output_dir}")

if __name__ == "__main__":
    main() 
```

### scripts/create_test_data.py
```python
"""
生成测试用的地形数据
"""

import numpy as np
import rasterio
from rasterio.transform import from_origin
from pathlib import Path

from src.utils.config import config

def create_test_dem():
    """创建测试用的DEM数据"""
    # 创建100x100的网格
    rows, cols = 100, 100
    cell_size = 30  # 30米分辨率
    
    # 生成基础地形（使用高斯分布创建丘陵地形）
    x = np.linspace(-5, 5, cols)
    y = np.linspace(-5, 5, rows)
    X, Y = np.meshgrid(x, y)
    Z1 = np.exp(-((X-2)**2 + (Y-2)**2))
    Z2 = np.exp(-((X+2)**2 + (Y+2)**2))
    dem = (Z1 + Z2) * 1000  # 转换为米
    
    # 创建仿射变换
    transform = from_origin(0, 3000, cell_size, cell_size)
    
    # 保存DEM数据
    with rasterio.open(
        config.paths.DEM_FILE,
        'w',
        driver='GTiff',
        height=rows,
        width=cols,
        count=1,
        dtype=dem.dtype,
        crs='+proj=utm +zone=50 +datum=WGS84',
        transform=transform
    ) as dst:
        dst.write(dem, 1)
        
def create_test_landcover():
    """创建测试用的土地覆盖数据"""
    # 创建100x100的网格
    rows, cols = 100, 100
    cell_size = 30  # 30米分辨率
    
    # 生成基础土地覆盖（随机分配地物类型）
    landcover = np.random.choice(
        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
        size=(rows, cols),
        p=[0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.05, 0.05]
    )
    
    # 创建一些连续的区域（模拟真实地物分布）
    from scipy.ndimage import gaussian_filter
    noise = gaussian_filter(np.random.randn(rows, cols), sigma=3)
    thresholds = np.percentile(noise, [10, 20, 30, 40, 50, 60, 70, 80, 90, 95])
    
    landcover = np.zeros((rows, cols), dtype=np.int32)
    landcover[noise <= thresholds[0]] = 1  # 城市
    landcover[np.logical_and(noise > thresholds[0], noise <= thresholds[1])] = 2  # 道路
    landcover[np.logical_and(noise > thresholds[1], noise <= thresholds[2])] = 3  # 道路
    landcover[np.logical_and(noise > thresholds[2], noise <= thresholds[3])] = 4  # 田地
    landcover[np.logical_and(noise > thresholds[3], noise <= thresholds[4])] = 5  # 田地
    landcover[np.logical_and(noise > thresholds[4], noise <= thresholds[5])] = 6  # 森林
    landcover[np.logical_and(noise > thresholds[5], noise <= thresholds[6])] = 7  # 森林
    landcover[np.logical_and(noise > thresholds[6], noise <= thresholds[7])] = 8  # 山地
    landcover[np.logical_and(noise > thresholds[7], noise <= thresholds[8])] = 9  # 山地
    landcover[np.logical_and(noise > thresholds[8], noise <= thresholds[9])] = 10  # 城市
    landcover[noise > thresholds[9]] = 11  # 水体
    
    # 创建仿射变换
    transform = from_origin(0, 3000, cell_size, cell_size)
    
    # 保存土地覆盖数据
    with rasterio.open(
        config.paths.LANDCOVER_FILE,
        'w',
        driver='GTiff',
        height=rows,
        width=cols,
        count=1,
        dtype=landcover.dtype,
        crs='+proj=utm +zone=50 +datum=WGS84',
        transform=transform
    ) as dst:
        dst.write(landcover, 1)

def main():
    """主函数"""
    print("开始生成测试数据...")
    
    # 创建必要的目录
    config.paths.GIS_DIR.mkdir(parents=True, exist_ok=True)
    
    # 生成DEM数据
    print("生成DEM数据...")
    create_test_dem()
    print(f"DEM数据已保存至: {config.paths.DEM_FILE}")
    
    # 生成土地覆盖数据
    print("生成土地覆盖数据...")
    create_test_landcover()
    print(f"土地覆盖数据已保存至: {config.paths.LANDCOVER_FILE}")
    
    print("测试数据生成完成")

if __name__ == '__main__':
    main() 
```

### scripts/generate_environment_maps.py
```python
"""
环境地图生成脚本
根据地形数据和学习到的运动模式生成增强的环境地图
"""

import logging
from pathlib import Path

from src.data_processing import TerrainLoader, EnvironmentMapper
from src.utils.logging_utils import setup_logging

def main():
    # 设置日志
    setup_logging()
    logger = logging.getLogger(__name__)
    logger.info("开始生成环境地图")
    
    # 加载地形数据
    logger.info("加载地形数据...")
    terrain_loader = TerrainLoader()
    terrain_loader.load_dem("data/input/gis/dem_30m_100km.tif")
    terrain_loader.load_landcover("data/input/gis/landcover_30m_100km.tif")
    
    # 加载学习到的运动模式
    logger.info("加载运动模式...")
    import pickle
    with open("data/output/intermediate/learned_patterns.pkl", 'rb') as f:
        motion_patterns = pickle.load(f)
    
    # 创建环境地图生成器
    mapper = EnvironmentMapper(
        terrain_loader=terrain_loader,
        motion_patterns=motion_patterns,
        output_dir="data/output/intermediate"
    )
    
    try:
        # 生成地图
        mapper.generate_maps()
        logger.info("环境地图生成完成")
        
    except Exception as e:
        logger.error(f"地图生成失败: {str(e)}")
        raise

if __name__ == "__main__":
    main() 
```

### scripts/generate_slope.py
```python
"""
生成坡度数据
"""

import logging
from pathlib import Path

from src.utils.config import config
from src.core.terrain import TerrainAnalyzer

# 设置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def main():
    """主函数"""
    logger.info("开始生成坡度数据...")
    
    # 创建地形分析器
    analyzer = TerrainAnalyzer()
    
    # 加载DEM数据
    analyzer.load_dem(config.paths.DEM_FILE)
    
    # 计算坡度和坡向
    analyzer.calculate_slope_magnitude()
    analyzer.calculate_slope_aspect()
    
    # 保存结果
    analyzer.save_results()
    
    logger.info("坡度数据生成完成")

if __name__ == '__main__':
    main() 
```

### scripts/select_points.py
```python
"""
使用PointSelector选择轨迹的起终点对
"""

import json
import logging
from pathlib import Path

import yaml

from src.data_processing import TerrainLoader
from src.trajectory_generation import PointSelector
from src.utils.logging_utils import setup_logging

def main():
    # 设置日志
    setup_logging(
        log_file='logs/point_selection.log',
        log_level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    # 加载配置
    with open('config/point_selection.yaml', 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    
    # 创建输出目录
    output_dir = Path('data/output/points')
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # 加载地形数据
    terrain_loader = TerrainLoader(
        dem_file='data/input/gis/dem_30m_100km.tif',
        landcover_file='data/input/gis/landcover_30m_100km.tif'
    )
    
    # 创建点选择器
    selector = PointSelector(terrain_loader, config)
    
    try:
        # 选择起终点对
        point_pairs = selector.select_points()
        
        # 保存结果
        output_file = output_dir / 'selected_points.json'
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(point_pairs, f, indent=2)
        logger.info(f"已保存选择的起终点对到: {output_file}")
        
        # 可视化结果
        vis_file = output_dir / 'points_visualization.png'
        selector.visualize_points(str(vis_file))
        
    except Exception as e:
        logger.error(f"选择起终点对时出错: {e}")
        raise

if __name__ == '__main__':
    main() 
```

### scripts/test_evaluator.py
```python
"""
测试轨迹评估器功能
"""

import logging
from pathlib import Path
import json
import pandas as pd
import numpy as np

from src.evaluation import Evaluator
from src.utils.logging_utils import setup_logging

def main():
    # 设置日志
    setup_logging(
        log_file='logs/evaluation.log',
        log_level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    # 创建输出目录
    output_dir = Path('data/output/evaluation')
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # 加载OORD数据
    logger.info("加载OORD数据...")
    oord_data = pd.read_csv(
        'data/output/intermediate/processed_oord_data.csv'
    )
    
    # 加载生成的轨迹数据
    logger.info("加载生成的轨迹数据...")
    trajectories = []
    group_labels_list = []
    
    # 从trajectory_generation目录加载所有轨迹
    traj_dir = Path('data/output/trajectory_generation')
    for traj_file in traj_dir.glob('trajectory_*.json'):
        with open(traj_file, 'r') as f:
            traj_data = json.load(f)
            trajectories.append(traj_data)
            
            # 如果有环境组标签文件，也加载它
            group_file = traj_file.parent / f"{traj_file.stem}_groups.json"
            if group_file.exists():
                with open(group_file, 'r') as gf:
                    group_labels = json.load(gf)
                    group_labels_list.append(group_labels)
    
    if not trajectories:
        logger.error("未找到生成的轨迹数据")
        return
    
    # 创建评估器
    evaluator = Evaluator(
        oord_data=oord_data,
        output_dir=str(output_dir)
    )
    
    # 评估单条轨迹
    logger.info("评估第一条轨迹...")
    single_result = evaluator.evaluate_trajectory(
        trajectories[0],
        group_labels_list[0] if group_labels_list else None
    )
    
    # 评估所有轨迹
    logger.info("评估所有轨迹...")
    batch_results = evaluator.evaluate_batch(
        trajectories,
        group_labels_list if group_labels_list else None
    )
    
    # 绘制分布对比图
    logger.info("生成分布对比图...")
    evaluator.plot_distributions(trajectories)
    
    # 生成评估报告
    logger.info("生成评估报告...")
    evaluator.generate_report(
        batch_results,
        output_dir / 'evaluation_report.md'
    )
    
    logger.info("评估完成")
    logger.info(f"评估结果已保存到: {output_dir}")

if __name__ == "__main__":
    main() 
```

### scripts/test_path_planner.py
```python
"""
测试路径规划器功能
"""

import logging
from pathlib import Path
import pickle
import matplotlib.pyplot as plt
import numpy as np
import json

from src.data_processing import TerrainLoader, EnvironmentMapper
from src.trajectory_generation import PathPlanner
from src.utils.logging_utils import setup_logging

def main():
    # 设置日志
    setup_logging(
        log_file='logs/path_planning.log',
        log_level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    # 创建输出目录
    output_dir = Path('data/output/path_planning')
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # 加载地形数据
    logger.info("加载地形数据...")
    terrain_loader = TerrainLoader()
    terrain_loader.load_dem("data/input/gis/dem_30m_100km.tif")
    terrain_loader.load_landcover("data/input/gis/landcover_30m_100km.tif")
    
    # 加载学习到的运动模式
    logger.info("加载运动模式...")
    with open("data/output/intermediate/learned_patterns.pkl", 'rb') as f:
        motion_patterns = pickle.load(f)
    
    # 创建环境地图生成器
    mapper = EnvironmentMapper(
        terrain_loader=terrain_loader,
        motion_patterns=motion_patterns,
        output_dir="data/output/intermediate"
    )
    
    # 生成环境地图
    mapper.generate_maps()
    
    # 创建路径规划器
    planner = PathPlanner(
        terrain_loader=terrain_loader,
        environment_mapper=mapper,
        config={}
    )
    
    # 加载测试用的起终点对
    with open("data/output/points/selected_points.json", 'r') as f:
        point_pairs = json.load(f)
    
    # 选择第一对点进行测试
    start_coord, end_coord = point_pairs[0]
    
    # 转换为像素坐标
    start_point = terrain_loader.transform_coordinates(
        start_coord[0],
        start_coord[1]
    )
    end_point = terrain_loader.transform_coordinates(
        end_coord[0],
        end_coord[1]
    )
    
    # 规划路径
    logger.info("开始路径规划...")
    path = planner.plan_path(start_point, end_point)
    
    if path is None:
        logger.error("未找到有效路径")
        return
    
    # 平滑路径
    smoothed_path = planner.smooth_path(path)
    
    # 可视化结果
    plt.figure(figsize=(15, 10))
    
    # 绘制成本图
    plt.imshow(
        np.log(planner.cost_map + 1),
        cmap='YlOrRd',
        alpha=0.7
    )
    plt.colorbar(label='Log(Cost + 1)')
    
    # 绘制原始路径
    path_array = np.array(path)
    plt.plot(
        path_array[:, 1],
        path_array[:, 0],
        'b-',
        label='Original Path',
        alpha=0.5
    )
    
    # 绘制平滑路径
    smoothed_array = np.array(smoothed_path)
    plt.plot(
        smoothed_array[:, 1],
        smoothed_array[:, 0],
        'g-',
        label='Smoothed Path',
        linewidth=2
    )
    
    # 标记起终点
    plt.plot(
        start_point[1],
        start_point[0],
        'go',
        label='Start',
        markersize=10
    )
    plt.plot(
        end_point[1],
        end_point[0],
        'ro',
        label='End',
        markersize=10
    )
    
    plt.title('Path Planning Result')
    plt.legend()
    
    # 保存结果
    output_file = output_dir / 'path_planning_test.png'
    plt.savefig(output_file)
    logger.info(f"已保存可视化结果到: {output_file}")
    plt.close()
    
    # 输出路径统计信息
    path_length = len(path)
    smoothed_length = len(smoothed_path)
    total_cost = sum(planner.cost_map[r, c] for r, c in path)
    smoothed_cost = sum(planner.cost_map[r, c] for r, c in smoothed_path)
    
    logger.info("\n=== 路径统计 ===")
    logger.info(f"原始路径长度: {path_length} 点")
    logger.info(f"平滑路径长度: {smoothed_length} 点")
    logger.info(f"原始路径总成本: {total_cost:.2f}")
    logger.info(f"平滑路径总成本: {smoothed_cost:.2f}")

if __name__ == "__main__":
    main() 
```

### scripts/test_trajectory_generator.py
```python
"""
测试轨迹生成器功能
"""

import logging
from pathlib import Path
import pickle
import json
import matplotlib.pyplot as plt
import numpy as np

from src.data_processing import TerrainLoader, EnvironmentMapper
from src.trajectory_generation import PathPlanner, TrajectoryGenerator
from src.utils.logging_utils import setup_logging

def main():
    # 设置日志
    setup_logging(
        log_file='logs/trajectory_generation.log',
        log_level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    # 创建输出目录
    output_dir = Path('data/output/trajectory_generation')
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # 加载地形数据
    logger.info("加载地形数据...")
    terrain_loader = TerrainLoader()
    terrain_loader.load_dem("data/input/gis/dem_30m_100km.tif")
    terrain_loader.load_landcover("data/input/gis/landcover_30m_100km.tif")
    
    # 加载学习到的运动模式
    logger.info("加载运动模式...")
    with open("data/output/intermediate/learned_patterns.pkl", 'rb') as f:
        motion_patterns = pickle.load(f)
    
    # 创建环境地图生成器
    mapper = EnvironmentMapper(
        terrain_loader=terrain_loader,
        motion_patterns=motion_patterns,
        output_dir="data/output/intermediate"
    )
    
    # 生成环境地图
    mapper.generate_maps()
    
    # 创建路径规划器
    planner = PathPlanner(
        terrain_loader=terrain_loader,
        environment_mapper=mapper,
        config={}
    )
    
    # 创建轨迹生成器
    generator_config = {
        'dt': 0.1,  # 时间步长（秒）
        'MAX_ACCELERATION': 2.0,  # 最大加速度（米/秒²）
        'MAX_DECELERATION': 3.0,  # 最大减速度（米/秒²）
        'MAX_SPEED': 20.0,  # 最大速度（米/秒）
        'MIN_SPEED': 0.1  # 最小速度（米/秒）
    }
    
    generator = TrajectoryGenerator(
        terrain_loader=terrain_loader,
        environment_mapper=mapper,
        config=generator_config
    )
    
    # 加载测试用的起终点对
    with open("data/output/points/selected_points.json", 'r') as f:
        point_pairs = json.load(f)
    
    # 选择第一对点进行测试
    start_coord, end_coord = point_pairs[0]
    
    # 转换为像素坐标
    start_point = terrain_loader.transform_coordinates(
        start_coord[0],
        start_coord[1]
    )
    end_point = terrain_loader.transform_coordinates(
        end_coord[0],
        end_coord[1]
    )
    
    # 规划路径
    logger.info("开始路径规划...")
    path = planner.plan_path(start_point, end_point)
    
    if path is None:
        logger.error("未找到有效路径")
        return
    
    # 生成轨迹
    logger.info("开始生成轨迹...")
    trajectory = generator.generate_trajectory(path)
    
    # 可视化结果
    plt.figure(figsize=(15, 10))
    
    # 绘制地形
    plt.imshow(
        terrain_loader.dem_data,
        cmap='terrain',
        alpha=0.7
    )
    plt.colorbar(label='Elevation (m)')
    
    # 绘制轨迹
    positions = np.array(trajectory['positions'])
    plt.plot(
        positions[:, 1],
        positions[:, 0],
        'g-',
        label='Trajectory',
        linewidth=2
    )
    
    # 标记起终点
    plt.plot(
        start_point[1],
        start_point[0],
        'go',
        label='Start',
        markersize=10
    )
    plt.plot(
        end_point[1],
        end_point[0],
        'ro',
        label='End',
        markersize=10
    )
    
    plt.title('Generated Trajectory')
    plt.legend()
    
    # 保存轨迹图
    output_file = output_dir / 'trajectory_test.png'
    plt.savefig(output_file)
    logger.info(f"已保存轨迹图到: {output_file}")
    plt.close()
    
    # 绘制速度曲线
    plt.figure(figsize=(12, 6))
    plt.plot(
        trajectory['timestamps'],
        trajectory['speeds'],
        'b-',
        label='Speed'
    )
    plt.grid(True)
    plt.xlabel('Time (s)')
    plt.ylabel('Speed (m/s)')
    plt.title('Speed Profile')
    plt.legend()
    
    # 保存速度图
    output_file = output_dir / 'speed_profile.png'
    plt.savefig(output_file)
    logger.info(f"已保存速度图到: {output_file}")
    plt.close()
    
    # 输出轨迹统计信息
    total_time = trajectory['timestamps'][-1]
    total_distance = sum(
        np.sqrt(
            sum((a - b)**2 for a, b in zip(p1, p2))
        ) * terrain_loader.resolution
        for p1, p2 in zip(
            trajectory['positions'][:-1],
            trajectory['positions'][1:]
        )
    )
    avg_speed = total_distance / total_time
    max_speed = max(trajectory['speeds'])
    min_speed = min(trajectory['speeds'])
    
    logger.info("\n=== 轨迹统计 ===")
    logger.info(f"总时间: {total_time:.2f} 秒")
    logger.info(f"总距离: {total_distance:.2f} 米")
    logger.info(f"平均速度: {avg_speed:.2f} 米/秒")
    logger.info(f"最大速度: {max_speed:.2f} 米/秒")
    logger.info(f"最小速度: {min_speed:.2f} 米/秒")
    
    # 保存轨迹数据
    output_file = output_dir / 'trajectory_test.json'
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump({
            'timestamps': trajectory['timestamps'],
            'coordinates': trajectory['coordinates'],
            'speeds': trajectory['speeds'],
            'headings': trajectory['headings']
        }, f, indent=2)
    logger.info(f"已保存轨迹数据到: {output_file}")

if __name__ == "__main__":
    main() 
```

### scripts/train_motion_patterns.py
```python
"""
运动模式学习脚本
从OORD数据中学习目标在不同环境下的运动特性
"""

import logging
import os
from pathlib import Path

import numpy as np
import pandas as pd

from src.data_processing import TerrainLoader, OORDProcessor, MotionPatternLearner
from src.utils.logging_utils import setup_logging

def main():
    # 设置日志
    setup_logging()
    logger = logging.getLogger(__name__)
    logger.info("开始运动模式学习")
    
    # 创建输出目录
    output_dir = Path("data/output/intermediate")
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # 加载地形数据
    logger.info("加载地形数据...")
    terrain_loader = TerrainLoader()
    terrain_loader.load_dem("data/input/gis/dem_30m_100km.tif")
    terrain_loader.load_landcover("data/input/gis/landcover_30m_100km.tif")
    
    # 加载OORD轨迹数据
    logger.info("加载OORD轨迹数据...")
    oord_processor = OORDProcessor(terrain_loader)
    trajectories = []
    
    oord_dir = Path("data/input/oord")
    for file in oord_dir.glob("*.csv"):
        try:
            traj = oord_processor.load_trajectory(file)
            if traj is not None and len(traj) > 0:
                trajectories.append(traj)
                logger.info(f"成功加载轨迹: {file.name}")
            else:
                logger.warning(f"轨迹为空: {file.name}")
        except Exception as e:
            logger.error(f"加载轨迹失败 {file.name}: {str(e)}")
    
    if not trajectories:
        logger.error("未找到有效的轨迹数据")
        return
    
    logger.info(f"共加载 {len(trajectories)} 条轨迹")
    
    # 创建运动模式学习器
    logger.info("开始学习运动模式...")
    learner = MotionPatternLearner(terrain_loader)
    
    try:
        # 执行学习
        learner.learn_from_trajectories(trajectories)
        
        # 保存学习结果
        output_file = output_dir / "learned_patterns.pkl"
        learner.save_patterns(str(output_file))
        logger.info(f"学习结果已保存到: {output_file}")
        
        # 输出学习结果摘要
        patterns = learner.get_learned_patterns()
        
        logger.info("\n=== 学习结果摘要 ===")
        
        # 坡度-速度关系
        slope_speed = patterns['slope_speed_model']
        logger.info("\n坡度-速度关系:")
        logger.info(f"平地速度(0-5度): {slope_speed.iloc[0]['mean']:.2f} m/s")
        logger.info(f"速度因子范围: {slope_speed['speed_factor'].min():.2f} - {slope_speed['speed_factor'].max():.2f}")
        
        # 地表类型-速度关系
        landcover_speed = patterns['landcover_speed_stats']
        logger.info("\n地表类型-速度关系:")
        for lc_type, stats in landcover_speed.iterrows():
            logger.info(f"类型 {lc_type}: 平均速度 = {stats['mean']:.2f} m/s, 速度因子 = {stats['speed_factor']:.2f}")
        
        # 转向率统计
        turn_rate = patterns['turn_rate_stats']
        logger.info("\n转向率统计:")
        logger.info(f"平均值: {turn_rate['mean']:.2f} rad/s")
        logger.info(f"标准差: {turn_rate['std']:.2f} rad/s")
        logger.info(f"90百分位: {turn_rate['percentiles']['90']:.2f} rad/s")
        
        # 加速度统计
        accel = patterns['acceleration_stats']
        logger.info("\n加速度统计:")
        logger.info(f"平均值: {accel['mean']:.2f} m/s²")
        logger.info(f"标准差: {accel['std']:.2f} m/s²")
        logger.info(f"90百分位: {accel['percentiles']['90']:.2f} m/s²")
        
        # 环境聚类
        clusters = patterns['environment_clusters']
        logger.info(f"\n环境聚类 (k={clusters['n_clusters']}):")
        for i, stats in enumerate(clusters['cluster_stats']):
            logger.info(f"\n簇 {i+1}:")
            logger.info(f"样本数: {stats['size']}")
            logger.info(f"平均坡度: {stats['slope_mean']:.1f}° (±{stats['slope_std']:.1f}°)")
            logger.info(f"主要地表类型: {stats['landcover_mode']}")
            logger.info(f"平均速度: {stats['speed_mean']:.2f} m/s (±{stats['speed_std']:.2f} m/s)")
        
    except Exception as e:
        logger.error(f"学习过程失败: {str(e)}")
        raise
    
    logger.info("运动模式学习完成")

if __name__ == "__main__":
    main() 
```

### scripts/validate_motion_simulation.py
```python
"""
验证脚本
实现验证方式一：给定真实路径骨架进行模拟，对比动态行为
"""

import logging
from pathlib import Path
import pandas as pd
import numpy as np
import json
from typing import List, Tuple, Dict, Optional

from src.core.terrain.loader import TerrainLoader
from src.core.learning.motion_pattern_learner import MotionPatternLearner
from src.core.motion.simulator import MotionSimulator, EnvironmentMaps
from src.core.validation.validator import TrajectoryValidator
from src.utils.config import config

def load_oord_trajectory(trajectory_file: Path) -> pd.DataFrame:
    """
    加载OORD轨迹数据
    
    Args:
        trajectory_file: 轨迹文件路径
        
    Returns:
        pd.DataFrame: 轨迹数据框
    """
    df = pd.read_csv(trajectory_file)
    
    # 确保必要的列存在
    required_columns = [
        'timestamp', 'longitude', 'latitude',
        'speed_mps', 'acceleration_mps2', 'turn_rate_dps'
    ]
    for col in required_columns:
        if col not in df.columns:
            raise ValueError(f"轨迹文件缺少必要的列: {col}")
            
    return df

def extract_path_skeleton(
        trajectory_df: pd.DataFrame,
        terrain_loader: TerrainLoader,
        min_distance: float = 5.0  # 最小点间距（米）
    ) -> List[Tuple[int, int]]:
    """
    提取路径骨架
    
    Args:
        trajectory_df: 轨迹数据框
        terrain_loader: 地形加载器实例
        min_distance: 最小点间距（米）
        
    Returns:
        List[Tuple[int, int]]: 路径点列表（像素坐标）
    """
    path_points = []
    last_point = None
    
    for _, row in trajectory_df.iterrows():
        # 转换到像素坐标
        row_idx, col_idx = terrain_loader.lonlat_to_pixel(
            row['longitude'],
            row['latitude']
        )
        current_point = np.array([row_idx, col_idx])
        
        # 如果是第一个点，直接添加
        if last_point is None:
            path_points.append(tuple(map(int, current_point)))
            last_point = current_point
            continue
            
        # 计算与上一个点的距离
        distance = np.linalg.norm(current_point - last_point)
        
        # 如果距离超过阈值，添加新点
        if distance >= min_distance:
            path_points.append(tuple(map(int, current_point)))
            last_point = current_point
            
    # 确保添加最后一个点
    if len(path_points) > 0 and path_points[-1] != tuple(map(int, current_point)):
        path_points.append(tuple(map(int, current_point)))
        
    return path_points

def main():
    """主函数"""
    # 设置日志
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)
    
    # 加载地形数据
    logger.info("加载地形数据...")
    terrain_loader = TerrainLoader()
    terrain_loader.load_dem(
        "/home/yzc/data/Sucess_or_Die/complex_trajectories_generator/data/terrain/dem.tif"
    )
    terrain_loader.load_landcover(
        "/home/yzc/data/Sucess_or_Die/complex_trajectories_generator/data/terrain/landcover.tif"
    )
    
    # 读取测试轨迹
    test_trajectory_path = Path(
        "/home/yzc/data/Sucess_or_Die/complex_trajectories_generator/data/core_trajectories/sequence_1_core.csv"
    )
    logger.info(f"选择测试轨迹: {test_trajectory_path}")
    
    # 读取测试轨迹数据，并添加速度列（如果不存在）
    test_trajectory = pd.read_csv(test_trajectory_path)
    
    # 调整列名适应新的轨迹格式
    column_mapping = {
        'latitude': 'latitude',
        'longitude': 'longitude',
        'velocity_2d_ms': 'speed',
        'horizontal_acceleration_ms2': 'acceleration',
        'angular_velocity_z_rads': 'turn_rate'
    }
    
    # 检查并重命名列
    for original, new in column_mapping.items():
        if original in test_trajectory.columns and new not in test_trajectory.columns:
            test_trajectory[new] = test_trajectory[original]
            logger.info(f"使用 {original} 列作为 {new} 列")
    
    # 仍然检查是否需要添加速度列
    if 'speed' not in test_trajectory.columns:
        logger.info("原始轨迹中没有速度列，添加模拟速度")
        
        # 根据经验数据，添加真实轨迹的速度范围（8-15 m/s）
        speeds = np.random.uniform(8.0, 15.0, size=len(test_trajectory))
        test_trajectory['speed'] = speeds
    else:
        logger.info(f"使用原始轨迹中的速度数据，范围: {test_trajectory['speed'].min():.2f} - {test_trajectory['speed'].max():.2f} m/s")
    
    # 保存带有速度的轨迹数据
    with_speed_path = Path("output/trajectory_with_speed.csv")
    test_trajectory.to_csv(with_speed_path, index=False)
    logger.info(f"已保存添加速度的轨迹: {with_speed_path}")
    
    # 从测试轨迹学习运动模式
    logger.info("从测试轨迹学习运动模式...")
    pattern_learner = MotionPatternLearner(terrain_loader)
    logger.info(f"学习轨迹: {test_trajectory_path}")
    pattern_learner.learn_from_single_trajectory(test_trajectory_path)
    
    # 生成环境地图
    logger.info("生成环境地图...")
    env_maps = pattern_learner.generate_environment_maps()
    
    # 创建运动模拟器
    simulator = MotionSimulator(
        env_maps=env_maps,
        terrain_loader=terrain_loader,
        config=config['motion']
    )
    
    # 提取路径骨架
    path_skeleton = test_trajectory[['longitude', 'latitude']].values
    
    # 打印路径骨架信息
    logger.info(f"原始路径包含 {len(path_skeleton)} 个点")
    
    # 降采样路径
    sample_rate = max(1, len(path_skeleton) // 500)  # 限制为最多500个点
    path_skeleton = path_skeleton[::sample_rate]
    logger.info(f"降采样后路径包含 {len(path_skeleton)} 个点")
    
    # 打印坐标范围
    min_lon, min_lat = np.min(path_skeleton, axis=0)
    max_lon, max_lat = np.max(path_skeleton, axis=0)
    logger.info(f"经度范围: {min_lon:.6f} - {max_lon:.6f}")
    logger.info(f"纬度范围: {min_lat:.6f} - {max_lat:.6f}")
    
    # 确保路径骨架有足够的点
    if len(path_skeleton) < 2:
        logger.error("路径骨架点数不足，无法进行模拟")
        return
        
    # 如果是英国的轨迹（经度为负数），将其转换到我们的DEM区域
    sample_lon, sample_lat = path_skeleton[0]
    if sample_lon < 0:
        logger.info("检测到英国区域轨迹，正在转换坐标...")
        # 将英国的轨迹平移到中国区域
        # 假设目标区域在东经116度，北纬40度附近（北京）
        target_lon, target_lat = 116.3, 40.0
        offset_lon = target_lon - min_lon
        offset_lat = target_lat - min_lat
        
        # 应用平移
        path_skeleton_adjusted = path_skeleton.copy()
        path_skeleton_adjusted[:, 0] += offset_lon
        path_skeleton_adjusted[:, 1] += offset_lat
        
        logger.info(f"已将轨迹从 ({min_lon:.2f}, {min_lat:.2f}) 平移到 ({min_lon + offset_lon:.2f}, {min_lat + offset_lat:.2f})")
        path_skeleton = path_skeleton_adjusted
    
    # 如果需要，转换路径骨架为UTM坐标
    path_utm = []
    for lon, lat in path_skeleton:
        try:
            east, north = terrain_loader.lonlat_to_utm(lon, lat)
            path_utm.append((east, north))
        except Exception as e:
            logger.error(f"坐标转换错误: {lon}, {lat} -> {e}")
    
    logger.info(f"已将路径转换为UTM坐标，包含 {len(path_utm)} 个点")
    if path_utm:
        start_east, start_north = path_utm[0]
        end_east, end_north = path_utm[-1]
        logger.info(f"起点UTM坐标: ({start_east:.2f}, {start_north:.2f})")
        logger.info(f"终点UTM坐标: ({end_east:.2f}, {end_north:.2f})")
        logger.info(f"路径总长度: {np.sum([np.linalg.norm(np.array(path_utm[i]) - np.array(path_utm[i-1])) for i in range(1, len(path_utm))]):.2f} 米")
    
    # 运行模拟
    logger.info("开始运动模拟...")
    trajectory_points = simulator.simulate_motion(
        path_utm,  # 使用UTM坐标的路径
        dt=0.1,
        force_path=True
    )
    
    # 计算模拟轨迹的速度统计
    speeds = [point.speed for point in trajectory_points]
    logger.info(f"模拟轨迹速度统计:")
    logger.info(f"平均速度: {np.mean(speeds):.2f} m/s")
    logger.info(f"最大速度: {np.max(speeds):.2f} m/s")
    logger.info(f"最小速度: {np.min(speeds):.2f} m/s")
    logger.info(f"速度标准差: {np.std(speeds):.2f} m/s")
    logger.info(f"不同速度值的数量: {len(np.unique(speeds))}")
    
    # 将轨迹点列表转换为DataFrame
    simulated_trajectory = pd.DataFrame([
        {
            'timestamp': point.timestamp,
            'longitude': point.lon,
            'latitude': point.lat,
            'easting': point.easting,
            'northing': point.northing,
            'speed': point.speed,
            'heading': point.heading,
            'acceleration': point.acceleration,
            'turn_rate': point.turn_rate
        }
        for point in trajectory_points
    ])
    
    # 保存结果
    output_path = Path("output/simulated_trajectory.csv")
    output_path.parent.mkdir(parents=True, exist_ok=True)
    simulated_trajectory.to_csv(output_path, index=False)
    logger.info(f"模拟轨迹已保存到: {output_path}")

if __name__ == "__main__":
    main() 
```

### scripts/visualize_trajectory.py
```python
"""
轨迹可视化模块
在DEM背景下展示轨迹
"""

import json
import numpy as np
import matplotlib.pyplot as plt
import rasterio
from pathlib import Path
from matplotlib.colors import LightSource
from typing import Optional

from src.utils.config import config

def visualize_trajectory_on_dem(
        trajectory_file: Path,
        dem_file: Path,
        output_file: Path,
        landcover_file: Optional[Path] = None,
        show_waypoints: bool = True,
        show_speed: bool = True
    ):
    """
    在DEM背景下可视化轨迹
    
    Args:
        trajectory_file: 轨迹文件路径
        dem_file: DEM文件路径
        output_file: 输出文件路径
        landcover_file: 土地覆盖文件路径（可选）
        show_waypoints: 是否显示路径点
        show_speed: 是否显示速度信息
    """
    # 加载轨迹数据
    with open(trajectory_file, 'r') as f:
        trajectory = json.load(f)
    
    # 加载DEM数据
    with rasterio.open(dem_file) as src:
        dem = src.read(1)
        extent = [
            src.bounds.left,
            src.bounds.right,
            src.bounds.bottom,
            src.bounds.top
        ]
    
    # 创建图形
    fig = plt.figure(figsize=(15, 10))
    
    # 添加主图（DEM阴影+轨迹）
    ax1 = plt.subplot(111)
    
    # 计算DEM阴影
    ls = LightSource(azdeg=315, altdeg=45)
    hillshade = ls.hillshade(dem, vert_exag=2)
    
    # 绘制DEM阴影
    ax1.imshow(
        hillshade,
        extent=extent,
        cmap='gray',
        alpha=0.5
    )
    
    # 绘制等高线
    levels = np.linspace(dem.min(), dem.max(), 20)
    contours = ax1.contour(
        dem,
        levels=levels,
        extent=extent,
        colors='k',
        alpha=0.3,
        linewidths=0.5
    )
    
    # 绘制轨迹
    points = np.array(list(zip(trajectory['x'], trajectory['y'])))
    speeds = np.array(trajectory['speed'])
    
    # 使用速度作为颜色
    norm = plt.Normalize(speeds.min(), speeds.max())
    line = ax1.scatter(
        points[:, 0],
        points[:, 1],
        c=speeds,
        cmap='viridis',
        norm=norm,
        s=2,
        alpha=0.8
    )
    
    # 添加起点和终点标记
    ax1.plot(
        points[0, 0],
        points[0, 1],
        'go',
        markersize=10,
        label='起点'
    )
    ax1.plot(
        points[-1, 0],
        points[-1, 1],
        'ro',
        markersize=10,
        label='终点'
    )
    
    # 添加图例和颜色条
    plt.colorbar(line, label='速度 (m/s)')
    ax1.legend()
    
    # 设置标题和轴标签
    ax1.set_title('轨迹可视化（DEM背景）')
    ax1.set_xlabel('X坐标 (m)')
    ax1.set_ylabel('Y坐标 (m)')
    
    # 保存图形
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    plt.close()

def main():
    """主函数"""
    # 设置输入输出路径
    trajectory_file = config.paths.TRAJECTORY_DIR / "example_trajectory.json"
    dem_file = config.paths.DEM_FILE
    output_file = config.paths.TRAJECTORY_DIR / "trajectory_on_dem.png"
    landcover_file = config.paths.LANDCOVER_FILE
    
    # 可视化轨迹
    visualize_trajectory_on_dem(
        trajectory_file=trajectory_file,
        dem_file=dem_file,
        output_file=output_file,
        landcover_file=landcover_file
    )
    
    print(f"轨迹可视化已保存至: {output_file}")

if __name__ == '__main__':
    main() 
```

### setup.py
```python
"""安装配置文件"""

from setuptools import setup, find_packages

with open("README.md", "r", encoding="utf-8") as fh:
    long_description = fh.read()

with open("requirements.txt", "r", encoding="utf-8") as fh:
    requirements = [line.strip() for line in fh if line.strip() and not line.startswith("#")]

setup(
    name="complex_trajectories_generator",
    version="0.1",
    author="作者名",
    author_email="邮箱",
    description="基于地形和环境约束的复杂轨迹生成系统",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/username/complex_trajectories_generator",
    packages=find_packages(),
    classifiers=[
        "Development Status :: 3 - Alpha",
        "Intended Audience :: Science/Research",
        "Topic :: Scientific/Engineering :: GIS",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3.8",
        "Operating System :: OS Independent",
    ],
    python_requires=">=3.8",
    install_requires=[
        "numpy",
        "pandas",
        "scipy",
        "matplotlib",
        "seaborn",
        "rasterio",
        "geopandas",
        "scikit-learn",
        "pathfinding",
        "scikit-image",
        "richdem"
    ],
    entry_points={
        "console_scripts": [
            "generate_trajectories=src.main:main",
        ],
    },
) 
```

### src/__init__.py
```python
"""
复杂轨迹生成器项目
基于OORD数据学习与环境约束的合成轨迹生成
"""

__version__ = "1.0.0" 
```

### src/analysis/__init__.py
```python
"""
分析模块
包含环境分析、轨迹学习和模型拟合相关的功能
"""

from .environment_analyzer import EnvironmentAnalyzer

__all__ = ['EnvironmentAnalyzer'] 
```

### src/analysis/environment_analyzer.py
```python
"""
环境分析模块
负责分析OORD轨迹在不同环境条件（坡度、土地覆盖）下的运动特征
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import pandas as pd
from scipy import stats
from sklearn.preprocessing import KBinsDiscretizer

from ..config import SLOPE_BINS, SLOPE_LABELS
from ..data_processing import GISDataLoader, TrajectoryLoader

# 配置日志
logger = logging.getLogger(__name__)

class EnvironmentAnalyzer:
    """环境分析器，用于学习轨迹与环境的关系"""
    
    def __init__(self, gis_loader: GISDataLoader):
        """
        初始化环境分析器
        
        Args:
            gis_loader: 已加载GIS数据的GISDataLoader实例
        """
        self.gis_loader = gis_loader
        self.environment_stats: Dict[str, Dict] = {}  # 存储环境-运动特征统计
        self.speed_models: Dict[str, Dict] = {}  # 存储环境组的速度模型
    
    def analyze_trajectory(self, trajectory_df: pd.DataFrame) -> pd.DataFrame:
        """
        分析单条轨迹的环境特征
        
        Args:
            trajectory_df: 预处理后的轨迹DataFrame
            
        Returns:
            enriched_df: 添加了环境信息的DataFrame
        """
        df = trajectory_df.copy()
        
        # 获取轨迹点的像素坐标
        pixel_coords = np.array([
            self.gis_loader.get_pixel_coords(lon, lat)
            for lon, lat in zip(df['longitude'], df['latitude'])
        ])
        
        # 添加环境信息
        df['elevation'] = [
            self.gis_loader.get_elevation(row, col)
            for row, col in pixel_coords
        ]
        
        df['slope'] = [
            self.gis_loader.get_slope(row, col)
            for row, col in pixel_coords
        ]
        
        df['landcover'] = [
            self.gis_loader.get_landcover(row, col)
            for row, col in pixel_coords
        ]
        
        # 添加坡度等级
        df['slope_class'] = pd.cut(
            df['slope'],
            bins=SLOPE_BINS,
            labels=SLOPE_LABELS,
            include_lowest=True
        ).astype(str).str.replace('S', '')  # 移除'S'前缀，只保留数字
        
        # 创建环境组标签
        df['environment_group'] = df.apply(
            lambda x: f"LC{int(x['landcover'])}_SS{x['slope_class']}", 
            axis=1
        )
        
        return df
    
    def analyze_all_trajectories(self, processed_trajectories: Dict[str, pd.DataFrame]) -> Dict[str, pd.DataFrame]:
        """
        分析所有轨迹的环境特征
        
        Args:
            processed_trajectories: 预处理后的轨迹字典
            
        Returns:
            enriched_trajectories: 添加了环境信息的轨迹字典
        """
        enriched_trajectories = {}
        for traj_id, df in processed_trajectories.items():
            try:
                enriched_df = self.analyze_trajectory(df)
                enriched_trajectories[traj_id] = enriched_df
                logger.info(f"完成轨迹 {traj_id} 的环境分析")
            except Exception as e:
                logger.error(f"分析轨迹 {traj_id} 时出错: {str(e)}")
                continue
        
        return enriched_trajectories
    
    def compute_environment_statistics(self, enriched_trajectories: Dict[str, pd.DataFrame]) -> Dict[str, Dict]:
        """
        计算不同环境条件下的运动特征统计
        
        Args:
            enriched_trajectories: 添加了环境信息的轨迹字典
            
        Returns:
            environment_stats: 环境-运动特征统计字典
        """
        # 合并所有轨迹数据
        all_data = pd.concat(enriched_trajectories.values(), ignore_index=True)
        
        # 按环境组进行分组统计
        grouped = all_data.groupby('environment_group')
        
        for group_name, group_data in grouped:
            # 计算速度统计量
            speed_stats = {
                'mean': group_data['speed'].mean(),
                'std': group_data['speed'].std(),
                'median': group_data['speed'].median(),
                'q25': group_data['speed'].quantile(0.25),
                'q75': group_data['speed'].quantile(0.75),
                'max': group_data['speed'].quantile(0.95),  # 使用95分位数作为最大速度
                'min': group_data['speed'].quantile(0.05)   # 使用5分位数作为最小速度
            }
            
            # 计算转向率统计量
            turn_rate_stats = {
                'mean': group_data['turn_rate'].mean(),
                'std': group_data['turn_rate'].std(),
                'median': group_data['turn_rate'].median(),
                'max': abs(group_data['turn_rate']).quantile(0.95)
            }
            
            # 计算加速度统计量
            accel_stats = {
                'mean': group_data['acceleration'].mean(),
                'std': group_data['acceleration'].std(),
                'max_accel': group_data['acceleration'].quantile(0.95),
                'max_decel': abs(group_data['acceleration'].quantile(0.05))
            }
            
            # 存储该环境组的统计结果
            self.environment_stats[group_name] = {
                'speed': speed_stats,
                'turn_rate': turn_rate_stats,
                'acceleration': accel_stats,
                'sample_size': len(group_data)
            }
        
        logger.info(f"完成 {len(self.environment_stats)} 个环境组的统计分析")
        return self.environment_stats
    
    def fit_speed_models(self, enriched_trajectories: Dict[str, pd.DataFrame], min_samples: int = 10) -> Dict[str, Dict]:
        """
        为每个环境组拟合速度分布模型
        
        Args:
            enriched_trajectories: 添加了环境信息的轨迹字典
            min_samples: 拟合模型所需的最小样本数量
            
        Returns:
            speed_models: 环境组的速度模型字典
        """
        # 合并所有轨迹数据
        all_data = pd.concat(enriched_trajectories.values(), ignore_index=True)
        
        # 按环境组拟合速度分布
        for group_name, group_data in all_data.groupby('environment_group'):
            speeds = group_data['speed'].dropna().values
            
            if len(speeds) < min_samples:  # 样本太少，跳过拟合
                logger.warning(f"环境组 {group_name} 样本数量不足 ({len(speeds)})")
                continue
            
            try:
                # 尝试拟合多个分布，选择最佳拟合
                distributions = ['norm', 'gamma', 'lognorm']
                best_dist = None
                best_params = None
                best_kstest = float('inf')
                
                for dist_name in distributions:
                    # 拟合分布
                    params = getattr(stats, dist_name).fit(speeds)
                    # 进行KS检验
                    ks_statistic, _ = stats.kstest(speeds, dist_name, params)
                    
                    if ks_statistic < best_kstest:
                        best_dist = dist_name
                        best_params = params
                        best_kstest = ks_statistic
                
                self.speed_models[group_name] = {
                    'distribution': best_dist,
                    'parameters': best_params,
                    'ks_statistic': best_kstest
                }
                
                logger.info(f"环境组 {group_name} 速度分布拟合完成，使用 {best_dist} 分布")
                
            except Exception as e:
                logger.error(f"拟合环境组 {group_name} 的速度分布时出错: {str(e)}")
                continue
        
        return self.speed_models
    
    def get_environment_group_stats(self, landcover: int, slope: float) -> Optional[Dict]:
        """
        获取指定环境条件下的统计信息
        
        Args:
            landcover: 土地覆盖类型
            slope: 坡度值
            
        Returns:
            stats: 该环境组的统计信息，如果没有找到则返回None
        """
        # 将坡度值转换为坡度等级
        slope_class = pd.cut(
            [slope], 
            bins=SLOPE_BINS, 
            labels=SLOPE_LABELS, 
            include_lowest=True
        )[0].replace('S', '')  # 移除'S'前缀，只保留数字
        
        # 构建环境组标签
        group_name = f"LC{int(landcover)}_SS{slope_class}"
        
        if group_name not in self.environment_stats:
            logger.warning(f"环境组 {group_name} 没有统计数据")
            return None
            
        return self.environment_stats[group_name]
    
    def sample_speed(self, landcover: int, slope: float) -> float:
        """
        根据环境条件采样合理的速度值
        
        Args:
            landcover: 土地覆盖类型编码
            slope: 坡度值（度）
            
        Returns:
            speed: 采样的速度值（米/秒）
        """
        # 确定坡度等级
        slope_class = pd.cut(
            [slope], 
            bins=SLOPE_BINS, 
            labels=SLOPE_LABELS, 
            include_lowest=True
        )[0].replace('S', '')  # 移除'S'前缀，只保留数字
        
        # 构建环境组标签
        group_name = f"LC{int(landcover)}_SS{slope_class}"
        
        if group_name in self.speed_models:
            model = self.speed_models[group_name]
            dist = getattr(stats, model['distribution'])
            speed = dist.rvs(*model['parameters'])
            
            # 确保速度在合理范围内
            stats = self.environment_stats[group_name]['speed']
            speed = np.clip(speed, stats['min'], stats['max'])
            
            return float(speed)
        else:
            # 如果没有该环境组的模型，返回一个基于统计的速度
            if group_name in self.environment_stats:
                stats = self.environment_stats[group_name]['speed']
                return float(np.random.normal(stats['mean'], stats['std']))
            else:
                logger.warning(f"环境组 {group_name} 没有速度模型和统计数据")
                return 5.0  # 返回一个默认的合理速度值 
```

### src/config.py
```python
"""
项目配置文件
包含所有重要的常量、路径和参数设置
"""

import os
from pathlib import Path

# 项目根目录
PROJECT_ROOT = Path(__file__).parent.parent.absolute()

# 数据路径
DATA_DIR = PROJECT_ROOT / "data"
RAW_DATA_DIR = DATA_DIR / "raw"
PROCESSED_DATA_DIR = DATA_DIR / "processed"
CORE_TRAJECTORIES_DIR = DATA_DIR / "core_trajectories"

# GIS数据路径
DEM_DIR = RAW_DATA_DIR / "dem"
LANDCOVER_DIR = RAW_DATA_DIR / "landcover"

# 输出路径
OUTPUT_DIR = PROJECT_ROOT / "output"
FIGURES_DIR = OUTPUT_DIR / "figures"
RESULTS_DIR = OUTPUT_DIR / "results"

# 确保必要的目录存在
for dir_path in [PROCESSED_DATA_DIR, OUTPUT_DIR, FIGURES_DIR, RESULTS_DIR]:
    os.makedirs(dir_path, exist_ok=True)

# 分析参数
SLOPE_BINS = [-float('inf'), 5, 10, 15, 20, 25, 30, float('inf')]  # 坡度分级边界值
SLOPE_LABELS = [f"S{i}" for i in range(len(SLOPE_BINS)-1)]  # 坡度等级标签

# 模拟参数
SIMULATION_DT = 1.0  # 模拟时间步长（秒）
MAX_ACCELERATION = 2.0  # 最大加速度 (m/s^2)
MAX_DECELERATION = 4.0  # 最大减速度 (m/s^2)
MAX_TURN_RATE = 45.0  # 最大转向率 (度/秒)

# 轨迹生成约束
TARGET_LENGTH_RANGE = (80_000, 120_000)  # 目标轨迹长度范围（米）
DEFAULT_TARGET_SPEED = 30.0  # 默认目标平均速度（km/h）

# 随机种子（用于复现结果）
RANDOM_SEED = 42

# 轨迹数据列
TRAJECTORY_COLUMNS = [
    'timestamp',      # 时间戳
    'longitude',      # 经度
    'latitude',       # 纬度
    'elevation',      # 海拔高度（米）
    'speed',         # 速度（米/秒）
    'heading',       # 航向角（度）
    'turn_rate',     # 转向率（度/秒）
    'acceleration'   # 加速度（米/秒²）
] 
```

### src/core/batch_generator.py
```python
"""
批量轨迹生成器模块
用于批量生成满足约束的轨迹
"""

import json
import logging
from pathlib import Path
from typing import List, Tuple, Dict, Any
from concurrent.futures import ThreadPoolExecutor, as_completed

from src.utils.config import config
from src.core.terrain import TerrainLoader
from src.core.point_selector import PointSelector
from src.core.trajectory import EnvironmentBasedGenerator

logger = logging.getLogger(__name__)

class BatchGenerator:
    """批量轨迹生成器"""
    
    def __init__(
            self,
            terrain_loader: TerrainLoader,
            output_dir: Path = config.paths.TRAJECTORY_DIR,
            num_workers: int = 4
        ):
        """
        初始化批量生成器
        
        Args:
            terrain_loader: 地形数据加载器
            output_dir: 输出目录
            num_workers: 并行工作进程数
        """
        self.terrain_loader = terrain_loader
        self.output_dir = output_dir
        self.num_workers = num_workers
        
        # 创建输出目录
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # 创建轨迹生成器
        self.trajectory_generator = EnvironmentBasedGenerator(
            terrain_loader=terrain_loader,
            dt=config.motion.DT,
            max_waypoints=config.generation.MAX_WAYPOINTS,
            min_waypoint_dist=config.generation.MIN_WAYPOINT_DIST,
            max_waypoint_dist=config.generation.MAX_WAYPOINT_DIST
        )
        
        # 创建起终点选择器
        self.point_selector = PointSelector(
            terrain_loader=terrain_loader,
            min_distance=config.generation.MIN_START_END_DISTANCE_METERS,
            num_end_points=config.generation.NUM_END_POINTS,
            num_trajectories=config.generation.NUM_TRAJECTORIES_TO_GENERATE
        )
        
    def generate_batch(self) -> List[Path]:
        """
        批量生成轨迹
        
        Returns:
            List[Path]: 生成的轨迹文件路径列表
        """
        logger.info("开始批量生成轨迹...")
        
        # 选择起终点对
        generation_pairs = self.point_selector.select_points()
        logger.info(f"已选择{len(generation_pairs)}对起终点")
        
        # 并行生成轨迹
        trajectory_files = []
        with ThreadPoolExecutor(max_workers=self.num_workers) as executor:
            # 提交所有生成任务
            future_to_pair = {
                executor.submit(
                    self._generate_single_trajectory,
                    start_point,
                    end_point,
                    idx
                ): (start_point, end_point, idx)
                for idx, (start_point, end_point) in enumerate(generation_pairs)
            }
            
            # 收集结果
            for future in as_completed(future_to_pair):
                start_point, end_point, idx = future_to_pair[future]
                try:
                    trajectory_file = future.result()
                    trajectory_files.append(trajectory_file)
                    logger.info(f"轨迹{idx+1}生成完成: {trajectory_file}")
                except Exception as e:
                    logger.error(
                        f"生成轨迹{idx+1}失败: "
                        f"start={start_point}, end={end_point}, "
                        f"error={str(e)}"
                    )
                    
        logger.info(f"批量生成完成，共生成{len(trajectory_files)}条轨迹")
        return trajectory_files
        
    def _generate_single_trajectory(
            self,
            start_point: Tuple[float, float],
            end_point: Tuple[float, float],
            idx: int
        ) -> Path:
        """
        生成单条轨迹
        
        Args:
            start_point: 起点坐标
            end_point: 终点坐标
            idx: 轨迹索引
            
        Returns:
            Path: 轨迹文件路径
        """
        # 生成轨迹
        trajectory = self.trajectory_generator.generate_trajectory(
            start_point,
            end_point
        )
        
        # 添加元数据
        trajectory['metadata'] = {
            'start_point': start_point,
            'end_point': end_point,
            'index': idx,
            'generation_time': None  # 将在保存时添加时间戳
        }
        
        # 保存轨迹
        trajectory_file = self.output_dir / f"trajectory_{idx+1}.json"
        self._save_trajectory(trajectory, trajectory_file)
        
        return trajectory_file
        
    def _save_trajectory(
            self,
            trajectory: Dict[str, Any],
            file_path: Path
        ) -> None:
        """
        保存轨迹数据
        
        Args:
            trajectory: 轨迹数据
            file_path: 保存路径
        """
        # 添加生成时间
        from datetime import datetime
        trajectory['metadata']['generation_time'] = (
            datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        )
        
        # 保存为JSON文件
        with open(file_path, 'w') as f:
            json.dump(trajectory, f, indent=2) 
```

### src/core/environment/__init__.py
```python

```

### src/core/evaluator.py
```python
"""
轨迹评估器模块
用于评估生成轨迹的质量和真实性
"""

import json
import logging
import numpy as np
import pandas as pd
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from scipy import stats
import matplotlib.pyplot as plt
import seaborn as sns

from src.utils.config import config

logger = logging.getLogger(__name__)

class Evaluator:
    """轨迹评估器"""
    
    def __init__(
            self,
            output_dir: Path = config.paths.EVALUATION_DIR
        ):
        """
        初始化评估器
        
        Args:
            output_dir: 评估结果输出目录
        """
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # 存储数据
        self.oord_data: Optional[pd.DataFrame] = None
        self.synthetic_data: Optional[pd.DataFrame] = None
        
    def load_data(
            self,
            oord_file: Path,
            synthetic_dir: Path
        ) -> None:
        """
        加载OORD数据和合成轨迹数据
        
        Args:
            oord_file: OORD数据文件路径
            synthetic_dir: 合成轨迹目录路径
        """
        logger.info("加载数据...")
        
        # 加载OORD数据
        self.oord_data = pd.read_csv(oord_file)
        logger.info(f"已加载{len(self.oord_data)}条OORD记录")
        
        # 加载合成轨迹
        synthetic_trajectories = []
        for file_path in synthetic_dir.glob('trajectory_*.json'):
            with open(file_path) as f:
                trajectory = json.load(f)
                
            # 转换为DataFrame格式
            df = pd.DataFrame({
                'timestamp': trajectory['timestamp'],
                'x': trajectory['x'],
                'y': trajectory['y'],
                'speed': trajectory['speed'],
                'orientation': trajectory['orientation']
            })
            
            # 添加轨迹ID
            df['trajectory_id'] = trajectory['metadata']['index']
            
            synthetic_trajectories.append(df)
            
        if not synthetic_trajectories:
            raise ValueError(f"未在{synthetic_dir}找到轨迹文件")
            
        self.synthetic_data = pd.concat(
            synthetic_trajectories,
            ignore_index=True
        )
        logger.info(f"已加载{len(synthetic_trajectories)}条合成轨迹")
        
    def evaluate(self) -> Dict[str, float]:
        """
        执行评估
        
        Returns:
            Dict[str, float]: 评估指标
        """
        if self.oord_data is None or self.synthetic_data is None:
            raise ValueError("请先加载数据")
            
        logger.info("开始评估...")
        
        # 计算统计指标
        metrics = {}
        
        # 速度分布比较
        metrics.update(self._compare_speed_distributions())
        
        # 加速度分布比较
        metrics.update(self._compare_acceleration_distributions())
        
        # 转向率分布比较
        metrics.update(self._compare_turn_rate_distributions())
        
        # 环境交互比较
        if 'group_label' in self.oord_data.columns:
            metrics.update(self._compare_environment_interaction())
            
        # 生成评估报告
        self._generate_report(metrics)
        
        logger.info("评估完成")
        return metrics
        
    def _compare_speed_distributions(self) -> Dict[str, float]:
        """
        比较速度分布
        
        Returns:
            Dict[str, float]: 速度相关指标
        """
        oord_speeds = self.oord_data['speed']
        synthetic_speeds = self.synthetic_data['speed']
        
        # 计算KS检验
        ks_stat, p_value = stats.ks_2samp(
            oord_speeds,
            synthetic_speeds
        )
        
        # 计算基本统计量
        metrics = {
            'speed_ks_stat': ks_stat,
            'speed_ks_p_value': p_value,
            'speed_mean_diff': abs(
                oord_speeds.mean() - synthetic_speeds.mean()
            ),
            'speed_std_diff': abs(
                oord_speeds.std() - synthetic_speeds.std()
            )
        }
        
        # 绘制分布对比图
        plt.figure(figsize=(10, 6))
        sns.kdeplot(
            data=oord_speeds,
            label='OORD',
            color='blue',
            alpha=0.5
        )
        sns.kdeplot(
            data=synthetic_speeds,
            label='Synthetic',
            color='red',
            alpha=0.5
        )
        plt.title('速度分布对比')
        plt.xlabel('速度 (m/s)')
        plt.ylabel('密度')
        plt.legend()
        plt.savefig(self.output_dir / 'speed_distribution.png')
        plt.close()
        
        return metrics
        
    def _compare_acceleration_distributions(self) -> Dict[str, float]:
        """
        比较加速度分布
        
        Returns:
            Dict[str, float]: 加速度相关指标
        """
        # 计算加速度
        oord_acc = np.diff(self.oord_data['speed']) / \
                   np.diff(self.oord_data['timestamp'])
        synthetic_acc = np.diff(self.synthetic_data['speed']) / \
                       np.diff(self.synthetic_data['timestamp'])
        
        # 计算KS检验
        ks_stat, p_value = stats.ks_2samp(
            oord_acc,
            synthetic_acc
        )
        
        # 计算基本统计量
        metrics = {
            'acceleration_ks_stat': ks_stat,
            'acceleration_ks_p_value': p_value,
            'acceleration_mean_diff': abs(
                np.mean(oord_acc) - np.mean(synthetic_acc)
            ),
            'acceleration_std_diff': abs(
                np.std(oord_acc) - np.std(synthetic_acc)
            )
        }
        
        # 绘制分布对比图
        plt.figure(figsize=(10, 6))
        sns.kdeplot(
            data=oord_acc,
            label='OORD',
            color='blue',
            alpha=0.5
        )
        sns.kdeplot(
            data=synthetic_acc,
            label='Synthetic',
            color='red',
            alpha=0.5
        )
        plt.title('加速度分布对比')
        plt.xlabel('加速度 (m/s²)')
        plt.ylabel('密度')
        plt.legend()
        plt.savefig(self.output_dir / 'acceleration_distribution.png')
        plt.close()
        
        return metrics
        
    def _compare_turn_rate_distributions(self) -> Dict[str, float]:
        """
        比较转向率分布
        
        Returns:
            Dict[str, float]: 转向率相关指标
        """
        # 计算转向率
        oord_turn = np.diff(self.oord_data['orientation']) / \
                    np.diff(self.oord_data['timestamp'])
        synthetic_turn = np.diff(self.synthetic_data['orientation']) / \
                        np.diff(self.synthetic_data['timestamp'])
        
        # 处理角度环绕
        oord_turn = np.where(
            oord_turn > 180,
            oord_turn - 360,
            np.where(
                oord_turn < -180,
                oord_turn + 360,
                oord_turn
            )
        )
        synthetic_turn = np.where(
            synthetic_turn > 180,
            synthetic_turn - 360,
            np.where(
                synthetic_turn < -180,
                synthetic_turn + 360,
                synthetic_turn
            )
        )
        
        # 计算KS检验
        ks_stat, p_value = stats.ks_2samp(
            oord_turn,
            synthetic_turn
        )
        
        # 计算基本统计量
        metrics = {
            'turn_rate_ks_stat': ks_stat,
            'turn_rate_ks_p_value': p_value,
            'turn_rate_mean_diff': abs(
                np.mean(oord_turn) - np.mean(synthetic_turn)
            ),
            'turn_rate_std_diff': abs(
                np.std(oord_turn) - np.std(synthetic_turn)
            )
        }
        
        # 绘制分布对比图
        plt.figure(figsize=(10, 6))
        sns.kdeplot(
            data=oord_turn,
            label='OORD',
            color='blue',
            alpha=0.5
        )
        sns.kdeplot(
            data=synthetic_turn,
            label='Synthetic',
            color='red',
            alpha=0.5
        )
        plt.title('转向率分布对比')
        plt.xlabel('转向率 (度/秒)')
        plt.ylabel('密度')
        plt.legend()
        plt.savefig(self.output_dir / 'turn_rate_distribution.png')
        plt.close()
        
        return metrics
        
    def _compare_environment_interaction(self) -> Dict[str, float]:
        """
        比较环境交互特性
        
        Returns:
            Dict[str, float]: 环境交互相关指标
        """
        metrics = {}
        
        # 按环境组计算平均速度
        oord_group_speeds = self.oord_data.groupby('group_label')['speed'].mean()
        synthetic_group_speeds = self.synthetic_data.groupby('group_label')['speed'].mean()
        
        # 计算组间速度差异
        common_groups = set(oord_group_speeds.index) & \
                       set(synthetic_group_speeds.index)
                       
        if not common_groups:
            logger.warning("未找到共同的环境组")
            return metrics
            
        speed_diffs = []
        for group in common_groups:
            diff = abs(
                oord_group_speeds[group] - synthetic_group_speeds[group]
            )
            speed_diffs.append(diff)
            metrics[f'speed_diff_group_{group}'] = diff
            
        metrics['mean_group_speed_diff'] = np.mean(speed_diffs)
        
        # 绘制环境组速度对比图
        plt.figure(figsize=(12, 6))
        x = np.arange(len(common_groups))
        width = 0.35
        
        plt.bar(
            x - width/2,
            [oord_group_speeds[g] for g in common_groups],
            width,
            label='OORD',
            color='blue',
            alpha=0.5
        )
        plt.bar(
            x + width/2,
            [synthetic_group_speeds[g] for g in common_groups],
            width,
            label='Synthetic',
            color='red',
            alpha=0.5
        )
        
        plt.title('环境组平均速度对比')
        plt.xlabel('环境组')
        plt.ylabel('平均速度 (m/s)')
        plt.xticks(x, common_groups, rotation=45)
        plt.legend()
        plt.tight_layout()
        plt.savefig(self.output_dir / 'environment_interaction.png')
        plt.close()
        
        return metrics
        
    def _generate_report(self, metrics: Dict[str, float]) -> None:
        """
        生成评估报告
        
        Args:
            metrics: 评估指标
        """
        report_file = self.output_dir / 'evaluation_report.txt'
        
        with open(report_file, 'w') as f:
            f.write("轨迹评估报告\n")
            f.write("=" * 50 + "\n\n")
            
            f.write("1. 数据概况\n")
            f.write("-" * 30 + "\n")
            f.write(f"OORD轨迹数量: {len(self.oord_data['trajectory_id'].unique())}\n")
            f.write(f"合成轨迹数量: {len(self.synthetic_data['trajectory_id'].unique())}\n")
            f.write(f"OORD数据点数: {len(self.oord_data)}\n")
            f.write(f"合成数据点数: {len(self.synthetic_data)}\n\n")
            
            f.write("2. 速度分布\n")
            f.write("-" * 30 + "\n")
            f.write(f"KS统计量: {metrics['speed_ks_stat']:.4f}\n")
            f.write(f"P值: {metrics['speed_ks_p_value']:.4f}\n")
            f.write(f"平均值差异: {metrics['speed_mean_diff']:.4f} m/s\n")
            f.write(f"标准差差异: {metrics['speed_std_diff']:.4f} m/s\n\n")
            
            f.write("3. 加速度分布\n")
            f.write("-" * 30 + "\n")
            f.write(f"KS统计量: {metrics['acceleration_ks_stat']:.4f}\n")
            f.write(f"P值: {metrics['acceleration_ks_p_value']:.4f}\n")
            f.write(f"平均值差异: {metrics['acceleration_mean_diff']:.4f} m/s²\n")
            f.write(f"标准差差异: {metrics['acceleration_std_diff']:.4f} m/s²\n\n")
            
            f.write("4. 转向率分布\n")
            f.write("-" * 30 + "\n")
            f.write(f"KS统计量: {metrics['turn_rate_ks_stat']:.4f}\n")
            f.write(f"P值: {metrics['turn_rate_ks_p_value']:.4f}\n")
            f.write(f"平均值差异: {metrics['turn_rate_mean_diff']:.4f} 度/秒\n")
            f.write(f"标准差差异: {metrics['turn_rate_std_diff']:.4f} 度/秒\n\n")
            
            if 'mean_group_speed_diff' in metrics:
                f.write("5. 环境交互\n")
                f.write("-" * 30 + "\n")
                f.write(f"环境组平均速度差异: {metrics['mean_group_speed_diff']:.4f} m/s\n")
                for key, value in metrics.items():
                    if key.startswith('speed_diff_group_'):
                        group = key.replace('speed_diff_group_', '')
                        f.write(f"组{group}速度差异: {value:.4f} m/s\n")
                        
            f.write("\n6. 结论\n")
            f.write("-" * 30 + "\n")
            
            # 添加结论
            conclusions = []
            
            # 速度分布结论
            if metrics['speed_ks_p_value'] > 0.05:
                conclusions.append("速度分布相似性良好")
            else:
                conclusions.append("速度分布存在显著差异")
                
            # 加速度分布结论
            if metrics['acceleration_ks_p_value'] > 0.05:
                conclusions.append("加速度分布相似性良好")
            else:
                conclusions.append("加速度分布存在显著差异")
                
            # 转向率分布结论
            if metrics['turn_rate_ks_p_value'] > 0.05:
                conclusions.append("转向率分布相似性良好")
            else:
                conclusions.append("转向率分布存在显著差异")
                
            # 环境交互结论
            if 'mean_group_speed_diff' in metrics:
                if metrics['mean_group_speed_diff'] < 2.0:  # 阈值可调
                    conclusions.append("环境交互特性表现良好")
                else:
                    conclusions.append("环境交互特性需要改进")
                    
            for conclusion in conclusions:
                f.write(f"- {conclusion}\n")
                
        logger.info(f"评估报告已保存至: {report_file}") 
```

### src/core/learning/motion_pattern_learner.py
```python
"""
运动模式学习器
从OORD数据中学习运动特性与环境的关系
"""

import numpy as np
import pandas as pd
import logging
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
import json

from src.core.terrain.loader import TerrainLoader
from src.utils.config import config

logger = logging.getLogger(__name__)

@dataclass
class EnvironmentMaps:
    """环境地图集合"""
    typical_speed: np.ndarray    # 典型速度图
    max_speed: np.ndarray       # 最大速度图
    speed_stddev: np.ndarray    # 速度标准差图
    slope_magnitude: np.ndarray  # 坡度图
    slope_aspect: np.ndarray    # 坡向图
    landcover: Optional[np.ndarray] = None  # 土地覆盖图

@dataclass
class EnvironmentGroup:
    """环境分组"""
    landcover_code: int
    slope_level: int
    group_label: str
    
    # 统计量
    typical_speed: float
    max_speed: float
    speed_stddev: float
    max_acceleration: float
    max_deceleration: float
    max_turn_rate: float
    
    # 样本数量
    sample_count: int

class MotionPatternLearner:
    """运动模式学习器"""
    
    def __init__(
            self,
            terrain_loader: TerrainLoader,
            min_samples_per_group: int = 20,
            window_size_seconds: int = 30  # 添加窗口大小参数，默认30秒
        ):
        """
        初始化学习器
        
        Args:
            terrain_loader: 地形加载器实例
            min_samples_per_group: 每个环境组的最小样本数
            window_size_seconds: 计算平均速度的时间窗口大小（秒）
        """
        self.terrain_loader = terrain_loader
        self.min_samples_per_group = min_samples_per_group
        self.window_size_seconds = window_size_seconds
        self.config = config  # 添加config属性
        
        # 存储学习结果
        self.env_groups: Dict[str, EnvironmentGroup] = {}
        
    def _create_group_label(
            self,
            landcover_code: int,
            slope_magnitude: float
        ) -> str:
        """
        创建环境组标签
        
        Args:
            landcover_code: 土地覆盖类型代码
            slope_magnitude: 坡度大小(度)
            
        Returns:
            str: 环境组标签
        """
        # 确定坡度等级
        slope_bins = config['terrain']['SLOPE_BINS']
        slope_level = np.digitize(slope_magnitude, slope_bins) - 1
        
        return f"LC{landcover_code}_S{slope_level}"
        
    def _process_trajectory(
            self,
            trajectory_df: pd.DataFrame,
            group_stats: Dict[str, List]
        ) -> None:
        """
        处理单条轨迹
        
        Args:
            trajectory_df: 轨迹数据框
            group_stats: 用于收集统计数据的字典
        """
        for _, row in trajectory_df.iterrows():
            # 将经纬度转换为UTM坐标
            utm_coord = self.terrain_loader.lonlat_to_utm(
                row['longitude'],
                row['latitude']
            )
            
            # 将UTM坐标转换为栅格坐标
            pixel_coord = self.terrain_loader.utm_to_pixel(*utm_coord)
            
            # 获取地形属性
            attrs = self.terrain_loader.get_terrain_attributes(*utm_coord)
            
            if not attrs:  # 如果位置无效
                continue
                
            # 创建环境组标签
            group_label = self._create_group_label(
                attrs['landcover'],
                attrs['slope']
            )
            
            # 收集统计数据
            if group_label not in group_stats:
                group_stats[group_label] = {
                    'landcover_code': attrs['landcover'],
                    'slope_level': np.digitize(
                        attrs['slope'],
                        config['terrain']['SLOPE_BINS']
                    ) - 1,
                    'speeds': [],
                    'accelerations': [],
                    'turn_rates': []
                }
                
            stats = group_stats[group_label]
            stats['speeds'].append(row['speed_mps'])
            stats['accelerations'].append(row['acceleration_mps2'])
            stats['turn_rates'].append(row['turn_rate_dps'])
            
    def learn_from_single_trajectory(
            self,
            trajectory_file: Path,
            min_samples_per_group: Optional[int] = None
        ) -> None:
        """
        从单条轨迹学习运动模式，使用30秒窗口的平均速度
        
        Args:
            trajectory_file: 轨迹文件路径
            min_samples_per_group: 临时设置每组最小样本数
        """
        # 临时调整最小样本数
        original_min_samples = None
        if min_samples_per_group is not None:
            original_min_samples = self.min_samples_per_group
            self.min_samples_per_group = min_samples_per_group
            
        logger.info(f"从单条轨迹学习运动模式: {trajectory_file}")
        
        # 读取轨迹数据
        trajectory = pd.read_csv(trajectory_file)
        
        # 检查是否有常见的速度列名
        speed_column_candidates = ['speed', 'velocity_2d_ms', 'speed_mps', 'velocity']
        acceleration_column_candidates = ['acceleration', 'horizontal_acceleration_ms2', 'acceleration_mps2']
        turn_rate_column_candidates = ['turn_rate', 'angular_velocity_z_rads', 'turn_rate_dps']
        
        # 检查时间戳列
        time_column_candidates = ['timestamp', 'time', 'unix_time', 'seconds']
        time_column = None
        for col in time_column_candidates:
            if col in trajectory.columns:
                time_column = col
                print(f"使用'{col}'列作为时间数据")
                break
                
        # 映射列名
        for col in speed_column_candidates:
            if col in trajectory.columns:
                trajectory['speed'] = trajectory[col]
                print(f"使用'{col}'列作为速度数据")
                break
                
        for col in acceleration_column_candidates:
            if col in trajectory.columns:
                trajectory['acceleration'] = trajectory[col]
                print(f"使用'{col}'列作为加速度数据")
                break
                
        for col in turn_rate_column_candidates:
            if col in trajectory.columns:
                trajectory['turn_rate'] = trajectory[col]
                print(f"使用'{col}'列作为转向率数据")
                break
        
        # 打印原始速度统计
        print(f"原始轨迹速度统计:")
        if 'speed' in trajectory.columns:
            print(f"平均速度: {trajectory['speed'].mean():.2f} m/s")
            print(f"最大速度: {trajectory['speed'].max():.2f} m/s")
            print(f"最小速度: {trajectory['speed'].min():.2f} m/s")
            print(f"速度标准差: {trajectory['speed'].std():.2f} m/s")
            print(f"不同速度值数量: {len(trajectory['speed'].unique())}")
        else:
            print("轨迹数据中没有速度列")
            # 如果没有速度列，添加模拟速度
            min_speed = 1.0
            max_speed = 8.5
            # 使用多种模式生成速度，确保多样性
            segments = np.random.randint(5, 10)  # 分5-10段
            segment_size = len(trajectory) // segments
            speeds = []
            
            for i in range(segments):
                # 生成基础速度
                base_speed = np.random.uniform(min_speed, max_speed)
                # 在段内添加小的随机波动
                segment_speeds = base_speed + np.random.normal(0, 0.5, size=segment_size)
                speeds.extend(segment_speeds)
            
            # 确保长度匹配
            if len(speeds) < len(trajectory):
                # 添加剩余的点
                remaining = len(trajectory) - len(speeds)
                speeds.extend(np.random.uniform(min_speed, max_speed, size=remaining))
            elif len(speeds) > len(trajectory):
                # 截断多余的点
                speeds = speeds[:len(trajectory)]
                
            # 确保速度在范围内
            speeds = np.clip(speeds, min_speed, max_speed)
            trajectory['speed'] = speeds
            
            print(f"添加了模拟速度:")
            print(f"平均速度: {np.mean(speeds):.2f} m/s")
            print(f"最大速度: {np.max(speeds):.2f} m/s")
            print(f"最小速度: {np.min(speeds):.2f} m/s")
            print(f"速度标准差: {np.std(speeds):.2f} m/s")
            print(f"不同速度值数量: {len(np.unique(speeds))}")
            
        # 计算基于窗口的平均速度
        if 'speed' in trajectory.columns:
            # 如果有时间列，按时间分窗口
            if time_column:
                print(f"使用{self.window_size_seconds}秒的时间窗口计算平均速度")
                # 确保时间列是升序的
                trajectory = trajectory.sort_values(by=time_column)
                
                # 创建时间窗口并计算平均速度
                trajectory['time_window'] = trajectory[time_column] // self.window_size_seconds
                window_speeds = trajectory.groupby('time_window')['speed'].mean().reset_index()
                
                print(f"基于{len(window_speeds)}个时间窗口的速度统计:")
                print(f"窗口平均速度: {window_speeds['speed'].mean():.2f} m/s")
                print(f"窗口最大速度: {window_speeds['speed'].max():.2f} m/s")
                print(f"窗口最小速度: {window_speeds['speed'].min():.2f} m/s")
                print(f"窗口速度标准差: {window_speeds['speed'].std():.2f} m/s")
            else:
                # 如果没有时间列，按点数分窗口
                points_per_window = 10  # 每窗口10个点，近似30秒
                print(f"没有时间列，使用每{points_per_window}个点的窗口计算平均速度")
                
                # 创建窗口并计算平均速度
                trajectory['point_window'] = trajectory.index // points_per_window
                window_speeds = trajectory.groupby('point_window')['speed'].mean().reset_index()
                
                print(f"基于{len(window_speeds)}个点数窗口的速度统计:")
                print(f"窗口平均速度: {window_speeds['speed'].mean():.2f} m/s")
                print(f"窗口最大速度: {window_speeds['speed'].max():.2f} m/s")
                print(f"窗口最小速度: {window_speeds['speed'].min():.2f} m/s")
                print(f"窗口速度标准差: {window_speeds['speed'].std():.2f} m/s")
                
        # 按环境条件分组统计
        group_stats = {}
        
        # 使用窗口平均速度数据（如果有）
        for _, row in trajectory.iterrows():
            # 获取UTM坐标
            utm_east, utm_north = self.terrain_loader.lonlat_to_utm(
                row['longitude'],
                row['latitude']
            )
            
            # 获取地形属性
            attrs = self.terrain_loader.get_terrain_attributes(utm_east, utm_north)
            if not attrs:
                continue
                
            # 创建环境组标签
            group_label = self._create_group_label(
                attrs['landcover'],
                attrs['slope']
            )
            
            # 初始化组统计数据
            if group_label not in group_stats:
                group_stats[group_label] = {
                    'landcover_code': attrs['landcover'],
                    'slope_level': int(np.digitize(attrs['slope'], 
                                     config['terrain']['SLOPE_BINS']) - 1),
                    'speeds': [],
                    'accelerations': [],
                    'turn_rates': []
                }
            
            # 获取该点所在窗口的平均速度
            if 'time_window' in trajectory.columns and time_column:
                window_id = row['time_window']
                window_speed = window_speeds[window_speeds['time_window'] == window_id]['speed'].values[0]
                group_stats[group_label]['speeds'].append(float(window_speed))
            elif 'point_window' in trajectory.columns:
                window_id = row['point_window']
                window_speed = window_speeds[window_speeds['point_window'] == window_id]['speed'].values[0]
                group_stats[group_label]['speeds'].append(float(window_speed))
            elif 'speed' in row:
                # 如果没有窗口信息，使用原始速度
                group_stats[group_label]['speeds'].append(float(row['speed']))
            
            # 统计加速度数据    
            if 'acceleration' in row:
                group_stats[group_label]['accelerations'].append(
                    float(row['acceleration'])
                )
                
            # 统计转向率数据
            if 'turn_rate' in row:
                group_stats[group_label]['turn_rates'].append(
                    float(row['turn_rate'])
                )
        
        # 计算统计量
        for group_label, stats in group_stats.items():
            speeds = np.array(stats['speeds'])
            
            # 如果没有速度数据，使用全局轨迹统计
            if len(speeds) == 0 and 'speed' in trajectory.columns:
                if 'time_window' in trajectory.columns or 'point_window' in trajectory.columns:
                    # 使用窗口平均速度
                    speeds = window_speeds['speed'].values
                else:
                    # 使用原始轨迹速度
                    speeds = trajectory['speed'].values
                print(f"环境组 {group_label} 没有速度数据，使用全局轨迹统计")
            
            accels = np.array(stats['accelerations'])
            turn_rates = np.array(stats['turn_rates'])
            
            # 检查样本数量
            if len(speeds) < self.min_samples_per_group:
                logger.warning(
                    f"环境组 {group_label} 样本数量不足: {len(speeds)} < "
                    f"{self.min_samples_per_group}"
                )
                # 继续使用这些样本，即使数量不足
                # 调整为使用轨迹整体速度统计
                if len(speeds) == 0:
                    if 'time_window' in trajectory.columns or 'point_window' in trajectory.columns:
                        speeds = window_speeds['speed'].values
                    elif 'speed' in trajectory.columns:
                        speeds = trajectory['speed'].values
                    print(f"环境组 {group_label} 使用全局轨迹速度数据")
                
            # 确保有速度数据
            if len(speeds) > 0:
                # 创建环境组对象
                self.env_groups[group_label] = EnvironmentGroup(
                    landcover_code=stats['landcover_code'],
                    slope_level=stats['slope_level'],
                    group_label=group_label,
                    typical_speed=np.median(speeds),
                    max_speed=np.max(speeds),  # 使用最大值而不是95百分位数
                    speed_stddev=np.std(speeds),
                    max_acceleration=np.percentile(accels, 95) if len(accels) > 0 else 2.0,
                    max_deceleration=np.percentile(accels, 5) if len(accels) > 0 else -4.0,
                    max_turn_rate=np.percentile(np.abs(turn_rates), 95) if len(turn_rates) > 0 else 30.0,
                    sample_count=len(speeds)
                )
                print(f"环境组 {group_label} 统计: 典型速度={np.median(speeds):.2f}, 最大速度={np.max(speeds):.2f}, 标准差={np.std(speeds):.2f}")
            
        # 恢复原始最小样本数
        if min_samples_per_group is not None:
            self.min_samples_per_group = original_min_samples
            
    def learn_from_oord_data(
            self,
            oord_data_dir: Path,
            exclude_files: Optional[List[str]] = None
        ) -> None:
        """
        从OORD数据学习运动模式
        
        Args:
            oord_data_dir: OORD数据目录
            exclude_files: 要排除的文件名列表
        """
        logger.info(f"开始从OORD数据学习运动模式: {oord_data_dir}")
        
        # 收集统计数据
        group_stats: Dict[str, List] = {}
        
        # 处理所有轨迹文件
        for trajectory_file in oord_data_dir.glob('*_core.csv'):
            # 如果文件在排除列表中，跳过
            if (exclude_files and 
                trajectory_file.name in exclude_files):
                logger.info(f"跳过文件: {trajectory_file}")
                continue
                
            logger.debug(f"处理轨迹文件: {trajectory_file}")
            try:
                trajectory_df = pd.read_csv(trajectory_file)
                self._process_trajectory(trajectory_df, group_stats)
            except Exception as e:
                logger.error(f"处理文件 {trajectory_file} 时出错: {e}")
                continue
                
        # 计算统计量
        for group_label, stats in group_stats.items():
            speeds = np.array(stats['speeds'])
            accels = np.array(stats['accelerations'])
            turn_rates = np.array(stats['turn_rates'])
            
            # 检查样本数量
            if len(speeds) < self.min_samples_per_group:
                logger.warning(
                    f"环境组 {group_label} 样本数量不足: {len(speeds)} < "
                    f"{self.min_samples_per_group}"
                )
                continue
                
            # 创建环境组对象
            self.env_groups[group_label] = EnvironmentGroup(
                landcover_code=stats['landcover_code'],
                slope_level=stats['slope_level'],
                group_label=group_label,
                typical_speed=np.median(speeds),
                max_speed=np.percentile(speeds, 95),
                speed_stddev=np.std(speeds),
                max_acceleration=np.percentile(accels, 95),
                max_deceleration=np.percentile(accels, 5),
                max_turn_rate=np.percentile(np.abs(turn_rates), 95),
                sample_count=len(speeds)
            )
            
    def generate_speed_maps(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        生成速度相关的环境地图
        
        Returns:
            Tuple[np.ndarray, np.ndarray, np.ndarray]: 
            (典型速度图, 最大速度图, 速度标准差图)
        """
        height, width = self.terrain_loader.dem_data.shape
        
        # 初始化地图
        typical_speed = np.full(
            (height, width),
            self.config['motion']['DEFAULT_SPEED']
        )
        max_speed = np.full(
            (height, width),
            self.config['motion']['MAX_SPEED']
        )
        speed_stddev = np.full(
            (height, width),
            self.config['motion']['SPEED_STDDEV']
        )
        
        # 填充地图
        for row in range(height):
            for col in range(width):
                attrs = self.terrain_loader.get_terrain_attributes(row, col)
                if not attrs:
                    continue
                    
                group_label = self._create_group_label(
                    attrs['landcover'],
                    attrs['slope']
                )
                
                if group_label in self.env_groups:
                    group = self.env_groups[group_label]
                    typical_speed[row, col] = group.typical_speed
                    max_speed[row, col] = group.max_speed
                    speed_stddev[row, col] = group.speed_stddev
                    
        return typical_speed, max_speed, speed_stddev
        
    def save_results(self, output_file: Path) -> None:
        """
        保存学习结果
        
        Args:
            output_file: 输出文件路径
        """
        # 转换为可序列化的字典
        results = {
            'env_groups': {
                label: {
                    'landcover_code': group.landcover_code,
                    'slope_level': group.slope_level,
                    'typical_speed': group.typical_speed,
                    'max_speed': group.max_speed,
                    'speed_stddev': group.speed_stddev,
                    'max_acceleration': group.max_acceleration,
                    'max_deceleration': group.max_deceleration,
                    'max_turn_rate': group.max_turn_rate,
                    'sample_count': group.sample_count
                }
                for label, group in self.env_groups.items()
            },
            'metadata': {
                'total_samples': sum(
                    group.sample_count for group in self.env_groups.values()
                ),
                'group_count': len(self.env_groups)
            }
        }
        
        # 保存为JSON文件
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2)
            
    @classmethod
    def load_results(
            cls,
            input_file: Path,
            terrain_loader: TerrainLoader,
            config: Dict
        ) -> 'MotionPatternLearner':
        """
        加载学习结果
        
        Args:
            input_file: 输入文件路径
            terrain_loader: 地形加载器实例
            config: 配置参数
            
        Returns:
            MotionPatternLearner: 学习器实例
        """
        learner = cls(terrain_loader)
        
        # 从JSON文件加载
        with open(input_file, 'r') as f:
            results = json.load(f)
            
        # 重建环境组对象
        for label, group_data in results['env_groups'].items():
            learner.env_groups[label] = EnvironmentGroup(
                landcover_code=group_data['landcover_code'],
                slope_level=group_data['slope_level'],
                group_label=label,
                typical_speed=group_data['typical_speed'],
                max_speed=group_data['max_speed'],
                speed_stddev=group_data['speed_stddev'],
                max_acceleration=group_data['max_acceleration'],
                max_deceleration=group_data['max_deceleration'],
                max_turn_rate=group_data['max_turn_rate'],
                sample_count=group_data['sample_count']
            )
            
        return learner

    def generate_environment_maps(self) -> EnvironmentMaps:
        """
        生成环境地图
        
        Returns:
            EnvironmentMaps: 包含各种速度地图的对象
        """
        # 获取地图尺寸
        height, width = self.terrain_loader.dem_data.shape
        
        # 初始化地图
        typical_speed = np.full(
            (height, width),
            10.0  # 提高默认速度
        )
        max_speed = np.full(
            (height, width),
            15.0  # 提高最大速度
        )
        speed_stddev = np.full(
            (height, width),
            2.0   # 提高速度标准差
        )
        
        # 遍历每个像素
        for i in range(height):
            for j in range(width):
                # 获取像素的UTM坐标
                utm_coord = self.terrain_loader.pixel_to_utm(i, j)
                
                # 获取地形属性
                attrs = self.terrain_loader.get_terrain_attributes(*utm_coord)
                if not attrs:
                    continue
                    
                # 获取环境组标签
                group_label = self._create_group_label(
                    attrs['landcover'],
                    attrs['slope']
                )
                
                # 如果该环境组存在,使用其统计值
                if group_label in self.env_groups:
                    group = self.env_groups[group_label]
                    typical_speed[i, j] = group.typical_speed
                    max_speed[i, j] = group.max_speed
                    speed_stddev[i, j] = group.speed_stddev
                else:
                    # 使用默认值，但提高速度范围以匹配原始轨迹
                    typical_speed[i, j] = 10.0  # 提高默认速度
                    max_speed[i, j] = 15.0     # 提高默认最大速度
                    speed_stddev[i, j] = 2.0   # 提高默认标准差
        
        # 验证生成的速度图
        self.validate_speed_maps(typical_speed, max_speed)
        
        return EnvironmentMaps(
            typical_speed=typical_speed,
            max_speed=max_speed,
            speed_stddev=speed_stddev,
            slope_magnitude=self.terrain_loader.slope_data,
            slope_aspect=self.terrain_loader.aspect_data,
            landcover=self.terrain_loader.landcover_data
        )

    def validate_speed_maps(self, typical_speed: np.ndarray, max_speed: np.ndarray) -> None:
        """
        验证生成的速度图是否合理
        
        Args:
            typical_speed: 典型速度图
            max_speed: 最大速度图
        """
        # 检查速度范围
        typical_speed_max = np.max(typical_speed)
        max_speed_max = np.max(max_speed)
        
        if typical_speed_max > 15.0:  # ~54 km/h
            logger.warning(f"典型速度最大值过高: {typical_speed_max:.2f} m/s")
            # 对超过阈值的速度进行缩放
            scale_factor = 15.0 / typical_speed_max
            typical_speed *= scale_factor
            logger.info(f"已将典型速度缩放为原来的 {scale_factor:.2%}")
            
        if max_speed_max > 20.0:  # ~72 km/h
            logger.warning(f"最大速度最大值过高: {max_speed_max:.2f} m/s")
            # 对超过阈值的速度进行缩放
            scale_factor = 20.0 / max_speed_max
            max_speed *= scale_factor
            logger.info(f"已将最大速度缩放为原来的 {scale_factor:.2%}")
            
        # 检查典型速度是否总是小于等于最大速度
        invalid_mask = typical_speed > max_speed
        if np.any(invalid_mask):
            invalid_count = np.sum(invalid_mask)
            logger.warning(
                f"发现 {invalid_count} 个像素的典型速度大于最大速度"
            )
            # 修正这些像素的速度值
            typical_speed[invalid_mask] = max_speed[invalid_mask] * 0.8
            logger.info("已修正典型速度大于最大速度的像素")
            
        # 检查速度的空间连续性
        typical_speed_grad = np.gradient(typical_speed)
        max_speed_grad = np.gradient(max_speed)
        
        typical_speed_grad_mag = np.sqrt(
            typical_speed_grad[0]**2 + typical_speed_grad[1]**2
        )
        max_speed_grad_mag = np.sqrt(
            max_speed_grad[0]**2 + max_speed_grad[1]**2
        )
        
        # 检查速度梯度是否过大
        if np.max(typical_speed_grad_mag) > 2.0:  # 每像素最大2m/s的变化
            logger.warning(
                f"典型速度空间变化过大: {np.max(typical_speed_grad_mag):.2f} m/s/pixel"
            )
            
        if np.max(max_speed_grad_mag) > 3.0:  # 每像素最大3m/s的变化
            logger.warning(
                f"最大速度空间变化过大: {np.max(max_speed_grad_mag):.2f} m/s/pixel"
            ) 
```

### src/core/motion/__init__.py
```python

```

### src/core/motion/simulator.py
```python
"""
运动模拟器模块
基于物理模型和环境约束进行运动模拟
"""

import numpy as np
import logging
from dataclasses import dataclass
from typing import List, Tuple, Dict, Optional, Any
from pathlib import Path

logger = logging.getLogger(__name__)

@dataclass
class EnvironmentMaps:
    """环境地图集合"""
    typical_speed: np.ndarray  # 典型速度图（来自学习）
    max_speed: np.ndarray     # 最大速度图（来自学习）
    speed_stddev: np.ndarray  # 速度标准差图（来自学习）
    slope_magnitude: np.ndarray  # 坡度大小图
    slope_aspect: np.ndarray    # 坡向图
    landcover: Optional[np.ndarray] = None  # 土地覆盖类型图

@dataclass
class AgentState:
    """智能体状态"""
    position: np.ndarray  # [easting, northing] (UTM坐标，米)
    speed: float         # 当前速度 (m/s)
    heading: float       # 当前朝向 (弧度)
    target_point: np.ndarray  # 目标点 [easting, northing] (UTM坐标，米)

@dataclass
class TrajectoryPoint:
    """轨迹点"""
    timestamp: float  # 时间戳(秒)
    easting: float   # UTM东坐标(米)
    northing: float  # UTM北坐标(米)
    lon: float       # 经度
    lat: float       # 纬度
    speed: float     # 速度(米/秒)
    heading: float   # 朝向(弧度)
    acceleration: float = 0.0  # 加速度(米/秒²)
    turn_rate: float = 0.0    # 转向率(度/秒)

class MotionSimulator:
    """运动模拟器"""
    
    def __init__(
            self,
            env_maps: EnvironmentMaps,
            terrain_loader: Any,  # TerrainLoader实例
            config: Dict
        ):
        """
        初始化运动模拟器
        
        Args:
            env_maps: 环境地图集合（包含从OORD数据学习到的速度图）
            terrain_loader: 地形加载器实例，用于坐标转换
            config: 配置参数字典（motion子字典）
        """
        self.env_maps = env_maps
        self.terrain_loader = terrain_loader
        
        # 使用环境地图中的速度值来设置配置参数
        self.config = config.copy()  # 创建配置的副本
        
        # 从环境地图中获取速度统计信息
        # 使用学习到的值设置速度参数
        self.config['DEFAULT_SPEED'] = float(np.median(env_maps.typical_speed))
        self.config['MAX_SPEED'] = float(np.max(env_maps.max_speed))
        self.config['MIN_SPEED'] = 0.1  # 设置一个合理的最小速度
        self.config['SPEED_STDDEV'] = float(np.median(env_maps.speed_stddev))
        
        # 输出学习到的速度参数
        logger.info(f"从环境地图学习到的速度参数:")
        logger.info(f"默认速度: {self.config['DEFAULT_SPEED']:.2f} m/s")
        logger.info(f"最大速度: {self.config['MAX_SPEED']:.2f} m/s")
        logger.info(f"最小速度: {self.config['MIN_SPEED']:.2f} m/s")
        logger.info(f"速度标准差: {self.config['SPEED_STDDEV']:.2f} m/s")
        
        # 验证地图尺寸一致性
        self._validate_maps()
        
        # 获取地图尺寸
        self.height, self.width = env_maps.typical_speed.shape
        
    def _validate_maps(self) -> None:
        """验证所有地图尺寸一致"""
        shape = self.env_maps.typical_speed.shape
        if self.env_maps.max_speed.shape != shape:
            raise ValueError("最大速度图尺寸不匹配")
        if self.env_maps.speed_stddev.shape != shape:
            raise ValueError("速度标准差图尺寸不匹配")
        if self.env_maps.slope_magnitude.shape != shape:
            raise ValueError("坡度图尺寸不匹配")
        if self.env_maps.slope_aspect.shape != shape:
            raise ValueError("坡向图尺寸不匹配")
        if (self.env_maps.landcover is not None and 
            self.env_maps.landcover.shape != shape):
            raise ValueError("土地覆盖图尺寸不匹配")
            
    def _get_environment_at_position(self, easting: float, northing: float) -> Dict:
        """
        获取指定位置的环境参数
        
        Args:
            easting: UTM东坐标(米)
            northing: UTM北坐标(米)
            
        Returns:
            Dict: 环境参数字典
        """
        # 转换UTM坐标为像素坐标
        pixel_i, pixel_j = self.terrain_loader.utm_to_pixel(easting, northing)
        
        # 检查像素是否在地图范围内
        if (0 <= pixel_i < self.height and 0 <= pixel_j < self.width):
            i, j = int(pixel_i), int(pixel_j)
            
            # 从环境地图获取参数
            typical_speed = float(self.env_maps.typical_speed[i, j])
            max_speed = float(self.env_maps.max_speed[i, j])
            speed_stddev = float(self.env_maps.speed_stddev[i, j])
            slope_magnitude = float(self.env_maps.slope_magnitude[i, j])
            slope_aspect = float(self.env_maps.slope_aspect[i, j])
            
            # 使用学习到的值，不再硬编码速度范围
            min_speed = max(self.config['MIN_SPEED'], typical_speed * 0.5)
            
            return {
                'typical_speed': typical_speed,
                'max_speed': max_speed,
                'min_speed': min_speed,
                'speed_stddev': speed_stddev,
                'slope_magnitude': slope_magnitude,
                'slope_aspect': slope_aspect,
                'max_acceleration': self.config['MAX_ACCELERATION'],
                'max_deceleration': self.config['MAX_DECELERATION'],
                'max_turn_rate': self.config['MAX_TURN_RATE']
            }
        else:
            # 超出地图范围，使用默认值
            return {
                'typical_speed': self.config['DEFAULT_SPEED'],
                'max_speed': self.config['MAX_SPEED'],
                'min_speed': self.config['MIN_SPEED'],
                'speed_stddev': self.config['SPEED_STDDEV'],
                'slope_magnitude': 0.0,
                'slope_aspect': 0.0,
                'max_acceleration': self.config['MAX_ACCELERATION'],
                'max_deceleration': self.config['MAX_DECELERATION'],
                'max_turn_rate': self.config['MAX_TURN_RATE']
            }
        
    def _calculate_slope_effects(
            self,
            slope_magnitude: float,
            slope_aspect: float,
            heading: float
        ) -> Tuple[float, float]:
        """
        计算坡度对运动的影响
        
        Args:
            slope_magnitude: 坡度大小(度)
            slope_aspect: 坡向(度)
            heading: 运动朝向(弧度)
            
        Returns:
            Tuple[float, float]: (沿路径坡度, 横向坡度)
        """
        # 将坡向和朝向转换为弧度
        aspect_rad = np.deg2rad(slope_aspect)
        
        # 计算坡度在运动方向上的分量
        slope_along_path = (
            slope_magnitude * np.cos(aspect_rad - heading)
        )
        
        # 计算横向坡度
        cross_slope = (
            slope_magnitude * np.sin(aspect_rad - heading)
        )
        
        return slope_along_path, cross_slope
        
    def _adjust_speed_for_terrain(
            self,
            base_speed: float,
            slope_along_path: float,
            cross_slope: float
        ) -> float:
        """
        根据地形调整速度
        
        Args:
            base_speed: 基础速度
            slope_along_path: 沿路径坡度
            cross_slope: 横向坡度
            
        Returns:
            float: 调整后的速度
        """
        # 获取配置参数
        slope_factor = self.config['SLOPE_SPEED_FACTOR']
        cross_slope_factor = self.config['CROSS_SLOPE_FACTOR']
        min_speed = self.config['MIN_SPEED']
        
        # 计算坡度影响
        slope_effect = 1.0 - slope_factor * abs(slope_along_path)
        cross_slope_effect = 1.0 - cross_slope_factor * abs(cross_slope)
        
        # 应用地形影响
        adjusted_speed = base_speed * slope_effect * cross_slope_effect
        
        # 确保速度不低于最小值
        return max(adjusted_speed, min_speed)
        
    def _update_agent_state(
            self,
            agent: AgentState,
            dt: float,
            force_target: Optional[np.ndarray] = None
        ) -> Tuple[AgentState, float, float]:
        """
        更新智能体状态
        
        Args:
            agent: 当前智能体状态
            dt: 时间步长
            force_target: 强制目标点（可选）
            
        Returns:
            更新后的智能体状态、加速度和转向率
        """
        # 获取当前位置的环境参数
        environment = self._get_environment_at_position(*agent.position)
        
        # 从环境中获取速度参数
        typical_speed = environment['typical_speed']
        max_speed = environment['max_speed']
        min_speed = environment['min_speed']
        speed_stddev = environment['speed_stddev']
        
        # 基于学习到的速度分布生成目标速度
        # 使用正态分布生成速度，中心在典型速度，标准差由学习得到
        target_speed = np.random.normal(typical_speed, speed_stddev)
        
        # 确保目标速度在合理范围内
        target_speed = np.clip(target_speed, min_speed, max_speed)
        
        # 随机添加小的波动，模拟30秒窗口内的速度变化
        # 每隔一定时间有30%的概率进行明显的速度调整
        if agent.speed > 0 and np.random.random() < 0.3:
            # 速度变化的方向（加速或减速）
            direction = np.random.choice([-1, 1])
            # 变化的幅度（基于学习到的标准差）
            magnitude = np.random.uniform(0.1, speed_stddev)
            # 应用变化
            target_speed = np.clip(agent.speed + direction * magnitude, min_speed, max_speed)
        
        # 计算到目标点的方向和距离
        target = force_target if force_target is not None else agent.target_point
        direction = target - agent.position
        distance = np.linalg.norm(direction)
        
        if distance > 0:
            direction = direction / distance
            
            # 计算目标朝向
            target_heading = np.arctan2(direction[1], direction[0])
            
            # 计算转向角度
            heading_diff = (target_heading - agent.heading + np.pi) % (2 * np.pi) - np.pi
            
            # 根据转向角度调整速度
            angle_factor = np.cos(heading_diff)
            target_speed *= max(0.7, angle_factor)  # 转弯时保持至少70%的速度
            
            # 根据距离调整速度
            distance_factor = max(0.7, min(1.0, distance / 20.0))  # 接近目标点时保持至少70%的速度
            target_speed *= distance_factor
            
            # 计算加速度和转向率
            speed_diff = target_speed - agent.speed
            acceleration = np.clip(
                speed_diff / dt,
                -self.config['MAX_DECELERATION'],
                self.config['MAX_ACCELERATION']
            )
            
            turn_rate = np.clip(
                heading_diff / dt,
                -np.deg2rad(self.config['MAX_TURN_RATE']),
                np.deg2rad(self.config['MAX_TURN_RATE'])
            )
            
            # 更新状态
            new_speed = np.clip(
                agent.speed + acceleration * dt,
                min_speed,
                max_speed
            )
            
            new_heading = (agent.heading + turn_rate * dt) % (2 * np.pi)
            new_position = agent.position + new_speed * dt * np.array([
                np.cos(new_heading),
                np.sin(new_heading)
            ])
            
            return (
                AgentState(
                    position=new_position,
                    speed=new_speed,
                    heading=new_heading,
                    target_point=agent.target_point
                ),
                acceleration,
                turn_rate
            )
        else:
            # 如果已到达目标点，保持当前状态
            return agent, 0.0, 0.0
        
    def simulate_motion(
            self,
            path_points: List[Tuple[float, float]],  # UTM坐标点列表
            dt: float = 0.1,
            force_path: bool = False
        ) -> List[TrajectoryPoint]:
        """
        模拟运动轨迹
        
        Args:
            path_points: 路径点列表（UTM坐标，米）
            dt: 时间步长（秒）
            force_path: 是否强制沿路径运动
            
        Returns:
            List[TrajectoryPoint]: 轨迹点列表
        """
        if len(path_points) < 2:
            raise ValueError("路径点数量不足")
            
        # 初始化轨迹点列表
        trajectory = []
        speeds = []  # 记录所有速度值，用于调试
        speed_changes = []  # 记录速度变化
        
        # 获取起点和终点
        start_point = np.array(path_points[0], dtype=float)
        end_point = np.array(path_points[-1], dtype=float)
        
        # 打印路径信息
        print(f"路径起点: ({start_point[0]}, {start_point[1]})")
        print(f"路径终点: ({end_point[0]}, {end_point[1]})")
        print(f"路径总长度: {len(path_points)} 个点")
        
        # 确保坐标是UTM形式
        if not (100000 <= start_point[0] <= 1000000 and 100000 <= start_point[1] <= 10000000):
            print("警告: 起点坐标似乎不是UTM格式，这可能导致模拟错误")
            
        # 获取起点位置的环境参数
        environment = self._get_environment_at_position(*start_point)
        
        # 打印环境地图的统计信息，用于调试
        print(f"环境地图统计：")
        print(f"典型速度范围: {np.min(self.env_maps.typical_speed):.2f} - {np.max(self.env_maps.typical_speed):.2f} m/s")
        print(f"最大速度范围: {np.min(self.env_maps.max_speed):.2f} - {np.max(self.env_maps.max_speed):.2f} m/s")
        print(f"速度标准差范围: {np.min(self.env_maps.speed_stddev):.2f} - {np.max(self.env_maps.speed_stddev):.2f} m/s")
        
        print(f"起点位置速度参数: 典型={environment['typical_speed']:.2f}, 最大={environment['max_speed']:.2f}, 标准差={environment['speed_stddev']:.2f}")
        
        # 生成初始速度，基于学习到的速度分布
        initial_speed = np.random.normal(environment['typical_speed'], environment['speed_stddev'])
        initial_speed = np.clip(initial_speed, environment['min_speed'], environment['max_speed'])
        
        print(f"初始速度: {initial_speed:.2f} m/s")
        
        # 初始化智能体状态
        agent = AgentState(
            position=start_point,
            speed=initial_speed,
            heading=0.0,  # 初始朝向将在第一次更新时调整
            target_point=end_point
        )
        
        # 初始化时间和路径索引
        t = 0.0
        path_index = 1
        
        # 用于控制30秒窗口的速度变化
        last_speed_change_time = 0.0
        window_size_seconds = 30.0  # 30秒窗口
        
        while True:
            # 转换UTM坐标为经纬度
            lon, lat = self.terrain_loader.utm_to_lonlat(
                agent.position[0],
                agent.position[1]
            )
            
            # 记录当前状态
            trajectory.append(TrajectoryPoint(
                timestamp=t,
                easting=agent.position[0],
                northing=agent.position[1],
                lon=lon,
                lat=lat,
                speed=agent.speed,
                heading=agent.heading,
                acceleration=0.0,  # 将在更新后设置
                turn_rate=0.0      # 将在更新后设置
            ))
            speeds.append(agent.speed)
            
            # 检查是否到达终点
            if np.linalg.norm(agent.position - end_point) < 5.0:  # 5米阈值
                break
                
            # 更新目标点
            if force_path:
                # 强制沿路径运动时，使用路径点作为目标
                while (path_index < len(path_points) and
                       np.linalg.norm(agent.position - np.array(path_points[path_index])) < 5.0):
                    path_index += 1
                    
                if path_index < len(path_points):
                    force_target = np.array(path_points[path_index], dtype=float)
                else:
                    force_target = end_point
            else:
                force_target = None
                
            # 检查是否需要在30秒窗口内更新速度
            if t - last_speed_change_time >= window_size_seconds:
                # 到达30秒窗口边界，获取当前环境并更新目标速度
                environment = self._get_environment_at_position(*agent.position)
                
                # 生成新的目标速度
                new_target_speed = np.random.normal(environment['typical_speed'], environment['speed_stddev'])
                new_target_speed = np.clip(new_target_speed, environment['min_speed'], environment['max_speed'])
                
                # 如果新速度与当前速度差异很大，逐渐调整
                if abs(new_target_speed - agent.speed) > 2.0:
                    # 设置一个中间速度，使变化更加平滑
                    target_speed = agent.speed + np.sign(new_target_speed - agent.speed) * 1.0
                else:
                    target_speed = new_target_speed
                
                # 更新上次速度变化时间
                last_speed_change_time = t
                
            # 更新智能体状态
            agent, acceleration, turn_rate = self._update_agent_state(
                agent,
                dt,
                force_target
            )
            
            # 将加速度和转向率添加到前一个轨迹点
            if len(trajectory) > 0:
                trajectory[-1].acceleration = acceleration
                trajectory[-1].turn_rate = np.rad2deg(turn_rate)
                
            # 更新时间
            t += dt
            
            # 如果模拟时间过长，退出循环
            max_simulation_time = self.config.get('MAX_SIMULATION_TIME', 3600)  # 默认1小时
            if t > max_simulation_time:
                logger.warning(f"模拟达到最大时间限制: {t} 秒")
                break
                
        # 统计和打印速度分布情况
        final_speeds = np.array([point.speed for point in trajectory])
        
        print(f"\n速度分布统计:")
        print(f"平均速度: {np.mean(final_speeds):.2f} m/s")
        print(f"最大速度: {np.max(final_speeds):.2f} m/s")
        print(f"最小速度: {np.min(final_speeds):.2f} m/s")
        print(f"速度标准差: {np.std(final_speeds):.2f} m/s")
        print(f"不同速度值数量: {len(np.unique(final_speeds))}")
        
        # 确保有足够的点计算速度变化
        if len(final_speeds) > 1:
            speed_changes = np.diff(final_speeds)
            print(f"平均速度变化: {np.mean(np.abs(speed_changes)):.2f} m/s")
            print(f"最大速度变化: {np.max(np.abs(speed_changes)):.2f} m/s")
        else:
            print("速度变化统计: 轨迹点数量不足，无法计算速度变化")
        
        return trajectory 
```

### src/core/path/planner.py
```python
"""
路径规划器模块
使用A*算法在成本图上规划最优路径
"""

import numpy as np
import logging
from typing import List, Tuple, Set, Dict, Optional
from queue import PriorityQueue
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class Node:
    """A*搜索节点"""
    row: int
    col: int
    g_cost: float  # 从起点到当前节点的实际成本
    h_cost: float  # 从当前节点到终点的启发式估计成本
    parent: Optional['Node'] = None
    
    @property
    def f_cost(self) -> float:
        """总成本 f(n) = g(n) + h(n)"""
        return self.g_cost + self.h_cost
    
    def __lt__(self, other: 'Node') -> bool:
        """优先队列比较函数"""
        return self.f_cost < other.f_cost

class PathPlanner:
    """A*路径规划器"""
    
    def __init__(self, cost_map: np.ndarray):
        """
        初始化路径规划器
        
        Args:
            cost_map: 成本图，表示每个像素的通行成本
        """
        self.cost_map = cost_map
        self.height, self.width = cost_map.shape
        
    def heuristic(self, node: Node, end: Tuple[int, int]) -> float:
        """
        计算启发式成本（使用欧几里得距离）
        
        Args:
            node: 当前节点
            end: 终点坐标 (row, col)
            
        Returns:
            float: 启发式估计成本
        """
        # 使用欧几里得距离乘以成本图中的最小成本作为启发式
        min_cost = np.min(self.cost_map[self.cost_map > 0])
        return min_cost * np.sqrt(
            (node.row - end[0])**2 + (node.col - end[1])**2
        )
        
    def get_neighbors(self, node: Node) -> List[Tuple[int, int]]:
        """
        获取节点的相邻节点坐标
        
        Args:
            node: 当前节点
            
        Returns:
            List[Tuple[int, int]]: 相邻节点坐标列表
        """
        neighbors = []
        # 8个方向：上、下、左、右、左上、右上、左下、右下
        directions = [
            (-1, 0), (1, 0), (0, -1), (0, 1),
            (-1, -1), (-1, 1), (1, -1), (1, 1)
        ]
        
        for dr, dc in directions:
            new_row = node.row + dr
            new_col = node.col + dc
            
            # 检查边界
            if (0 <= new_row < self.height and 
                0 <= new_col < self.width):
                # 检查是否可通行（成本不为无穷大）
                if self.cost_map[new_row, new_col] < float('inf'):
                    neighbors.append((new_row, new_col))
                    
        return neighbors
        
    def find_path(
            self,
            start: Tuple[int, int],
            end: Tuple[int, int]
        ) -> List[Tuple[int, int]]:
        """
        使用A*算法寻找最优路径
        
        Args:
            start: 起点坐标 (row, col)
            end: 终点坐标 (row, col)
            
        Returns:
            List[Tuple[int, int]]: 路径点列表，从起点到终点
        """
        # 检查起点和终点是否有效
        if (not (0 <= start[0] < self.height and 
                0 <= start[1] < self.width)):
            raise ValueError(f"无效的起点坐标: {start}")
        if (not (0 <= end[0] < self.height and 
                0 <= end[1] < self.width)):
            raise ValueError(f"无效的终点坐标: {end}")
            
        # 检查起点和终点是否可通行
        if self.cost_map[start] == float('inf'):
            raise ValueError(f"起点不可通行: {start}")
        if self.cost_map[end] == float('inf'):
            raise ValueError(f"终点不可通行: {end}")
            
        # 初始化开放列表（优先队列）和关闭列表
        open_list = PriorityQueue()
        closed_set: Set[Tuple[int, int]] = set()
        
        # 创建起点节点
        start_node = Node(
            row=start[0],
            col=start[1],
            g_cost=0,
            h_cost=self.heuristic(Node(start[0], start[1], 0, 0), end)
        )
        
        # 将起点加入开放列表
        open_list.put(start_node)
        node_dict: Dict[Tuple[int, int], Node] = {
            (start[0], start[1]): start_node
        }
        
        # 开始搜索
        while not open_list.empty():
            current = open_list.get()
            
            # 如果到达终点
            if (current.row, current.col) == end:
                # 重建路径
                path = []
                while current:
                    path.append((current.row, current.col))
                    current = current.parent
                return path[::-1]  # 反转路径，从起点到终点
                
            # 将当前节点加入关闭列表
            closed_set.add((current.row, current.col))
            
            # 检查所有相邻节点
            for neighbor_pos in self.get_neighbors(current):
                # 如果节点已在关闭列表中，跳过
                if neighbor_pos in closed_set:
                    continue
                    
                # 计算从起点经过当前节点到相邻节点的成本
                # 对角线移动的成本为√2倍
                is_diagonal = (abs(neighbor_pos[0] - current.row) + 
                             abs(neighbor_pos[1] - current.col)) == 2
                movement_cost = (
                    np.sqrt(2) if is_diagonal else 1
                ) * self.cost_map[neighbor_pos]
                
                new_g_cost = current.g_cost + movement_cost
                
                # 如果是新节点或找到更好的路径
                if (neighbor_pos not in node_dict or 
                    new_g_cost < node_dict[neighbor_pos].g_cost):
                    # 创建新的相邻节点
                    neighbor = Node(
                        row=neighbor_pos[0],
                        col=neighbor_pos[1],
                        g_cost=new_g_cost,
                        h_cost=self.heuristic(
                            Node(neighbor_pos[0], neighbor_pos[1], 0, 0),
                            end
                        ),
                        parent=current
                    )
                    
                    # 更新或添加到开放列表
                    node_dict[neighbor_pos] = neighbor
                    open_list.put(neighbor)
                    
        # 如果没有找到路径
        raise ValueError("未找到可行路径") 
```

### src/core/point_selector.py
```python
 
```

### src/core/terrain/__init__.py
```python
"""
地形模块
包含地形数据的加载、分析和处理功能
"""

from .analyzer import TerrainAnalyzer
from .loader import TerrainLoader

__all__ = [
    'TerrainAnalyzer',
    'TerrainLoader'
]

```

### src/core/terrain/analyzer.py
```python
"""
地形分析模块
用于计算和分析地形属性
"""

import logging
import numpy as np
import rasterio
from pathlib import Path
from typing import Tuple, Optional

from src.utils.config import config

logger = logging.getLogger(__name__)

class TerrainAnalyzer:
    """地形分析器"""
    
    def __init__(self):
        """初始化地形分析器"""
        self.dem_data: Optional[np.ndarray] = None
        self.resolution: Optional[float] = None
        self.slope_magnitude: Optional[np.ndarray] = None
        self.slope_aspect: Optional[np.ndarray] = None
        self.dzdx: Optional[np.ndarray] = None
        self.dzdy: Optional[np.ndarray] = None
    
    def load_dem(self, dem_file: Path) -> None:
        """
        加载DEM数据
        
        Args:
            dem_file: DEM文件路径
        """
        logger.info(f"加载DEM数据: {dem_file}")
        with rasterio.open(dem_file) as src:
            self.dem_data = src.read(1)
            # 获取分辨率（假设x和y方向分辨率相同）
            self.resolution = src.transform[0]
            logger.info(f"DEM分辨率: {self.resolution}米")
    
    def calculate_slope_magnitude(self) -> None:
        """计算坡度大小（度）"""
        if self.dem_data is None:
            raise ValueError("请先加载DEM数据")
        
        logger.info("计算坡度大小...")
        
        # 计算x和y方向的梯度
        self.dzdx, self.dzdy = np.gradient(
            self.dem_data,
            self.resolution
        )
        
        # 计算坡度大小（度）
        self.slope_magnitude = np.degrees(
            np.arctan(
                np.sqrt(
                    np.square(self.dzdx) + 
                    np.square(self.dzdy)
                )
            )
        )
        
        logger.info(
            f"坡度范围: {self.slope_magnitude.min():.2f}° - "
            f"{self.slope_magnitude.max():.2f}°"
        )
    
    def calculate_slope_aspect(self) -> None:
        """计算坡向（度，北为0，顺时针）"""
        if self.dzdx is None or self.dzdy is None:
            self.calculate_slope_magnitude()
        
        logger.info("计算坡向...")
        
        # 计算坡向（弧度）
        aspect_rad = np.arctan2(self.dzdx, self.dzdy)
        
        # 转换为度数并调整为北为0
        self.slope_aspect = np.degrees(aspect_rad)
        self.slope_aspect = 90.0 - self.slope_aspect
        self.slope_aspect[self.slope_aspect < 0] += 360.0
        
        # 处理平坦区域（坡度<1度）
        flat_mask = self.slope_magnitude < 1.0
        self.slope_aspect[flat_mask] = -1
        
        logger.info("坡向计算完成")
    
    def get_terrain_attributes(
            self,
            row: int,
            col: int
        ) -> Tuple[float, float]:
        """
        获取指定位置的地形属性
        
        Args:
            row: 行索引
            col: 列索引
            
        Returns:
            Tuple[float, float]: (坡度大小, 坡向)
        """
        if (self.slope_magnitude is None or 
            self.slope_aspect is None):
            raise ValueError("请先计算坡度和坡向")
        
        return (
            self.slope_magnitude[row, col],
            self.slope_aspect[row, col]
        )
    
    def save_results(self) -> None:
        """保存计算结果"""
        if self.slope_magnitude is None:
            raise ValueError("请先计算坡度")
        
        # 保存坡度
        with rasterio.open(
            config.paths.SLOPE_FILE,
            'w',
            driver='GTiff',
            height=self.slope_magnitude.shape[0],
            width=self.slope_magnitude.shape[1],
            count=1,
            dtype=self.slope_magnitude.dtype,
            crs='+proj=latlong',
            transform=rasterio.transform.from_origin(
                0, 0, self.resolution, self.resolution
            )
        ) as dst:
            dst.write(self.slope_magnitude, 1)
        
        if self.slope_aspect is not None:
            # 保存坡向
            with rasterio.open(
                config.paths.ASPECT_FILE,
                'w',
                driver='GTiff',
                height=self.slope_aspect.shape[0],
                width=self.slope_aspect.shape[1],
                count=1,
                dtype=self.slope_aspect.dtype,
                crs='+proj=latlong',
                transform=rasterio.transform.from_origin(
                    0, 0, self.resolution, self.resolution
                )
            ) as dst:
                dst.write(self.slope_aspect, 1)
        
        logger.info("地形分析结果已保存") 
```

### src/core/terrain/loader.py
```python
"""
地形加载器模块
用于加载和管理地形数据
"""

import logging
import numpy as np
import rasterio
from pathlib import Path
from typing import Tuple, Dict, Optional, Any
import pyproj
from rasterio.crs import CRS

from src.utils.config import config

logger = logging.getLogger(__name__)

class TerrainLoader:
    """地形数据加载器"""
    
    def __init__(self):
        """初始化地形加载器"""
        self.dem_data: Optional[np.ndarray] = None
        self.landcover_data: Optional[np.ndarray] = None
        self.slope_data: Optional[np.ndarray] = None
        self.aspect_data: Optional[np.ndarray] = None
        self.resolution: Optional[float] = None  # 栅格分辨率（米）
        self.transform: Optional[Any] = None
        self.crs: Optional[CRS] = None
        self.utm_proj: Optional[pyproj.Proj] = None
        self.wgs84_proj: Optional[pyproj.Proj] = None
        self.transformer: Optional[pyproj.Transformer] = None
        self.utm_origin: Optional[Tuple[float, float]] = None  # UTM坐标系原点（左上角）
        
    def load_dem(self, dem_file: Path) -> None:
        """
        加载DEM数据
        
        Args:
            dem_file: DEM文件路径
        """
        logger.info(f"加载DEM数据: {dem_file}")
        with rasterio.open(dem_file) as src:
            self.dem_data = src.read(1)
            self.transform = src.transform
            self.crs = src.crs
            
            # 获取数据中心点的经纬度
            center_lon = (src.bounds.left + src.bounds.right) / 2
            center_lat = (src.bounds.bottom + src.bounds.top) / 2
            
            # 确定UTM区域
            utm_zone = int((center_lon + 180) / 6) + 1
            hemisphere = 'north' if center_lat >= 0 else 'south'
            
            # 创建投影转换器
            self.wgs84_proj = pyproj.Proj('epsg:4326')  # WGS84
            self.utm_proj = pyproj.Proj(
                f'+proj=utm +zone={utm_zone} +{hemisphere} +datum=WGS84'
            )
            self.transformer = pyproj.Transformer.from_proj(
                self.wgs84_proj,
                self.utm_proj,
                always_xy=True
            )
            
            # 计算左上角的UTM坐标作为原点
            self.utm_origin = self.transformer.transform(
                src.bounds.left,
                src.bounds.top
            )
            
            # 设置栅格分辨率（米）
            self.resolution = 30.0
            
            logger.info(f"DEM分辨率: {self.resolution}米")
            logger.info(
                f"坐标系统: WGS84 -> UTM Zone {utm_zone} "
                f"{'North' if hemisphere == 'north' else 'South'}"
            )
            
            # 计算坡度和坡向
            self._calculate_slope_aspect()
            
    def _calculate_slope_aspect(self) -> None:
        """计算坡度和坡向"""
        if self.dem_data is None:
            raise ValueError("未加载DEM数据")
            
        # 计算x和y方向的梯度
        dy, dx = np.gradient(self.dem_data, self.resolution)
        
        # 计算坡度（度）
        slope_rad = np.arctan(np.sqrt(dx*dx + dy*dy))
        self.slope_data = np.degrees(slope_rad)
        
        # 计算坡向（度）
        aspect_rad = np.arctan2(dy, dx)
        self.aspect_data = np.degrees(aspect_rad)
        self.aspect_data[self.aspect_data < 0] += 360
            
    def load_landcover(self, landcover_file: Path) -> None:
        """
        加载土地覆盖数据
        
        Args:
            landcover_file: 土地覆盖文件路径
        """
        logger.info(f"加载土地覆盖数据: {landcover_file}")
        with rasterio.open(landcover_file) as src:
            self.landcover_data = src.read(1)
            
    def load_slope(self, slope_file: Path) -> None:
        """
        加载坡度数据
        
        Args:
            slope_file: 坡度文件路径
        """
        logger.info(f"加载坡度数据: {slope_file}")
        with rasterio.open(slope_file) as src:
            self.slope_data = src.read(1)
            
    def load_aspect(self, aspect_file: Path) -> None:
        """
        加载坡向数据
        
        Args:
            aspect_file: 坡向文件路径
        """
        logger.info(f"加载坡向数据: {aspect_file}")
        with rasterio.open(aspect_file) as src:
            self.aspect_data = src.read(1)
            
    def lonlat_to_utm(self, lon: float, lat: float) -> Tuple[float, float]:
        """
        将经纬度坐标转换为UTM坐标（米）
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            Tuple[float, float]: (easting, northing) UTM坐标（米）
        """
        if self.transformer is None:
            raise ValueError("未初始化坐标转换器")
        return self.transformer.transform(lon, lat)
        
    def utm_to_lonlat(self, easting: float, northing: float) -> Tuple[float, float]:
        """
        将UTM坐标（米）转换为经纬度坐标
        
        Args:
            easting: UTM东坐标（米）
            northing: UTM北坐标（米）
            
        Returns:
            Tuple[float, float]: (经度, 纬度)
        """
        if self.transformer is None:
            raise ValueError("未初始化坐标转换器")
        return self.transformer.transform(easting, northing, direction='INVERSE')
        
    def utm_to_pixel(self, easting: float, northing: float) -> Tuple[int, int]:
        """
        将UTM坐标（米）转换为栅格坐标
        
        Args:
            easting: UTM东坐标（米）
            northing: UTM北坐标（米）
            
        Returns:
            Tuple[int, int]: (行号, 列号)
        """
        if self.utm_origin is None:
            raise ValueError("未初始化UTM原点")
            
        # 计算相对于原点的偏移（米）
        dx = easting - self.utm_origin[0]
        dy = self.utm_origin[1] - northing  # 北向坐标需要反转
        
        # 转换为栅格坐标
        col = int(dx / self.resolution)
        row = int(dy / self.resolution)
        
        return row, col
        
    def pixel_to_utm(self, row: int, col: int) -> Tuple[float, float]:
        """
        将栅格坐标转换为UTM坐标（米）
        
        Args:
            row: 行号
            col: 列号
            
        Returns:
            Tuple[float, float]: (easting, northing) UTM坐标（米）
        """
        if self.utm_origin is None:
            raise ValueError("未初始化UTM原点")
            
        # 计算UTM坐标
        easting = self.utm_origin[0] + col * self.resolution
        northing = self.utm_origin[1] - row * self.resolution
        
        return easting, northing
        
    def get_terrain_attributes(
            self,
            easting: float,
            northing: float
        ) -> Dict[str, float]:
        """
        获取指定UTM坐标位置的地形属性
        
        Args:
            easting: UTM东坐标（米）
            northing: UTM北坐标（米）
            
        Returns:
            Dict[str, float]: 地形属性字典
        """
        # 转换为栅格坐标
        row, col = self.utm_to_pixel(easting, northing)
        
        # 检查坐标是否在范围内
        if not (0 <= row < self.dem_data.shape[0] and 0 <= col < self.dem_data.shape[1]):
            return {}
            
        attributes = {}
        
        if self.dem_data is not None:
            attributes['elevation'] = float(self.dem_data[row, col])
            
        if self.landcover_data is not None:
            attributes['landcover'] = int(self.landcover_data[row, col])
            
        if self.slope_data is not None:
            attributes['slope'] = float(self.slope_data[row, col])
            
        if self.aspect_data is not None:
            attributes['aspect'] = float(self.aspect_data[row, col])
            
        return attributes
        
    def lonlat_to_pixel(
            self,
            lon: float,
            lat: float
        ) -> Tuple[int, int]:
        """
        将经纬度坐标转换为像素索引
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            Tuple[int, int]: (行索引, 列索引)
        """
        if self.transform is None:
            raise ValueError("请先加载DEM数据")
            
        # 使用仿射变换转换为像素坐标
        col, row = ~self.transform * (lon, lat)
        return int(row), int(col)
        
    def pixel_to_lonlat(
            self,
            row: int,
            col: int
        ) -> Tuple[float, float]:
        """
        将像素索引转换为经纬度坐标
        
        Args:
            row: 行索引
            col: 列索引
            
        Returns:
            Tuple[float, float]: (经度, 纬度)
        """
        if self.transform is None:
            raise ValueError("请先加载DEM数据")
            
        # 使用仿射变换转换为经纬度
        lon, lat = self.transform * (col, row)
        return lon, lat
        
    def is_valid_pixel(
            self,
            row: int,
            col: int
        ) -> bool:
        """
        检查像素坐标是否有效
        
        Args:
            row: 行索引
            col: 列索引
            
        Returns:
            bool: 是否有效
        """
        if self.dem_data is None:
            raise ValueError("未加载地形数据")
            
        height, width = self.dem_data.shape
        return (0 <= row < height and 
                0 <= col < width)
                
    def is_passable(
            self,
            row: int,
            col: int
        ) -> bool:
        """
        检查指定位置是否可通行
        
        Args:
            row: 行索引
            col: 列索引
            
        Returns:
            bool: 是否可通行
        """
        if not self.is_valid_pixel(row, col):
            return False
            
        if self.landcover_data is not None:
            landcover = self.landcover_data[row, col]
            if landcover in config['terrain']['IMPASSABLE_LANDCOVER_CODES']:
                return False
                
        if self.slope_data is not None:
            slope = self.slope_data[row, col]
            if slope > config['motion']['MAX_SLOPE_DEGREES']:
                return False
                
        return True 

def convert_to_pixel_coords(
    coords: np.ndarray,
    transform: Any
) -> np.ndarray:
    """
    将经纬度坐标转换为像素坐标

    Args:
        coords: 形状为(N, 2)的数组，每行包含[longitude, latitude]
        transform: rasterio的仿射变换矩阵

    Returns:
        np.ndarray: 形状为(N, 2)的数组，每行包含[row, col]
    """
    # 使用仿射变换矩阵进行转换
    cols = (coords[:, 0] - transform[2]) / transform[0]
    rows = (coords[:, 1] - transform[5]) / transform[4]
    
    # 将结果组合为(N, 2)数组
    return np.column_stack([rows, cols])

def convert_to_lonlat(
    pixel_coords: np.ndarray,
    transform: Any
) -> np.ndarray:
    """
    将像素坐标转换为经纬度坐标

    Args:
        pixel_coords: 形状为(N, 2)的数组，每行包含[row, col]
        transform: rasterio的仿射变换矩阵

    Returns:
        np.ndarray: 形状为(N, 2)的数组，每行包含[longitude, latitude]
    """
    # 使用仿射变换矩阵进行转换
    lons = transform[0] * pixel_coords[:, 1] + transform[2]
    lats = transform[4] * pixel_coords[:, 0] + transform[5]
    
    # 将结果组合为(N, 2)数组
    return np.column_stack([lons, lats]) 
```

### src/core/trajectory/__init__.py
```python
"""
轨迹模块
包含轨迹生成和处理相关功能
"""

from .generator import TrajectoryGenerator
from .environment_based import EnvironmentBasedGenerator

__all__ = [
    'TrajectoryGenerator',
    'EnvironmentBasedGenerator'
] 
```

### src/core/trajectory/environment_based.py
```python
"""
基于环境的轨迹生成器
考虑地形和环境约束生成轨迹
"""

import logging
import numpy as np
from typing import List, Dict, Tuple

from src.utils.config import config
from src.core.terrain import TerrainLoader
from .generator import TrajectoryGenerator

logger = logging.getLogger(__name__)

class EnvironmentBasedGenerator(TrajectoryGenerator):
    """基于环境的轨迹生成器"""
    
    def __init__(
            self,
            terrain_loader: TerrainLoader,
            dt: float = config.motion.DT,
            max_waypoints: int = 10,
            min_waypoint_dist: float = 1000.0,
            max_waypoint_dist: float = 5000.0
        ):
        """
        初始化生成器
        
        Args:
            terrain_loader: 地形数据加载器
            dt: 时间步长（秒）
            max_waypoints: 最大路径点数
            min_waypoint_dist: 最小路径点间距（米）
            max_waypoint_dist: 最大路径点间距（米）
        """
        super().__init__(terrain_loader, dt)
        self.max_waypoints = max_waypoints
        self.min_waypoint_dist = min_waypoint_dist
        self.max_waypoint_dist = max_waypoint_dist
        
    def generate_trajectory(
            self,
            start_point: Tuple[float, float],
            end_point: Tuple[float, float]
        ) -> Dict[str, List[float]]:
        """
        生成轨迹
        
        Args:
            start_point: 起点坐标 (x, y)
            end_point: 终点坐标 (x, y)
            
        Returns:
            Dict[str, List[float]]: 轨迹数据
        """
        # 生成路径点
        waypoints = self._generate_waypoints(start_point, end_point)
        logger.info(f"生成{len(waypoints)}个路径点")
        
        # 插值生成轨迹点
        x, y = self._interpolate_path(waypoints)
        logger.info(f"插值得到{len(x)}个轨迹点")
        
        # 计算速度和朝向
        speeds = self._calculate_speeds(x, y)
        orientations = self._calculate_orientations(x, y)
        
        # 计算时间戳
        dx = np.diff(x)
        dy = np.diff(y)
        distances = np.sqrt(dx**2 + dy**2)
        timestamps = self._calculate_timestamps(distances, speeds)
        
        return {
            'timestamp': timestamps.tolist(),
            'x': x.tolist(),
            'y': y.tolist(),
            'speed': speeds.tolist(),
            'orientation': orientations.tolist()
        }
        
    def _generate_waypoints(
            self,
            start_point: Tuple[float, float],
            end_point: Tuple[float, float]
        ) -> List[Tuple[float, float]]:
        """
        生成路径点
        
        Args:
            start_point: 起点坐标 (x, y)
            end_point: 终点坐标 (x, y)
            
        Returns:
            List[Tuple[float, float]]: 路径点列表
        """
        waypoints = [start_point]
        current_point = start_point
        
        # 计算起终点直线距离
        dx = end_point[0] - start_point[0]
        dy = end_point[1] - start_point[1]
        total_dist = np.sqrt(dx**2 + dy**2)
        
        # 确保总距离满足最小要求（80km）
        if total_dist < config.generation.MIN_START_END_DISTANCE:
            raise ValueError(
                f"起终点直线距离（{total_dist/1000:.1f}km）小于最小要求"
                f"（{config.generation.MIN_START_END_DISTANCE/1000:.1f}km）"
            )
        
        # 生成中间路径点
        while len(waypoints) < self.max_waypoints:
            # 计算到终点的剩余距离
            dx = end_point[0] - current_point[0]
            dy = end_point[1] - current_point[1]
            dist_to_end = np.sqrt(dx**2 + dy**2)
            
            # 如果已经足够接近终点，直接添加终点
            if dist_to_end <= self.max_waypoint_dist:
                waypoints.append(end_point)
                break
            
            # 生成新的路径点
            for _ in range(50):  # 最多尝试50次
                # 在当前点附近随机选择一个方向和距离
                angle = np.random.uniform(0, 2 * np.pi)
                dist = np.random.uniform(
                    self.min_waypoint_dist,
                    self.max_waypoint_dist
                )
                
                # 计算新点坐标
                new_x = current_point[0] + dist * np.cos(angle)
                new_y = current_point[1] + dist * np.sin(angle)
                
                # 转换为像素坐标
                row, col = self.terrain_loader.coord_to_pixel(new_x, new_y)
                
                # 检查新点是否可通行
                if not self.terrain_loader.is_valid_pixel(row, col):
                    continue
                    
                if not self.terrain_loader.is_passable(row, col):
                    continue
                
                # 检查新点是否朝向终点（夹角不超过90度）
                dx_new = end_point[0] - new_x
                dy_new = end_point[1] - new_y
                dist_new_to_end = np.sqrt(dx_new**2 + dy_new**2)
                
                # 计算前进方向与终点方向的夹角
                dot_product = dx_new * np.cos(angle) + dy_new * np.sin(angle)
                angle_to_end = np.arccos(
                    dot_product / (dist_new_to_end * dist)
                )
                
                if angle_to_end > np.pi/2:  # 夹角不超过90度
                    continue
                
                # 接受新点
                current_point = (new_x, new_y)
                waypoints.append(current_point)
                break
            else:
                # 如果50次尝试都失败，直接添加终点
                waypoints.append(end_point)
                break
        
        # 如果还没有添加终点，添加终点
        if waypoints[-1] != end_point:
            waypoints.append(end_point)
        
        return waypoints 
```

### src/core/trajectory/generator.py
```python
"""
轨迹生成器模块
整合路径规划和运动模拟，生成完整轨迹
"""

import numpy as np
import logging
from pathlib import Path
from typing import List, Tuple, Dict, Optional
import json

from src.core.path.planner import PathPlanner
from src.core.motion.simulator import MotionSimulator, EnvironmentMaps, TrajectoryPoint
from src.core.terrain.loader import TerrainLoader
from src.utils.config import config

logger = logging.getLogger(__name__)

class TrajectoryGenerator:
    """轨迹生成器"""
    
    def __init__(
            self,
            terrain_loader: TerrainLoader,
            config: Dict
        ):
        """
        初始化轨迹生成器
        
        Args:
            terrain_loader: 地形加载器实例
            config: 配置参数字典
        """
        self.terrain_loader = terrain_loader
        self.config = config
        
        # 生成成本图
        self.cost_map = self._generate_cost_map()
        
        # 初始化路径规划器
        self.path_planner = PathPlanner(self.cost_map)
        
        # 初始化运动模拟器
        self.motion_simulator = MotionSimulator(
            env_maps=self._prepare_environment_maps(),
            terrain_loader=terrain_loader,
            config=config
        )
        
    def _generate_cost_map(self) -> np.ndarray:
        """
        生成成本图
        
        Returns:
            np.ndarray: 成本图
        """
        # 获取地图尺寸
        height, width = self.terrain_loader.dem_data.shape
        cost_map = np.ones((height, width), dtype=np.float32)
        
        # 设置不可通行区域的成本为无穷大
        for row in range(height):
            for col in range(width):
                if not self.terrain_loader.is_passable(row, col):
                    cost_map[row, col] = float('inf')
                    continue
                    
                # 获取地形属性
                attrs = self.terrain_loader.get_terrain_attributes(row, col)
                
                # 基础成本（与典型速度成反比）
                if 'typical_speed' in attrs:
                    cost_map[row, col] = 1.0 / max(
                        attrs['typical_speed'],
                        self.config['motion']['MIN_SPEED']
                    )
                    
                # 坡度影响
                if 'slope' in attrs:
                    slope_factor = 1.0 + (
                        attrs['slope'] / 
                        self.config['motion']['MAX_SLOPE_DEGREES']
                    )
                    cost_map[row, col] *= slope_factor
                    
        return cost_map
        
    def _prepare_environment_maps(self) -> EnvironmentMaps:
        """
        准备环境地图集合
        
        Returns:
            EnvironmentMaps: 环境地图集合
        """
        # 获取地图尺寸
        height, width = self.terrain_loader.dem_data.shape
        
        # 创建典型速度图（基于坡度和土地覆盖类型）
        typical_speed = np.full(
            (height, width),
            self.config['motion']['DEFAULT_SPEED']
        )
        
        # 创建最大速度图
        max_speed = np.full(
            (height, width),
            self.config['motion']['MAX_SPEED']
        )
        
        # 创建速度标准差图（可以基于地形复杂度调整）
        speed_stddev = np.full(
            (height, width),
            self.config['motion']['SPEED_STDDEV']
        )
        
        # 对每个像素计算实际速度限制
        for row in range(height):
            for col in range(width):
                attrs = self.terrain_loader.get_terrain_attributes(row, col)
                
                # 坡度影响
                if 'slope' in attrs:
                    slope_factor = 1.0 - (
                        attrs['slope'] / 
                        self.config['motion']['MAX_SLOPE_DEGREES']
                    )
                    typical_speed[row, col] *= max(0.1, slope_factor)
                    max_speed[row, col] *= max(0.1, slope_factor)
                    
                # 土地覆盖类型影响
                if ('landcover' in attrs and 
                    attrs['landcover'] in self.config['terrain']['SPEED_FACTORS']):
                    landcover_factor = self.config['terrain']['SPEED_FACTORS'][
                        attrs['landcover']
                    ]
                    typical_speed[row, col] *= landcover_factor
                    max_speed[row, col] *= landcover_factor
                    
                # 确保速度不低于最小值
                typical_speed[row, col] = max(
                    typical_speed[row, col],
                    self.config['motion']['MIN_SPEED']
                )
                max_speed[row, col] = max(
                    max_speed[row, col],
                    self.config['motion']['MIN_SPEED']
                )
                
        return EnvironmentMaps(
            typical_speed=typical_speed,
            max_speed=max_speed,
            speed_stddev=speed_stddev,
            slope_magnitude=self.terrain_loader.slope_data,
            slope_aspect=self.terrain_loader.aspect_data,
            landcover=self.terrain_loader.landcover_data
        )
        
    def generate_trajectory(
            self,
            start_point: Tuple[float, float],
            end_point: Tuple[float, float],
            output_file: Optional[Path] = None
        ) -> List[TrajectoryPoint]:
        """
        生成轨迹
        
        Args:
            start_point: 起点坐标 (经度, 纬度)
            end_point: 终点坐标 (经度, 纬度)
            output_file: 输出文件路径
            
        Returns:
            List[TrajectoryPoint]: 轨迹点列表
        """
        logger.info(f"开始生成轨迹: {start_point} -> {end_point}")
        
        # 将经纬度转换为UTM坐标
        start_utm = self.terrain_loader.lonlat_to_utm(*start_point)
        end_utm = self.terrain_loader.lonlat_to_utm(*end_point)
        
        # 将UTM坐标转换为像素坐标
        start_pixel = self.terrain_loader.coord_to_pixel(*start_utm)
        end_pixel = self.terrain_loader.coord_to_pixel(*end_utm)
        
        # 使用A*规划路径
        logger.info("使用A*算法规划路径...")
        path = self.path_planner.find_path(start_pixel, end_pixel)
        
        # 使用运动模拟器生成轨迹
        logger.info("使用运动模拟器生成轨迹...")
        trajectory = self.motion_simulator.simulate_motion(path)
        
        # 保存轨迹
        if output_file:
            self._save_trajectory(trajectory, output_file)
            
        return trajectory
        
    def _save_trajectory(
            self,
            trajectory: List[TrajectoryPoint],
            output_file: Path
        ) -> None:
        """
        保存轨迹到文件
        
        Args:
            trajectory: 轨迹点列表
            output_file: 输出文件路径
        """
        # 创建输出目录
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        # 转换轨迹点为字典列表
        trajectory_data = []
        for point in trajectory:
            # 将像素坐标转换为UTM坐标
            utm_coord = self.terrain_loader.pixel_to_coord(
                point.row, point.col
            )
            # 将UTM坐标转换为经纬度
            lon, lat = self.terrain_loader.utm_to_lonlat(*utm_coord)
            
            trajectory_data.append({
                'timestamp': point.timestamp,
                'longitude': lon,
                'latitude': lat,
                'speed': point.speed,
                'heading': point.heading
            })
            
        # 保存为JSON文件
        with open(output_file, 'w') as f:
            json.dump({
                'trajectory': trajectory_data,
                'metadata': {
                    'total_time': trajectory[-1].timestamp,
                    'total_distance': sum(
                        point.speed * 0.1  # dt = 0.1
                        for point in trajectory[:-1]
                    ),
                    'average_speed': np.mean([
                        point.speed for point in trajectory
                    ])
                }
            }, f, indent=2) 
```

### src/core/validation/validator.py
```python
"""
轨迹验证器模块
实现真实轨迹和模拟轨迹的对比分析
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from scipy import stats
from scipy.interpolate import interp1d

from src.core.motion.simulator import TrajectoryPoint
from src.utils.visualization import plot_trajectory_on_map
from src.core.terrain.loader import convert_to_pixel_coords, TerrainLoader

@dataclass
class ValidationMetrics:
    """验证指标"""
    # 速度相关
    speed_rmse: float
    speed_correlation: float
    speed_ks_statistic: float
    speed_ks_pvalue: float
    
    # 加速度相关
    accel_rmse: float
    accel_correlation: float
    accel_ks_statistic: float
    accel_ks_pvalue: float
    
    # 转向率相关
    turn_rate_rmse: float
    turn_rate_correlation: float
    turn_rate_ks_statistic: float
    turn_rate_ks_pvalue: float
    
    # 全局指标
    total_time_diff: float  # 总时间差异（秒）
    total_distance_diff: float  # 总距离差异（米）
    avg_speed_diff: float  # 平均速度差异（米/秒）

class TrajectoryValidator:
    """轨迹验证器"""
    
    def __init__(self, output_dir: Path):
        """
        初始化验证器
        
        Args:
            output_dir: 输出目录，用于保存验证结果和图表
        """
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
    def _interpolate_trajectory(
            self,
            trajectory: pd.DataFrame,
            target_timestamps: np.ndarray
        ) -> pd.DataFrame:
        """
        将轨迹插值到目标时间点
        
        Args:
            trajectory: 轨迹数据框
            target_timestamps: 目标时间点数组
            
        Returns:
            pd.DataFrame: 插值后的轨迹数据框
        """
        # 创建插值器
        interp_speed = interp1d(
            trajectory['timestamp'],
            trajectory['speed_mps'],
            kind='linear',
            bounds_error=False,
            fill_value='extrapolate'
        )
        interp_accel = interp1d(
            trajectory['timestamp'],
            trajectory['acceleration_mps2'],
            kind='linear',
            bounds_error=False,
            fill_value='extrapolate'
        )
        interp_turn_rate = interp1d(
            trajectory['timestamp'],
            trajectory['turn_rate_dps'],
            kind='linear',
            bounds_error=False,
            fill_value='extrapolate'
        )
        
        # 执行插值
        return pd.DataFrame({
            'timestamp': target_timestamps,
            'speed_mps': interp_speed(target_timestamps),
            'acceleration_mps2': interp_accel(target_timestamps),
            'turn_rate_dps': interp_turn_rate(target_timestamps)
        })
        
    def _calculate_metrics(
            self,
            real_df: pd.DataFrame,
            sim_df: pd.DataFrame
        ) -> ValidationMetrics:
        """
        计算验证指标
        
        Args:
            real_df: 真实轨迹数据框
            sim_df: 模拟轨迹数据框
            
        Returns:
            ValidationMetrics: 验证指标
        """
        # 速度指标
        speed_rmse = np.sqrt(np.mean(
            (real_df['speed_mps'] - sim_df['speed_mps'])**2
        ))
        speed_corr = np.corrcoef(
            real_df['speed_mps'],
            sim_df['speed_mps']
        )[0, 1]
        speed_ks = stats.ks_2samp(
            real_df['speed_mps'],
            sim_df['speed_mps']
        )
        
        # 加速度指标
        accel_rmse = np.sqrt(np.mean(
            (real_df['acceleration_mps2'] - 
             sim_df['acceleration_mps2'])**2
        ))
        accel_corr = np.corrcoef(
            real_df['acceleration_mps2'],
            sim_df['acceleration_mps2']
        )[0, 1]
        accel_ks = stats.ks_2samp(
            real_df['acceleration_mps2'],
            sim_df['acceleration_mps2']
        )
        
        # 转向率指标
        turn_rate_rmse = np.sqrt(np.mean(
            (real_df['turn_rate_dps'] - 
             sim_df['turn_rate_dps'])**2
        ))
        turn_rate_corr = np.corrcoef(
            real_df['turn_rate_dps'],
            sim_df['turn_rate_dps']
        )[0, 1]
        turn_rate_ks = stats.ks_2samp(
            real_df['turn_rate_dps'],
            sim_df['turn_rate_dps']
        )
        
        # 全局指标
        total_time_diff = (
            sim_df['timestamp'].max() - 
            real_df['timestamp'].max()
        )
        
        total_distance_diff = (
            np.sum(sim_df['speed_mps'] * 0.1) -  # dt = 0.1
            np.sum(real_df['speed_mps'] * 0.1)
        )
        
        avg_speed_diff = (
            sim_df['speed_mps'].mean() - 
            real_df['speed_mps'].mean()
        )
        
        return ValidationMetrics(
            speed_rmse=speed_rmse,
            speed_correlation=speed_corr,
            speed_ks_statistic=speed_ks.statistic,
            speed_ks_pvalue=speed_ks.pvalue,
            
            accel_rmse=accel_rmse,
            accel_correlation=accel_corr,
            accel_ks_statistic=accel_ks.statistic,
            accel_ks_pvalue=accel_ks.pvalue,
            
            turn_rate_rmse=turn_rate_rmse,
            turn_rate_correlation=turn_rate_corr,
            turn_rate_ks_statistic=turn_rate_ks.statistic,
            turn_rate_ks_pvalue=turn_rate_ks.pvalue,
            
            total_time_diff=total_time_diff,
            total_distance_diff=total_distance_diff,
            avg_speed_diff=avg_speed_diff
        )
        
    def _plot_time_series(
            self,
            real_df: pd.DataFrame,
            sim_df: pd.DataFrame,
            output_prefix: str
        ) -> None:
        """
        绘制时间序列对比图
        
        Args:
            real_df: 真实轨迹数据框
            sim_df: 模拟轨迹数据框
            output_prefix: 输出文件前缀
        """
        # 速度对比图
        plt.figure(figsize=(12, 6))
        plt.plot(
            real_df['timestamp'],
            real_df['speed_mps'],
            'b-',
            label='真实轨迹'
        )
        plt.plot(
            sim_df['timestamp'],
            sim_df['speed_mps'],
            'r--',
            label='模拟轨迹'
        )
        plt.xlabel('时间 (秒)')
        plt.ylabel('速度 (米/秒)')
        plt.title('速度随时间变化对比')
        plt.legend()
        plt.grid(True)
        plt.savefig(
            self.output_dir / f'{output_prefix}_speed.png'
        )
        plt.close()
        
        # 加速度对比图
        plt.figure(figsize=(12, 6))
        plt.plot(
            real_df['timestamp'],
            real_df['acceleration_mps2'],
            'b-',
            label='真实轨迹'
        )
        plt.plot(
            sim_df['timestamp'],
            sim_df['acceleration_mps2'],
            'r--',
            label='模拟轨迹'
        )
        plt.xlabel('时间 (秒)')
        plt.ylabel('加速度 (米/秒²)')
        plt.title('加速度随时间变化对比')
        plt.legend()
        plt.grid(True)
        plt.savefig(
            self.output_dir / f'{output_prefix}_acceleration.png'
        )
        plt.close()
        
        # 转向率对比图
        plt.figure(figsize=(12, 6))
        plt.plot(
            real_df['timestamp'],
            real_df['turn_rate_dps'],
            'b-',
            label='真实轨迹'
        )
        plt.plot(
            sim_df['timestamp'],
            sim_df['turn_rate_dps'],
            'r--',
            label='模拟轨迹'
        )
        plt.xlabel('时间 (秒)')
        plt.ylabel('转向率 (度/秒)')
        plt.title('转向率随时间变化对比')
        plt.legend()
        plt.grid(True)
        plt.savefig(
            self.output_dir / f'{output_prefix}_turn_rate.png'
        )
        plt.close()
        
    def _plot_distributions(
            self,
            real_df: pd.DataFrame,
            sim_df: pd.DataFrame,
            output_prefix: str
        ) -> None:
        """
        绘制分布对比图
        
        Args:
            real_df: 真实轨迹数据框
            sim_df: 模拟轨迹数据框
            output_prefix: 输出文件前缀
        """
        # 速度分布
        plt.figure(figsize=(10, 6))
        plt.hist(
            real_df['speed_mps'],
            bins=30,
            alpha=0.5,
            density=True,
            label='真实轨迹'
        )
        plt.hist(
            sim_df['speed_mps'],
            bins=30,
            alpha=0.5,
            density=True,
            label='模拟轨迹'
        )
        plt.xlabel('速度 (米/秒)')
        plt.ylabel('密度')
        plt.title('速度分布对比')
        plt.legend()
        plt.grid(True)
        plt.savefig(
            self.output_dir / f'{output_prefix}_speed_dist.png'
        )
        plt.close()
        
        # 加速度分布
        plt.figure(figsize=(10, 6))
        plt.hist(
            real_df['acceleration_mps2'],
            bins=30,
            alpha=0.5,
            density=True,
            label='真实轨迹'
        )
        plt.hist(
            sim_df['acceleration_mps2'],
            bins=30,
            alpha=0.5,
            density=True,
            label='模拟轨迹'
        )
        plt.xlabel('加速度 (米/秒²)')
        plt.ylabel('密度')
        plt.title('加速度分布对比')
        plt.legend()
        plt.grid(True)
        plt.savefig(
            self.output_dir / f'{output_prefix}_acceleration_dist.png'
        )
        plt.close()
        
        # 转向率分布
        plt.figure(figsize=(10, 6))
        plt.hist(
            real_df['turn_rate_dps'],
            bins=30,
            alpha=0.5,
            density=True,
            label='真实轨迹'
        )
        plt.hist(
            sim_df['turn_rate_dps'],
            bins=30,
            alpha=0.5,
            density=True,
            label='模拟轨迹'
        )
        plt.xlabel('转向率 (度/秒)')
        plt.ylabel('密度')
        plt.title('转向率分布对比')
        plt.legend()
        plt.grid(True)
        plt.savefig(
            self.output_dir / f'{output_prefix}_turn_rate_dist.png'
        )
        plt.close()
        
    def validate_trajectory(
            self,
            real_trajectory: pd.DataFrame,
            sim_trajectory: List[TrajectoryPoint],
            dem_data: Optional[TerrainLoader] = None,
            output_prefix: str = 'validation'
        ) -> ValidationMetrics:
        """验证模拟轨迹与真实轨迹的差异。

        Args:
            real_trajectory: 真实轨迹数据，包含timestamp、longitude、latitude、speed_mps等列
            sim_trajectory: 模拟轨迹点列表
            dem_data: 地形加载器对象，用于绘制轨迹叠加图
            output_prefix: 输出文件前缀

        Returns:
            ValidationMetrics: 验证指标
        """
        # 将模拟轨迹转换为DataFrame
        sim_df = pd.DataFrame([
            {
                'timestamp': p.timestamp,
                'longitude': p.lon,
                'latitude': p.lat,
                'speed_mps': p.speed,
                'acceleration_mps2': p.acceleration,
                'turn_rate_dps': p.turn_rate
            }
            for p in sim_trajectory
        ])

        # 将经纬度转换为行列坐标
        if dem_data is not None:
            real_coords = convert_to_pixel_coords(
                real_trajectory[['longitude', 'latitude']].values,
                dem_data.transform
            )
            sim_coords = convert_to_pixel_coords(
                sim_df[['longitude', 'latitude']].values,
                dem_data.transform
            )
            real_trajectory['row'] = real_coords[:, 0]
            real_trajectory['col'] = real_coords[:, 1]
            sim_df['row'] = sim_coords[:, 0]
            sim_df['col'] = sim_coords[:, 1]

        # 对齐时间戳
        target_timestamps = np.union1d(
            real_trajectory['timestamp'].values,
            sim_df['timestamp'].values
        )
        real_interp = self._interpolate_trajectory(real_trajectory, target_timestamps)
        sim_interp = self._interpolate_trajectory(sim_df, target_timestamps)
        
        # 计算验证指标
        metrics = self._calculate_metrics(real_interp, sim_interp)
        
        # 绘制对比图
        self._plot_time_series(real_interp, sim_interp, output_prefix)
        self._plot_distributions(real_interp, sim_interp, output_prefix)
        
        # 如果提供了DEM数据，绘制轨迹叠加图
        if dem_data is not None:
            plot_trajectory_on_map(
                dem_data.dem_data,
                real_trajectory[['row', 'col']].values,
                sim_df[['row', 'col']].values,
                self.output_dir / f'{output_prefix}_map.png'
            )
            
        # 保存验证指标
        metrics_dict = {
            'speed': {
                'rmse': metrics.speed_rmse,
                'correlation': metrics.speed_correlation,
                'ks_statistic': metrics.speed_ks_statistic,
                'ks_pvalue': metrics.speed_ks_pvalue
            },
            'acceleration': {
                'rmse': metrics.accel_rmse,
                'correlation': metrics.accel_correlation,
                'ks_statistic': metrics.accel_ks_statistic,
                'ks_pvalue': metrics.accel_ks_pvalue
            },
            'turn_rate': {
                'rmse': metrics.turn_rate_rmse,
                'correlation': metrics.turn_rate_correlation,
                'ks_statistic': metrics.turn_rate_ks_statistic,
                'ks_pvalue': metrics.turn_rate_ks_pvalue
            },
            'global': {
                'total_time_diff': metrics.total_time_diff,
                'total_distance_diff': metrics.total_distance_diff,
                'avg_speed_diff': metrics.avg_speed_diff
            }
        }
        
        with open(
            self.output_dir / f'{output_prefix}_metrics.json', 'w'
        ) as f:
            import json
            json.dump(metrics_dict, f, indent=2)
            
        return metrics 
```

### src/data_processing/__init__.py
```python
"""
数据处理模块
包含地形数据加载、地形分析和OORD数据处理功能
"""

from .terrain_loader import TerrainLoader
from .terrain_analyzer import TerrainAnalyzer
from .oord_processor import OORDProcessor

__all__ = ['TerrainLoader', 'TerrainAnalyzer', 'OORDProcessor'] 
```

### src/data_processing/data_loader.py
```python
"""
数据加载模块
负责加载和预处理GIS数据（DEM、坡度、土地覆盖）和OORD轨迹数据
"""

import logging
from pathlib import Path
from typing import Tuple, Union

import numpy as np
import pandas as pd
import rasterio
from rasterio.transform import rowcol

from ..config import DEM_DIR, LANDCOVER_DIR

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class GISDataLoader:
    """GIS数据加载器，用于加载和处理DEM、坡度和土地覆盖数据"""
    
    def __init__(self):
        self.dem = None
        self.slope = None
        self.landcover = None
        self.transform = None
        self.crs = None
        self.nodata = None
    
    def load_dem(self, dem_path: Union[str, Path]) -> np.ndarray:
        """
        加载DEM数据
        
        Args:
            dem_path: DEM文件路径
            
        Returns:
            dem_data: DEM数组
        """
        try:
            with rasterio.open(dem_path) as src:
                self.dem = src.read(1)  # 读取第一个波段
                self.transform = src.transform
                self.crs = src.crs
                self.nodata = src.nodata
                logger.info(f"成功加载DEM数据，形状: {self.dem.shape}")
                return self.dem
        except Exception as e:
            logger.error(f"加载DEM数据失败: {str(e)}")
            raise
    
    def load_slope(self, slope_path: Union[str, Path]) -> np.ndarray:
        """
        加载坡度数据
        
        Args:
            slope_path: 坡度文件路径
            
        Returns:
            slope_data: 坡度数组
        """
        try:
            with rasterio.open(slope_path) as src:
                self.slope = src.read(1)
                # 验证与DEM的一致性
                if self.dem is not None:
                    assert self.slope.shape == self.dem.shape, "坡度数据与DEM形状不一致"
                logger.info(f"成功加载坡度数据，形状: {self.slope.shape}")
                return self.slope
        except Exception as e:
            logger.error(f"加载坡度数据失败: {str(e)}")
            raise
    
    def load_landcover(self, landcover_path: Union[str, Path]) -> np.ndarray:
        """
        加载土地覆盖数据
        
        Args:
            landcover_path: 土地覆盖文件路径
            
        Returns:
            landcover_data: 土地覆盖数组
        """
        try:
            with rasterio.open(landcover_path) as src:
                self.landcover = src.read(1)
                # 验证与DEM的一致性
                if self.dem is not None:
                    assert self.landcover.shape == self.dem.shape, "土地覆盖数据与DEM形状不一致"
                logger.info(f"成功加载土地覆盖数据，形状: {self.landcover.shape}")
                return self.landcover
        except Exception as e:
            logger.error(f"加载土地覆盖数据失败: {str(e)}")
            raise
    
    def get_pixel_coords(self, lon: float, lat: float) -> Tuple[int, int]:
        """
        将地理坐标转换为像素坐标
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            (row, col): 像素坐标元组
        """
        if self.transform is None:
            raise ValueError("未加载GIS数据，无法进行坐标转换")
        
        row, col = rowcol(self.transform, lon, lat)
        return row, col
    
    def get_elevation(self, row: int, col: int) -> float:
        """获取指定像素位置的高程值"""
        if self.dem is None:
            raise ValueError("未加载DEM数据")
        return self.dem[row, col]
    
    def get_slope(self, row: int, col: int) -> float:
        """获取指定像素位置的坡度值"""
        if self.slope is None:
            raise ValueError("未加载坡度数据")
        return self.slope[row, col]
    
    def get_landcover(self, row: int, col: int) -> int:
        """获取指定像素位置的土地覆盖类型"""
        if self.landcover is None:
            raise ValueError("未加载土地覆盖数据")
        return self.landcover[row, col] 
```

### src/data_processing/environment_mapper.py
```python
"""
环境地图生成器
根据地形数据和学习结果构建增强的环境地图
"""

import logging
from pathlib import Path
from typing import Dict, Optional

import numpy as np
import rasterio
from rasterio.transform import Affine

from .terrain_analyzer import TerrainAnalyzer
from .terrain_loader import TerrainLoader

logger = logging.getLogger(__name__)

class EnvironmentMapper:
    """环境地图生成器"""
    
    def __init__(
            self,
            terrain_loader: TerrainLoader,
            motion_patterns: Dict,
            output_dir: str = "data/output/intermediate"
        ):
        """
        初始化环境地图生成器
        
        Args:
            terrain_loader: 地形数据加载器实例
            motion_patterns: 学习到的运动模式
            output_dir: 输出目录
        """
        self.terrain_loader = terrain_loader
        self.terrain_analyzer = TerrainAnalyzer(terrain_loader)
        self.motion_patterns = motion_patterns
        self.output_dir = Path(output_dir)
        
        # 确保输出目录存在
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # 初始化地图数组
        shape = terrain_loader.dem_data.shape
        self.max_speed_map = np.zeros(shape, dtype=np.float32)
        self.typical_speed_map = np.zeros(shape, dtype=np.float32)
        self.speed_stddev_map = np.zeros(shape, dtype=np.float32)
        self.cost_map = np.zeros(shape, dtype=np.float32)
    
    def generate_maps(self) -> None:
        """生成所有环境地图"""
        logger.info("开始生成环境地图...")
        
        # 获取地形属性
        rows, cols = self.terrain_loader.dem_data.shape
        for row in range(rows):
            for col in range(cols):
                # 获取地理坐标
                lon, lat = self.terrain_loader.transform_pixel_to_coord(row, col)
                
                # 获取地形属性
                terrain_attrs = self.terrain_analyzer.get_terrain_attributes(lon, lat)
                landcover = self.terrain_loader.get_landcover(lon, lat)
                
                # 计算速度特征
                max_s, typ_s, std_s = self._calculate_speed_features(
                    terrain_attrs['slope_magnitude'],
                    landcover
                )
                
                # 更新地图
                self.max_speed_map[row, col] = max_s
                self.typical_speed_map[row, col] = typ_s
                self.speed_stddev_map[row, col] = std_s
                
                # 计算成本（基于典型速度）
                if typ_s > 0:
                    self.cost_map[row, col] = self.terrain_loader.resolution / typ_s
                else:
                    self.cost_map[row, col] = np.inf
        
        logger.info("环境地图生成完成")
        
        # 保存地图
        self._save_maps()
    
    def _calculate_speed_features(
            self,
            slope_magnitude: float,
            landcover: int
        ) -> tuple[float, float, float]:
        """
        计算给定位置的速度特征
        
        Args:
            slope_magnitude: 坡度大小(度)
            landcover: 地表类型编码
            
        Returns:
            tuple: (最大速度, 典型速度, 速度标准差)
        """
        # 获取坡度速度模型
        slope_speed = self.motion_patterns['slope_speed_model']
        
        # 找到对应的坡度组
        for (lower, upper), row in slope_speed.iterrows():
            if lower <= slope_magnitude < upper:
                slope_factor = row['speed_factor']
                break
        else:
            slope_factor = slope_speed.iloc[-1]['speed_factor']  # 使用最陡坡度组的因子
        
        # 获取地表类型速度统计
        landcover_stats = self.motion_patterns['landcover_speed_stats']
        if landcover in landcover_stats.index:
            lc_stats = landcover_stats.loc[landcover]
            lc_factor = lc_stats['speed_factor']
            speed_std = lc_stats['std']
        else:
            lc_factor = 0.5  # 默认因子
            speed_std = landcover_stats['std'].mean()  # 使用平均标准差
        
        # 计算速度特征
        base_speed = 20.0  # 基准速度 (m/s)
        max_speed = base_speed * slope_factor * lc_factor
        typical_speed = max_speed * 0.8  # 典型速度略低于最大速度
        
        return max_speed, typical_speed, speed_std
    
    def _save_maps(self) -> None:
        """保存生成的地图"""
        # 准备元数据
        meta = self.terrain_loader.get_raster_meta()
        
        # 保存最大速度图
        self._save_raster(
            self.max_speed_map,
            self.output_dir / "max_speed_map.tif",
            meta,
            "最大速度图 (m/s)"
        )
        
        # 保存典型速度图
        self._save_raster(
            self.typical_speed_map,
            self.output_dir / "typical_speed_map.tif",
            meta,
            "典型速度图 (m/s)"
        )
        
        # 保存速度标准差图
        self._save_raster(
            self.speed_stddev_map,
            self.output_dir / "speed_stddev_map.tif",
            meta,
            "速度标准差图 (m/s)"
        )
        
        # 保存成本图
        self._save_raster(
            self.cost_map,
            self.output_dir / "cost_map.tif",
            meta,
            "成本图 (s/m)"
        )
        
        logger.info("已保存所有环境地图")
    
    def _save_raster(
            self,
            data: np.ndarray,
            filepath: Path,
            meta: Dict,
            description: str
        ) -> None:
        """
        保存栅格数据
        
        Args:
            data: 栅格数据
            filepath: 保存路径
            meta: 元数据
            description: 数据描述
        """
        meta = meta.copy()
        meta.update({
            'dtype': 'float32',
            'description': description
        })
        
        with rasterio.open(filepath, 'w', **meta) as dst:
            dst.write(data, 1)
        logger.info(f"已保存 {description} 到: {filepath}")
    
    def get_maps(self) -> Dict[str, np.ndarray]:
        """
        获取生成的地图
        
        Returns:
            Dict: 包含所有生成的地图
        """
        return {
            'max_speed_map': self.max_speed_map,
            'typical_speed_map': self.typical_speed_map,
            'speed_stddev_map': self.speed_stddev_map,
            'cost_map': self.cost_map
        } 
```

### src/data_processing/motion_pattern_learner.py
```python
"""
运动模式学习器
从OORD数据中学习目标在不同环境下的运动特性
"""

import logging
from typing import Dict, List, Optional, Tuple

import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

from .terrain_analyzer import TerrainAnalyzer
from .terrain_loader import TerrainLoader

logger = logging.getLogger(__name__)

class MotionPatternLearner:
    """运动模式学习器"""
    
    def __init__(self, terrain_loader: TerrainLoader):
        """
        初始化运动模式学习器
        
        Args:
            terrain_loader: 地形数据加载器实例
        """
        self.terrain_loader = terrain_loader
        self.terrain_analyzer = TerrainAnalyzer(terrain_loader)
        
        # 学习结果
        self.learned_patterns = {
            'slope_speed_model': None,          # 坡度-速度关系模型
            'slope_direction_model': None,      # 坡向-速度关系模型
            'landcover_speed_stats': None,      # 地表类型-速度统计
            'turn_rate_stats': None,            # 转向率统计
            'acceleration_stats': None,         # 加速度统计
            'environment_clusters': None        # 环境分类结果
        }
        
        # 环境分组参数
        self.env_params = {
            'slope_bins': [0, 5, 15, 30, 90],   # 坡度分组边界
            'direction_bins': [-180, -135, -90, -45, 0, 45, 90, 135, 180],  # 相对坡向分组
            'min_samples': 100                   # 每组最小样本数
        }
    
    def learn_from_trajectories(self, trajectories: List[pd.DataFrame]) -> None:
        """
        从轨迹数据中学习运动模式
        
        Args:
            trajectories: OORD轨迹数据列表
        """
        logger.info("开始从%d条轨迹中学习运动模式", len(trajectories))
        
        # 合并所有轨迹数据
        combined_data = self._preprocess_trajectories(trajectories)
        
        # 学习各种运动模式
        self._learn_slope_speed_relation(combined_data)
        self._learn_slope_direction_effect(combined_data)
        self._learn_landcover_speed_relation(combined_data)
        self._learn_turn_rate_patterns(combined_data)
        self._learn_acceleration_patterns(combined_data)
        self._cluster_environments(combined_data)
        
        logger.info("运动模式学习完成")
    
    def _preprocess_trajectories(self, trajectories: List[pd.DataFrame]) -> pd.DataFrame:
        """
        预处理轨迹数据，添加环境特征
        
        Args:
            trajectories: 轨迹数据列表
            
        Returns:
            pd.DataFrame: 处理后的数据
        """
        processed_data = []
        
        for traj in trajectories:
            # 计算基本运动特征
            traj = traj.copy()
            traj['speed'] = np.sqrt(
                traj['velocity_north_ms']**2 + 
                traj['velocity_east_ms']**2
            )
            traj['acceleration'] = np.sqrt(
                traj['acceleration_x_ms2']**2 + 
                traj['acceleration_y_ms2']**2 + 
                traj['acceleration_z_ms2']**2
            )
            traj['turn_rate'] = np.sqrt(
                traj['angular_velocity_x_rads']**2 + 
                traj['angular_velocity_y_rads']**2 + 
                traj['angular_velocity_z_rads']**2
            )
            
            # 计算行进方向（航向角）
            traj['heading'] = np.degrees(np.arctan2(
                traj['velocity_east_ms'],
                traj['velocity_north_ms']
            ))
            traj['heading'] = np.where(traj['heading'] < 0, 
                                     traj['heading'] + 360,
                                     traj['heading'])
            
            # 添加环境特征
            for idx, row in traj.iterrows():
                terrain_attrs = self.terrain_analyzer.get_terrain_attributes(
                    row['longitude'],
                    row['latitude']
                )
                traj.loc[idx, 'slope_magnitude'] = terrain_attrs['slope_magnitude']
                traj.loc[idx, 'slope_aspect'] = terrain_attrs['slope_aspect']
                traj.loc[idx, 'landcover'] = self.terrain_loader.get_landcover(
                    row['longitude'],
                    row['latitude']
                )
            
            # 计算相对坡向（行进方向与坡向的夹角）
            traj['relative_aspect'] = traj['heading'] - traj['slope_aspect']
            traj['relative_aspect'] = np.where(
                traj['relative_aspect'] > 180,
                traj['relative_aspect'] - 360,
                traj['relative_aspect']
            )
            traj['relative_aspect'] = np.where(
                traj['relative_aspect'] < -180,
                traj['relative_aspect'] + 360,
                traj['relative_aspect']
            )
            
            processed_data.append(traj)
        
        return pd.concat(processed_data, ignore_index=True)
    
    def _learn_slope_speed_relation(self, data: pd.DataFrame) -> None:
        """学习坡度与速度的关系"""
        # 按坡度分组统计速度
        slope_speed = data.groupby(pd.cut(
            data['slope_magnitude'],
            bins=self.env_params['slope_bins']
        ))['speed'].agg(['mean', 'std', 'count'])
        
        # 过滤掉样本数不足的组
        slope_speed = slope_speed[slope_speed['count'] >= self.env_params['min_samples']]
        
        # 计算速度因子（相对于平地速度的比例）
        flat_speed = slope_speed.iloc[0]['mean']  # 第一组（0-5度）作为基准
        slope_speed['speed_factor'] = slope_speed['mean'] / flat_speed
        
        self.learned_patterns['slope_speed_model'] = slope_speed
    
    def _learn_slope_direction_effect(self, data: pd.DataFrame) -> None:
        """学习坡向对速度的影响"""
        # 按相对坡向和坡度大小分组
        direction_groups = data.groupby([
            pd.cut(data['relative_aspect'], 
                  bins=self.env_params['direction_bins']),
            pd.cut(data['slope_magnitude'],
                  bins=self.env_params['slope_bins'])
        ])
        
        # 统计每组的速度特征
        direction_speed = direction_groups['speed'].agg(['mean', 'std', 'count'])
        
        # 过滤样本数不足的组
        direction_speed = direction_speed[
            direction_speed['count'] >= self.env_params['min_samples']
        ]
        
        # 计算速度影响因子
        flat_forward_speed = direction_speed.xs(
            (slice(-45, 45), slice(0, 5)),  # 平地前向组
            level=[0, 1]
        )['mean'].mean()
        
        direction_speed['speed_factor'] = direction_speed['mean'] / flat_forward_speed
        
        self.learned_patterns['slope_direction_model'] = direction_speed
    
    def _learn_landcover_speed_relation(self, data: pd.DataFrame) -> None:
        """学习地表类型与速度的关系"""
        # 按地表类型分组统计
        landcover_speed = data.groupby('landcover')['speed'].agg([
            'mean', 'std', 'min', 'max', 'count'
        ])
        
        # 过滤样本数不足的组
        landcover_speed = landcover_speed[
            landcover_speed['count'] >= self.env_params['min_samples']
        ]
        
        # 计算速度因子
        road_speed = landcover_speed.loc[1]['mean']  # 假设1为道路类型
        landcover_speed['speed_factor'] = landcover_speed['mean'] / road_speed
        
        self.learned_patterns['landcover_speed_stats'] = landcover_speed
    
    def _learn_turn_rate_patterns(self, data: pd.DataFrame) -> None:
        """学习转向率模式"""
        # 计算转向率统计特征
        turn_rate_stats = {
            'mean': float(data['turn_rate'].mean()),
            'std': float(data['turn_rate'].std()),
            'percentiles': {
                '50': float(data['turn_rate'].quantile(0.5)),
                '75': float(data['turn_rate'].quantile(0.75)),
                '90': float(data['turn_rate'].quantile(0.9)),
                '95': float(data['turn_rate'].quantile(0.95)),
                '99': float(data['turn_rate'].quantile(0.99))
            }
        }
        
        self.learned_patterns['turn_rate_stats'] = turn_rate_stats
    
    def _learn_acceleration_patterns(self, data: pd.DataFrame) -> None:
        """学习加速度模式"""
        # 计算加速度统计特征
        acceleration_stats = {
            'mean': float(data['acceleration'].mean()),
            'std': float(data['acceleration'].std()),
            'percentiles': {
                '50': float(data['acceleration'].quantile(0.5)),
                '75': float(data['acceleration'].quantile(0.75)),
                '90': float(data['acceleration'].quantile(0.9)),
                '95': float(data['acceleration'].quantile(0.95)),
                '99': float(data['acceleration'].quantile(0.99))
            }
        }
        
        self.learned_patterns['acceleration_stats'] = acceleration_stats
    
    def _cluster_environments(self, data: pd.DataFrame) -> None:
        """
        对环境特征进行聚类分析
        用于发现典型的环境组合模式
        """
        # 准备特征
        features = ['slope_magnitude', 'relative_aspect', 'landcover']
        X = data[features].copy()
        
        # 标准化
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)
        
        # K-means聚类
        n_clusters = 5  # 可以根据需要调整
        kmeans = KMeans(n_clusters=n_clusters, random_state=42)
        clusters = kmeans.fit_predict(X_scaled)
        
        # 分析每个簇的特征
        cluster_stats = []
        for i in range(n_clusters):
            cluster_data = data[clusters == i]
            stats = {
                'size': len(cluster_data),
                'slope_mean': float(cluster_data['slope_magnitude'].mean()),
                'slope_std': float(cluster_data['slope_magnitude'].std()),
                'relative_aspect_mean': float(cluster_data['relative_aspect'].mean()),
                'relative_aspect_std': float(cluster_data['relative_aspect'].std()),
                'landcover_mode': int(cluster_data['landcover'].mode().iloc[0]),
                'speed_mean': float(cluster_data['speed'].mean()),
                'speed_std': float(cluster_data['speed'].std())
            }
            cluster_stats.append(stats)
        
        self.learned_patterns['environment_clusters'] = {
            'n_clusters': n_clusters,
            'cluster_centers': kmeans.cluster_centers_.tolist(),
            'feature_names': features,
            'scaler': scaler,
            'cluster_stats': cluster_stats
        }
    
    def get_learned_patterns(self) -> Dict:
        """
        获取学习到的运动模式
        
        Returns:
            Dict: 学习结果字典
        """
        return self.learned_patterns
    
    def save_patterns(self, filepath: str) -> None:
        """
        保存学习结果到文件
        
        Args:
            filepath: 保存路径
        """
        import pickle
        with open(filepath, 'wb') as f:
            pickle.dump(self.learned_patterns, f)
        logger.info("学习结果已保存到: %s", filepath)
    
    def load_patterns(self, filepath: str) -> None:
        """
        从文件加载学习结果
        
        Args:
            filepath: 文件路径
        """
        import pickle
        with open(filepath, 'rb') as f:
            self.learned_patterns = pickle.load(f)
        logger.info("已从%s加载学习结果", filepath) 
```

### src/data_processing/oord_processor.py
```python
"""
OORD数据处理模块
负责处理和分析OORD轨迹数据
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import pandas as pd
from scipy.stats import binned_statistic_2d

from .terrain_loader import TerrainLoader
from .terrain_analyzer import TerrainAnalyzer

logger = logging.getLogger(__name__)

class OORDProcessor:
    """OORD数据处理器"""
    
    def __init__(self, terrain_loader: Optional[TerrainLoader] = None):
        """
        初始化OORD数据处理器
        
        Args:
            terrain_loader: 地形数据加载器实例，如果为None则不进行地形分析
        """
        self.terrain_loader = terrain_loader
        self.terrain_analyzer = TerrainAnalyzer() if terrain_loader is not None else None
        self.trajectories: Dict[str, pd.DataFrame] = {}
        self.processed_trajectories: Dict[str, pd.DataFrame] = {}
        self.environment_stats: Optional[Dict] = None
        
    def load_trajectory(self, trajectory_file: Union[str, Path]) -> pd.DataFrame:
        """
        加载轨迹数据
        
        Args:
            trajectory_file: 轨迹文件路径
            
        Returns:
            pd.DataFrame: 处理后的轨迹数据
        """
        try:
            # 读取CSV文件
            df = pd.read_csv(trajectory_file)
            
            # 转换时间戳
            df['timestamp'] = pd.to_datetime(df['timestamp_ms'], unit='ms')
            
            # 计算速度和加速度
            df['speed'] = np.sqrt(
                df['velocity_north_ms']**2 + 
                df['velocity_east_ms']**2
            )
            df['acceleration'] = np.sqrt(
                df['acceleration_x_ms2']**2 + 
                df['acceleration_y_ms2']**2 + 
                df['acceleration_z_ms2']**2
            )
            
            # 计算航向角
            df['heading'] = np.degrees(np.arctan2(
                df['velocity_east_ms'],
                df['velocity_north_ms']
            )) % 360
            
            # 计算转向率
            df['turn_rate'] = np.sqrt(
                df['angular_velocity_x_rads']**2 + 
                df['angular_velocity_y_rads']**2 + 
                df['angular_velocity_z_rads']**2
            )
            
            # 如果有地形数据，添加地形相关信息
            if self.terrain_loader is not None:
                df['elevation'] = df.apply(
                    lambda row: self.terrain_loader.get_elevation(row['longitude'], row['latitude']),
                    axis=1
                )
                df['landcover'] = df.apply(
                    lambda row: self.terrain_loader.get_landcover(row['longitude'], row['latitude']),
                    axis=1
                )
            
            # 保存轨迹数据
            trajectory_id = Path(trajectory_file).stem
            self.trajectories[trajectory_id] = df
            
            return df
            
        except Exception as e:
            logger.error(f"处理轨迹文件 {trajectory_file} 失败: {str(e)}")
            raise
            
    def process_trajectory(
            self,
            trajectory_id: str,
            max_speed: float = 50.0
        ) -> pd.DataFrame:
        """
        处理轨迹数据
        
        Args:
            trajectory_id: 轨迹ID
            max_speed: 最大速度阈值，单位：米/秒
            
        Returns:
            pd.DataFrame: 处理后的轨迹数据
        """
        if trajectory_id not in self.trajectories:
            raise ValueError(f"未找到轨迹 {trajectory_id}")
        
        df = self.trajectories[trajectory_id].copy()
        
        # 速度过滤
        df = df[df['speed'] <= max_speed].copy()
        
        # 如果有地形数据，添加环境分组
        if self.terrain_loader is not None and self.terrain_analyzer is not None:
            # 确保地形分析器已初始化
            if self.terrain_analyzer.slope_magnitude is None:
                self.terrain_analyzer.load_dem(
                    self.terrain_loader.dem_data,
                    self.terrain_loader.resolution
                )
                self.terrain_analyzer.calculate_slope_magnitude()
            
            # 获取每个点的坡度
            df['slope_magnitude'] = df.apply(
                lambda row: self.terrain_analyzer.get_terrain_attributes(
                    row['longitude'], row['latitude']
                )['slope_magnitude'],
                axis=1
            )
            
            # 坡度分组
            df['slope_group'] = pd.cut(
                df['slope_magnitude'],
                bins=[0, 5, 15, 30, np.inf],
                labels=['flat', 'gentle', 'moderate', 'steep'],
                include_lowest=True  # 包含最小值
            )
            
            # 环境分组标签
            df['group_label'] = df.apply(
                lambda row: f"{row['slope_group']}_{row['landcover']}",
                axis=1
            )
        else:
            # 如果没有地形数据，使用默认值
            df['slope_magnitude'] = 0.0
            df['slope_group'] = 'flat'
            df['group_label'] = 'flat_0'
        
        # 保存处理后的轨迹
        self.processed_trajectories[trajectory_id] = df
        
        return df
        
    def analyze_environment_interaction(self) -> Dict:
        """
        分析轨迹与环境的交互关系
        
        Returns:
            Dict: 环境交互统计信息
        """
        if not self.processed_trajectories:
            raise ValueError("没有处理过的轨迹数据")
        
        # 合并所有处理过的轨迹
        all_trajectories = pd.concat(self.processed_trajectories.values())
        
        def safe_std(x: pd.Series) -> float:
            """安全计算标准差，当样本数小于2时返回0"""
            return float(x.std()) if len(x) > 1 else 0.0
        
        # 如果没有地形数据，只分析基本运动特征
        if self.terrain_loader is None:
            stats = {
                'overall': {
                    'speed_mean': float(all_trajectories['speed'].mean()),
                    'speed_std': safe_std(all_trajectories['speed']),
                    'speed_median': float(all_trajectories['speed'].median()),
                    'speed_max': float(all_trajectories['speed'].max()),
                    'acceleration_std': safe_std(all_trajectories['acceleration']),
                    'turn_rate_std': safe_std(all_trajectories['turn_rate']),
                    'sample_size': int(len(all_trajectories))
                }
            }
            return stats
        
        # 如果有地形数据，按环境分组分析
        stats = {}
        for group_label in all_trajectories['group_label'].unique():
            group_data = all_trajectories[all_trajectories['group_label'] == group_label]
            if len(group_data) > 0:  # 只处理非空组
                stats[group_label] = {
                    'speed_mean': float(group_data['speed'].mean()),
                    'speed_std': safe_std(group_data['speed']),
                    'speed_median': float(group_data['speed'].median()),
                    'speed_max': float(group_data['speed'].max()),
                    'acceleration_std': safe_std(group_data['acceleration']),
                    'turn_rate_std': safe_std(group_data['turn_rate']),
                    'sample_size': int(len(group_data))
                }
        
        return stats
        
    def _get_slope_magnitude(self, lon: float, lat: float) -> float:
        """
        获取指定位置的坡度大小
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            slope_magnitude: 坡度大小（度）
        """
        if self.terrain_analyzer.slope_magnitude is None:
            return 0.0
            
        row, col = self.terrain_loader.get_pixel_coords(lon, lat)
        if 0 <= row < self.terrain_analyzer.slope_magnitude.shape[0] and \
           0 <= col < self.terrain_analyzer.slope_magnitude.shape[1]:
            return float(self.terrain_analyzer.slope_magnitude[row, col])
        return 0.0
        
    @staticmethod
    def _calculate_haversine_distance(lon: np.ndarray, lat: np.ndarray) -> np.ndarray:
        """
        计算相邻点间的Haversine距离
        
        Args:
            lon: 经度数组
            lat: 纬度数组
            
        Returns:
            distances: 距离数组（米）
        """
        R = 6371000  # 地球半径（米）
        
        # 转换为弧度
        lon_rad = np.radians(lon)
        lat_rad = np.radians(lat)
        
        # 计算差值
        dlon = np.diff(lon_rad)
        dlat = np.diff(lat_rad)
        
        # Haversine公式
        a = np.sin(dlat/2)**2 + np.cos(lat_rad[:-1]) * np.cos(lat_rad[1:]) * np.sin(dlon/2)**2
        c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1-a))
        
        distances = np.zeros_like(lon)
        distances[1:] = R * c
        return distances
        
    @staticmethod
    def _calculate_heading(lon: np.ndarray, lat: np.ndarray) -> np.ndarray:
        """
        计算航向角（度，北为0，顺时针）
        
        Args:
            lon: 经度数组
            lat: 纬度数组
            
        Returns:
            headings: 航向角数组（度）
        """
        # 转换为弧度
        lon_rad = np.radians(lon)
        lat_rad = np.radians(lat)
        
        # 计算差值
        dlon = np.diff(lon_rad)
        dlat = np.diff(lat_rad)
        
        # 计算方位角
        y = np.sin(dlon) * np.cos(lat_rad[1:])
        x = np.cos(lat_rad[:-1]) * np.sin(lat_rad[1:]) - \
            np.sin(lat_rad[:-1]) * np.cos(lat_rad[1:]) * np.cos(dlon)
        
        heading_rad = np.arctan2(y, x)
        heading_deg = np.degrees(heading_rad) % 360
        
        headings = np.zeros_like(lon)
        headings[1:] = heading_deg
        headings[0] = headings[1]  # 第一个点使用第二个点的航向
        return headings

    def calculate_haversine_distance(
            self,
            lon1: float,
            lat1: float,
            lon2: float,
            lat2: float
        ) -> float:
        """
        计算两点间的Haversine距离
        
        Args:
            lon1: 起点经度
            lat1: 起点纬度
            lon2: 终点经度
            lat2: 终点纬度
            
        Returns:
            float: 两点间的距离，单位：公里
        """
        # 地球平均半径（公里）
        R = 6371.0
        
        # 将经纬度转换为弧度
        lat1_rad = np.radians(lat1)
        lon1_rad = np.radians(lon1)
        lat2_rad = np.radians(lat2)
        lon2_rad = np.radians(lon2)
        
        # 计算差值
        dlat = lat2_rad - lat1_rad
        dlon = lon2_rad - lon1_rad
        
        # Haversine公式
        a = np.sin(dlat/2)**2 + np.cos(lat1_rad) * np.cos(lat2_rad) * np.sin(dlon/2)**2
        c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1-a))
        distance = R * c
        
        return distance

    def calculate_heading(
            self,
            velocity_north: float,
            velocity_east: float
        ) -> float:
        """
        计算航向角
        
        Args:
            velocity_north: 北向速度分量
            velocity_east: 东向速度分量
            
        Returns:
            float: 航向角，单位：度，范围[0, 360)
        """
        heading = np.degrees(np.arctan2(velocity_east, velocity_north)) % 360
        return heading 
```

### src/data_processing/terrain_analyzer.py
```python
"""
地形分析模块
负责计算和分析DEM数据，生成坡度、坡向等地形特征
"""

import logging
from pathlib import Path
from typing import Dict, Optional, Tuple, Union

import numpy as np
import rasterio
from rasterio.errors import RasterioIOError
import richdem as rd

logger = logging.getLogger(__name__)

class TerrainAnalyzer:
    """地形分析器"""
    
    def __init__(self):
        """初始化地形分析器"""
        self.dem_data: Optional[np.ndarray] = None
        self.resolution: Optional[float] = None
        self.slope_magnitude: Optional[np.ndarray] = None
        self.slope_aspect: Optional[np.ndarray] = None
        self.dzdx: Optional[np.ndarray] = None
        self.dzdy: Optional[np.ndarray] = None
        
    def load_dem(self, dem_data: np.ndarray, resolution: float):
        """
        加载DEM数据
        
        Args:
            dem_data: DEM数据数组
            resolution: 空间分辨率（米）
        """
        self.dem_data = dem_data
        self.resolution = resolution
        logger.info(f"加载DEM数据，形状: {dem_data.shape}, 分辨率: {resolution}米")
        
    def calculate_slope_magnitude(self) -> np.ndarray:
        """
        计算坡度大小（度）
        
        Returns:
            slope_magnitude: 坡度大小数组（度）
        """
        if self.dem_data is None or self.resolution is None:
            raise ValueError("请先加载DEM数据")
            
        # 计算X和Y方向的梯度
        self.dzdx, self.dzdy = np.gradient(self.dem_data, self.resolution)
        
        # 计算坡度（弧度）
        slope_rad = np.arctan(np.sqrt(self.dzdx**2 + self.dzdy**2))
        
        # 转换为度
        self.slope_magnitude = np.degrees(slope_rad)
        
        logger.info(f"计算坡度大小完成，范围: [{self.slope_magnitude.min():.2f}, {self.slope_magnitude.max():.2f}]度")
        return self.slope_magnitude
        
    def calculate_slope_aspect(self) -> np.ndarray:
        """
        计算坡向（度，北为0，顺时针）
        
        Returns:
            slope_aspect: 坡向数组（度）
        """
        if self.dzdx is None or self.dzdy is None:
            self.calculate_slope_magnitude()
            
        # 计算坡向（弧度）
        aspect_rad = np.arctan2(self.dzdx, self.dzdy)
        
        # 转换为度并调整为北为0
        self.slope_aspect = np.degrees(aspect_rad)
        self.slope_aspect = (450 - self.slope_aspect) % 360
        
        # 处理平坦区域（坡度接近0的区域）
        flat_mask = self.slope_magnitude < 0.1  # 坡度小于0.1度视为平地
        self.slope_aspect[flat_mask] = -1  # 平地的坡向设为-1
        
        logger.info("计算坡向完成")
        return self.slope_aspect
        
    def get_terrain_attributes(self, lon: float, lat: float) -> Dict[str, float]:
        """
        获取指定位置的地形属性
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            Dict[str, float]: 地形属性字典，包含：
                - slope_magnitude: 坡度大小（度）
                - slope_aspect: 坡向（度）
        """
        if self.dem_data is None:
            return {
                'slope_magnitude': 0.0,
                'slope_aspect': -1.0
            }
        
        # 获取像素坐标
        row = int((lat - 39.0) / (30 / 111000))  # 30米分辨率，1度约等于111公里
        col = int((lon - 116.0) / (30 / (111000 * np.cos(np.radians(lat)))))
        
        # 检查坐标是否在范围内
        if not (0 <= row < self.dem_data.shape[0] and 0 <= col < self.dem_data.shape[1]):
            return {
                'slope_magnitude': 0.0,
                'slope_aspect': -1.0
            }
        
        slope_mag = self.slope_magnitude[row, col] if self.slope_magnitude is not None else 0.0
        slope_asp = self.slope_aspect[row, col] if self.slope_aspect is not None else -1.0
        
        return {
            'slope_magnitude': float(slope_mag),
            'slope_aspect': float(slope_asp)
        }
        
    def calculate_gradients(self) -> Tuple[np.ndarray, np.ndarray]:
        """
        计算X和Y方向的地形梯度
        
        Returns:
            (dzdx, dzdy): X和Y方向的梯度数组
        """
        if self.dem_data is None or self.resolution is None:
            raise ValueError("未加载DEM数据")
            
        # 使用numpy.gradient计算梯度
        dy, dx = np.gradient(self.dem_data)
        self.dzdx = dx / self.resolution  # X方向梯度
        self.dzdy = dy / self.resolution  # Y方向梯度
        
        logger.info("完成地形梯度计算")
        return self.dzdx, self.dzdy
        
    def save_results(self, output_dir: Union[str, Path]):
        """
        保存计算结果
        
        Args:
            output_dir: 输出目录
        """
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # 保存坡度大小
        if self.slope_magnitude is not None:
            slope_path = output_dir / "slope_magnitude_30m_100km.tif"
            self._save_array(self.slope_magnitude, slope_path, "坡度大小")
            
        # 保存坡向
        if self.slope_aspect is not None:
            aspect_path = output_dir / "slope_aspect_30m_100km.tif"
            self._save_array(self.slope_aspect, aspect_path, "坡向")
            
        # 保存梯度
        if self.dzdx is not None and self.dzdy is not None:
            dzdx_path = output_dir / "dzdx_30m_100km.tif"
            dzdy_path = output_dir / "dzdy_30m_100km.tif"
            self._save_array(self.dzdx, dzdx_path, "X方向梯度")
            self._save_array(self.dzdy, dzdy_path, "Y方向梯度")
            
    def _save_array(self, array: np.ndarray, path: Path, description: str):
        """
        保存数组为GeoTIFF文件
        
        Args:
            array: 要保存的数组
            path: 保存路径
            description: 数据描述
        """
        try:
            with rasterio.open(path, 'w',
                             driver='GTiff',
                             height=array.shape[0],
                             width=array.shape[1],
                             count=1,
                             dtype=array.dtype,
                             crs='+proj=latlong',
                             transform=None) as dst:
                dst.write(array, 1)
            logger.info(f"保存{description}数据到: {path}")
        except Exception as e:
            logger.error(f"保存{description}数据失败: {str(e)}")
            raise 
```

### src/data_processing/terrain_loader.py
```python
"""
GIS数据加载模块
负责加载DEM、土地覆盖等GIS数据
"""

import logging
from pathlib import Path
from typing import Dict, Optional, Tuple, Union

import numpy as np
import rasterio
from rasterio.errors import RasterioIOError

logger = logging.getLogger(__name__)

class TerrainLoader:
    """GIS地形数据加载器"""
    
    def __init__(self):
        """初始化地形数据加载器"""
        self.dem_data: Optional[np.ndarray] = None
        self.landcover_data: Optional[np.ndarray] = None
        self.transform = None
        self.crs = None
        self.resolution = None
        self.bounds = None
        
    def load_dem(self, dem_path: Union[str, Path]) -> np.ndarray:
        """
        加载DEM数据
        
        Args:
            dem_path: DEM文件路径(.tif格式)
            
        Returns:
            dem_array: DEM数据数组
        """
        try:
            with rasterio.open(dem_path) as src:
                self.dem_data = src.read(1)  # 读取第一个波段
                self.transform = src.transform
                self.crs = src.crs
                self.resolution = (src.res[0], src.res[1])
                self.bounds = src.bounds
                
            logger.info(f"成功加载DEM数据，形状: {self.dem_data.shape}")
            return self.dem_data
            
        except RasterioIOError as e:
            logger.error(f"加载DEM文件失败: {str(e)}")
            raise
            
    def load_landcover(self, landcover_path: Union[str, Path]) -> np.ndarray:
        """
        加载土地覆盖数据
        
        Args:
            landcover_path: 土地覆盖数据文件路径(.tif格式)
            
        Returns:
            landcover_array: 土地覆盖数据数组
        """
        try:
            with rasterio.open(landcover_path) as src:
                self.landcover_data = src.read(1)
                
                # 验证与DEM的一致性
                if self.dem_data is not None:
                    if src.shape != self.dem_data.shape:
                        raise ValueError("土地覆盖数据与DEM形状不一致")
                    if src.transform != self.transform:
                        raise ValueError("土地覆盖数据与DEM空间参考不一致")
                
            logger.info(f"成功加载土地覆盖数据，形状: {self.landcover_data.shape}")
            return self.landcover_data
            
        except RasterioIOError as e:
            logger.error(f"加载土地覆盖数据失败: {str(e)}")
            raise
            
    def get_pixel_coords(self, lon: float, lat: float) -> Tuple[int, int]:
        """
        将经纬度坐标转换为像素坐标
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            (row, col): 像素坐标
        """
        if self.transform is None:
            raise ValueError("未加载任何地形数据")
            
        col, row = ~self.transform * (lon, lat)
        return int(row), int(col)
        
    def get_geo_coords(self, row: int, col: int) -> Tuple[float, float]:
        """
        将像素坐标转换为经纬度坐标
        
        Args:
            row: 行号
            col: 列号
            
        Returns:
            (lon, lat): 经纬度坐标
        """
        if self.transform is None:
            raise ValueError("未加载任何地形数据")
            
        lon, lat = self.transform * (col, row)
        return lon, lat
        
    def get_elevation(self, lon: float, lat: float) -> float:
        """
        获取指定位置的高程值
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            elevation: 高程值
        """
        if self.dem_data is None:
            raise ValueError("未加载DEM数据")
            
        row, col = self.get_pixel_coords(lon, lat)
        if 0 <= row < self.dem_data.shape[0] and 0 <= col < self.dem_data.shape[1]:
            return float(self.dem_data[row, col])
        else:
            raise ValueError("坐标超出DEM范围")
            
    def get_landcover(self, lon: float, lat: float) -> int:
        """
        获取指定位置的土地覆盖类型
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            landcover_code: 土地覆盖类型代码
        """
        if self.landcover_data is None:
            raise ValueError("未加载土地覆盖数据")
            
        row, col = self.get_pixel_coords(lon, lat)
        if 0 <= row < self.landcover_data.shape[0] and 0 <= col < self.landcover_data.shape[1]:
            return int(self.landcover_data[row, col])
        else:
            raise ValueError("坐标超出土地覆盖数据范围") 
```

### src/data_processing/trajectory_loader.py
```python
"""
OORD轨迹数据加载和预处理模块
负责加载、清洗和预处理OORD轨迹数据
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import pandas as pd
from scipy.spatial.distance import cdist

from ..config import CORE_TRAJECTORIES_DIR

# 配置日志
logger = logging.getLogger(__name__)

class TrajectoryLoader:
    """OORD轨迹数据加载器"""
    
    def __init__(self):
        """初始化轨迹加载器"""
        self.trajectories: Dict[str, pd.DataFrame] = {}
        self.processed_trajectories: Dict[str, pd.DataFrame] = {}
    
    def load_trajectory(self, file_path: Union[str, Path]) -> pd.DataFrame:
        """
        加载单个轨迹文件
        
        Args:
            file_path: 轨迹文件路径
            
        Returns:
            trajectory_df: 包含轨迹数据的DataFrame
        """
        try:
            # 假设轨迹文件是CSV格式，包含timestamp,longitude,latitude列
            df = pd.read_csv(file_path)
            
            # 验证必要的列是否存在
            required_columns = ['timestamp', 'longitude', 'latitude']
            missing_columns = [col for col in required_columns if col not in df.columns]
            if missing_columns:
                raise ValueError(f"轨迹文件缺少必要的列: {missing_columns}")
            
            # 确保时间戳是datetime类型
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            
            # 按时间戳排序
            df = df.sort_values('timestamp')
            
            # 将轨迹存储在字典中
            trajectory_id = Path(file_path).stem
            self.trajectories[trajectory_id] = df
            
            logger.info(f"成功加载轨迹 {trajectory_id}，共 {len(df)} 个点")
            return df
            
        except Exception as e:
            logger.error(f"加载轨迹文件 {file_path} 失败: {str(e)}")
            raise
    
    def load_all_trajectories(self, directory: Union[str, Path] = CORE_TRAJECTORIES_DIR) -> Dict[str, pd.DataFrame]:
        """
        加载目录中的所有轨迹文件
        
        Args:
            directory: 轨迹文件目录
            
        Returns:
            trajectories: 轨迹数据字典，键为轨迹ID
        """
        directory = Path(directory)
        try:
            for file_path in directory.glob("*.csv"):
                self.load_trajectory(file_path)
            
            logger.info(f"成功加载 {len(self.trajectories)} 条轨迹")
            return self.trajectories
            
        except Exception as e:
            logger.error(f"加载轨迹目录 {directory} 失败: {str(e)}")
            raise
    
    def preprocess_trajectory(self, trajectory_id: str, 
                            min_speed: float = 0.1,
                            max_speed: float = 50.0,
                            min_distance: float = 1.0) -> pd.DataFrame:
        """
        预处理单条轨迹，计算速度、方向等特征，并进行异常值过滤
        
        Args:
            trajectory_id: 轨迹ID
            min_speed: 最小合理速度（米/秒）
            max_speed: 最大合理速度（米/秒）
            min_distance: 最小点间距离（米）
            
        Returns:
            processed_df: 处理后的轨迹DataFrame
        """
        if trajectory_id not in self.trajectories:
            raise KeyError(f"轨迹 {trajectory_id} 不存在")
            
        df = self.trajectories[trajectory_id].copy()
        
        # 计算时间差（秒）
        df['time_diff'] = df['timestamp'].diff().dt.total_seconds()
        
        # 计算相邻点间的距离（米）
        coords = df[['longitude', 'latitude']].values
        distances = np.zeros(len(df))
        distances[1:] = self._haversine_distance(coords[:-1], coords[1:])
        df['distance'] = distances
        
        # 计算速度（米/秒）
        df['speed'] = df['distance'] / df['time_diff']
        
        # 计算方向角（度）
        df['heading'] = self._calculate_heading(coords)
        
        # 计算转向率（度/秒）
        df['turn_rate'] = df['heading'].diff() / df['time_diff']
        
        # 过滤异常值
        mask = (
            (df['speed'] >= min_speed) & 
            (df['speed'] <= max_speed) &
            (df['distance'] >= min_distance)
        )
        
        df_filtered = df[mask].copy()
        
        # 重新计算过滤后的特征
        df_filtered['time_diff'] = df_filtered['timestamp'].diff().dt.total_seconds()
        df_filtered['acceleration'] = df_filtered['speed'].diff() / df_filtered['time_diff']
        
        # 存储处理后的轨迹
        self.processed_trajectories[trajectory_id] = df_filtered
        
        logger.info(f"轨迹 {trajectory_id} 预处理完成，保留 {len(df_filtered)}/{len(df)} 个点")
        return df_filtered
    
    def preprocess_all_trajectories(self, **kwargs) -> Dict[str, pd.DataFrame]:
        """
        预处理所有已加载的轨迹
        
        Args:
            **kwargs: 传递给preprocess_trajectory的参数
            
        Returns:
            processed_trajectories: 处理后的轨迹数据字典
        """
        for trajectory_id in self.trajectories:
            self.preprocess_trajectory(trajectory_id, **kwargs)
        
        logger.info(f"完成 {len(self.processed_trajectories)} 条轨迹的预处理")
        return self.processed_trajectories
    
    @staticmethod
    def _haversine_distance(point1: np.ndarray, point2: np.ndarray) -> np.ndarray:
        """
        计算两点间的Haversine距离（米）
        
        Args:
            point1: [longitude, latitude] 数组
            point2: [longitude, latitude] 数组
            
        Returns:
            distances: 距离数组（米）
        """
        R = 6371000  # 地球半径（米）
        
        # 转换为弧度
        lat1, lon1 = np.radians(point1[:, 1]), np.radians(point1[:, 0])
        lat2, lon2 = np.radians(point2[:, 1]), np.radians(point2[:, 0])
        
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        
        a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2
        c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1-a))
        
        return R * c
    
    @staticmethod
    def _calculate_heading(coords: np.ndarray) -> np.ndarray:
        """
        计算轨迹点的方向角（度）
        
        Args:
            coords: [[longitude, latitude], ...] 数组
            
        Returns:
            headings: 方向角数组（度）
        """
        # 初始化方向角数组
        headings = np.zeros(len(coords))
        
        # 计算相邻点的经纬度差
        dlon = np.radians(np.diff(coords[:, 0]))
        lat1 = np.radians(coords[:-1, 1])
        lat2 = np.radians(coords[1:, 1])
        
        # 计算方位角
        y = np.sin(dlon) * np.cos(lat2)
        x = np.cos(lat1) * np.sin(lat2) - np.sin(lat1) * np.cos(lat2) * np.cos(dlon)
        heading_rad = np.arctan2(y, x)
        
        # 转换为度数并调整到[0, 360)范围
        headings[1:] = (np.degrees(heading_rad) + 360) % 360
        headings[0] = headings[1]  # 第一个点的方向与第二个点相同
        
        return headings 
```

### src/evaluation/__init__.py
```python

```

### src/evaluation/evaluator.py
```python
"""
轨迹评估器
用于评估生成轨迹的质量和真实性
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import numpy as np
import pandas as pd
from scipy import stats
import matplotlib.pyplot as plt
import seaborn as sns

logger = logging.getLogger(__name__)

class Evaluator:
    """轨迹评估器"""
    
    def __init__(
            self,
            oord_data: pd.DataFrame,
            output_dir: str
        ):
        """
        初始化评估器
        
        Args:
            oord_data: OORD轨迹数据，包含：
                - timestamp_ms: 时间戳（毫秒）
                - speed_mps: 速度（米/秒）
                - heading_degrees: 朝向（度）
                - turn_rate_dps: 转向率（度/秒）
                - acceleration_mps2: 加速度（米/秒²）
                - group_label: 环境组标签
            output_dir: 评估结果输出目录
        """
        self.oord_data = oord_data
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # 计算OORD数据的统计特征
        self._calculate_oord_statistics()
    
    def _calculate_oord_statistics(self) -> None:
        """计算OORD数据的统计特征"""
        # 全局统计
        self.oord_stats = {
            'speed': {
                'mean': self.oord_data['speed_mps'].mean(),
                'std': self.oord_data['speed_mps'].std(),
                'min': self.oord_data['speed_mps'].min(),
                'max': self.oord_data['speed_mps'].max(),
                'percentiles': np.percentile(
                    self.oord_data['speed_mps'],
                    [25, 50, 75]
                )
            },
            'acceleration': {
                'mean': self.oord_data['acceleration_mps2'].mean(),
                'std': self.oord_data['acceleration_mps2'].std(),
                'min': self.oord_data['acceleration_mps2'].min(),
                'max': self.oord_data['acceleration_mps2'].max(),
                'percentiles': np.percentile(
                    self.oord_data['acceleration_mps2'],
                    [25, 50, 75]
                )
            },
            'turn_rate': {
                'mean': self.oord_data['turn_rate_dps'].mean(),
                'std': self.oord_data['turn_rate_dps'].std(),
                'min': self.oord_data['turn_rate_dps'].min(),
                'max': self.oord_data['turn_rate_dps'].max(),
                'percentiles': np.percentile(
                    self.oord_data['turn_rate_dps'],
                    [25, 50, 75]
                )
            }
        }
        
        # 按环境组统计
        self.oord_group_stats = {}
        for group in self.oord_data['group_label'].unique():
            group_data = self.oord_data[
                self.oord_data['group_label'] == group
            ]
            self.oord_group_stats[group] = {
                'speed': {
                    'mean': group_data['speed_mps'].mean(),
                    'std': group_data['speed_mps'].std()
                }
            }
    
    def evaluate_trajectory(
            self,
            trajectory: Dict,
            group_labels: Optional[List[str]] = None
        ) -> Dict:
        """
        评估单条轨迹
        
        Args:
            trajectory: 轨迹数据字典，包含：
                - timestamps: 时间戳列表（秒）
                - speeds: 速度列表（米/秒）
                - headings: 朝向列表（度）
            group_labels: 轨迹点的环境组标签列表，可选
            
        Returns:
            Dict: 评估结果
        """
        # 转换为DataFrame
        traj_df = pd.DataFrame({
            'timestamp': trajectory['timestamps'],
            'speed': trajectory['speeds'],
            'heading': trajectory['headings']
        })
        
        # 计算转向率和加速度
        traj_df['turn_rate'] = np.gradient(
            traj_df['heading'],
            traj_df['timestamp']
        )
        traj_df['acceleration'] = np.gradient(
            traj_df['speed'],
            traj_df['timestamp']
        )
        
        # 计算统计特征
        stats_result = {
            'speed': {
                'mean': traj_df['speed'].mean(),
                'std': traj_df['speed'].std(),
                'min': traj_df['speed'].min(),
                'max': traj_df['speed'].max(),
                'percentiles': np.percentile(
                    traj_df['speed'],
                    [25, 50, 75]
                )
            },
            'acceleration': {
                'mean': traj_df['acceleration'].mean(),
                'std': traj_df['acceleration'].std(),
                'min': traj_df['acceleration'].min(),
                'max': traj_df['acceleration'].max(),
                'percentiles': np.percentile(
                    traj_df['acceleration'],
                    [25, 50, 75]
                )
            },
            'turn_rate': {
                'mean': traj_df['turn_rate'].mean(),
                'std': traj_df['turn_rate'].std(),
                'min': traj_df['turn_rate'].min(),
                'max': traj_df['turn_rate'].max(),
                'percentiles': np.percentile(
                    traj_df['turn_rate'],
                    [25, 50, 75]
                )
            }
        }
        
        # 进行KS检验
        ks_results = {
            'speed': stats.ks_2samp(
                traj_df['speed'],
                self.oord_data['speed_mps']
            ),
            'acceleration': stats.ks_2samp(
                traj_df['acceleration'],
                self.oord_data['acceleration_mps2']
            ),
            'turn_rate': stats.ks_2samp(
                traj_df['turn_rate'],
                self.oord_data['turn_rate_dps']
            )
        }
        
        # 如果提供了环境组标签，进行分组评估
        group_results = {}
        if group_labels is not None:
            traj_df['group_label'] = group_labels
            for group in traj_df['group_label'].unique():
                group_data = traj_df[
                    traj_df['group_label'] == group
                ]
                oord_group_data = self.oord_data[
                    self.oord_data['group_label'] == group
                ]
                
                if len(group_data) > 0 and len(oord_group_data) > 0:
                    group_results[group] = {
                        'speed': {
                            'mean': group_data['speed'].mean(),
                            'std': group_data['speed'].std(),
                            'ks_test': stats.ks_2samp(
                                group_data['speed'],
                                oord_group_data['speed_mps']
                            )
                        }
                    }
        
        return {
            'statistics': stats_result,
            'ks_tests': ks_results,
            'group_results': group_results
        }
    
    def evaluate_batch(
            self,
            trajectories: List[Dict],
            group_labels_list: Optional[List[List[str]]] = None
        ) -> Dict:
        """
        评估一批轨迹
        
        Args:
            trajectories: 轨迹数据字典列表
            group_labels_list: 轨迹点的环境组标签列表的列表，可选
            
        Returns:
            Dict: 评估结果
        """
        # 评估每条轨迹
        results = []
        for i, traj in enumerate(trajectories):
            group_labels = (
                group_labels_list[i]
                if group_labels_list is not None
                else None
            )
            results.append(
                self.evaluate_trajectory(traj, group_labels)
            )
        
        # 汇总统计结果
        speed_means = [r['statistics']['speed']['mean'] for r in results]
        accel_means = [
            r['statistics']['acceleration']['mean']
            for r in results
        ]
        turn_means = [
            r['statistics']['turn_rate']['mean']
            for r in results
        ]
        
        summary = {
            'speed': {
                'mean_of_means': np.mean(speed_means),
                'std_of_means': np.std(speed_means)
            },
            'acceleration': {
                'mean_of_means': np.mean(accel_means),
                'std_of_means': np.std(accel_means)
            },
            'turn_rate': {
                'mean_of_means': np.mean(turn_means),
                'std_of_means': np.std(turn_means)
            }
        }
        
        return {
            'individual_results': results,
            'summary': summary
        }
    
    def plot_distributions(
            self,
            trajectories: List[Dict],
            prefix: str = ''
        ) -> None:
        """
        绘制分布对比图
        
        Args:
            trajectories: 轨迹数据字典列表
            prefix: 输出文件名前缀
        """
        # 合并所有轨迹数据
        all_speeds = []
        all_accels = []
        all_turns = []
        
        for traj in trajectories:
            all_speeds.extend(traj['speeds'])
            
            # 计算加速度和转向率
            times = np.array(traj['timestamps'])
            speeds = np.array(traj['speeds'])
            headings = np.array(traj['headings'])
            
            accels = np.gradient(speeds, times)
            turns = np.gradient(headings, times)
            
            all_accels.extend(accels)
            all_turns.extend(turns)
        
        # 绘制速度分布
        plt.figure(figsize=(10, 6))
        sns.kdeplot(
            data=self.oord_data['speed_mps'],
            label='OORD',
            color='blue'
        )
        sns.kdeplot(
            data=all_speeds,
            label='Generated',
            color='red'
        )
        plt.title('Speed Distribution Comparison')
        plt.xlabel('Speed (m/s)')
        plt.ylabel('Density')
        plt.legend()
        plt.savefig(
            self.output_dir / f'{prefix}speed_distribution.png'
        )
        plt.close()
        
        # 绘制加速度分布
        plt.figure(figsize=(10, 6))
        sns.kdeplot(
            data=self.oord_data['acceleration_mps2'],
            label='OORD',
            color='blue'
        )
        sns.kdeplot(
            data=all_accels,
            label='Generated',
            color='red'
        )
        plt.title('Acceleration Distribution Comparison')
        plt.xlabel('Acceleration (m/s²)')
        plt.ylabel('Density')
        plt.legend()
        plt.savefig(
            self.output_dir / f'{prefix}acceleration_distribution.png'
        )
        plt.close()
        
        # 绘制转向率分布
        plt.figure(figsize=(10, 6))
        sns.kdeplot(
            data=self.oord_data['turn_rate_dps'],
            label='OORD',
            color='blue'
        )
        sns.kdeplot(
            data=all_turns,
            label='Generated',
            color='red'
        )
        plt.title('Turn Rate Distribution Comparison')
        plt.xlabel('Turn Rate (deg/s)')
        plt.ylabel('Density')
        plt.legend()
        plt.savefig(
            self.output_dir / f'{prefix}turn_rate_distribution.png'
        )
        plt.close()
    
    def generate_report(
            self,
            batch_results: Dict,
            output_file: str
        ) -> None:
        """
        生成评估报告
        
        Args:
            batch_results: 批量评估结果
            output_file: 输出文件路径
        """
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# 轨迹评估报告\n\n")
            
            # 写入总体统计
            f.write("## 总体统计\n\n")
            f.write("### 速度统计\n")
            f.write(f"- OORD平均速度: {self.oord_stats['speed']['mean']:.2f} m/s\n")
            f.write(f"- 生成轨迹平均速度: {batch_results['summary']['speed']['mean_of_means']:.2f} m/s\n")
            f.write(f"- OORD速度标准差: {self.oord_stats['speed']['std']:.2f} m/s\n")
            f.write(f"- 生成轨迹速度标准差: {batch_results['summary']['speed']['std_of_means']:.2f} m/s\n\n")
            
            f.write("### 加速度统计\n")
            f.write(f"- OORD平均加速度: {self.oord_stats['acceleration']['mean']:.2f} m/s²\n")
            f.write(f"- 生成轨迹平均加速度: {batch_results['summary']['acceleration']['mean_of_means']:.2f} m/s²\n")
            f.write(f"- OORD加速度标准差: {self.oord_stats['acceleration']['std']:.2f} m/s²\n")
            f.write(f"- 生成轨迹加速度标准差: {batch_results['summary']['acceleration']['std_of_means']:.2f} m/s²\n\n")
            
            f.write("### 转向率统计\n")
            f.write(f"- OORD平均转向率: {self.oord_stats['turn_rate']['mean']:.2f} deg/s\n")
            f.write(f"- 生成轨迹平均转向率: {batch_results['summary']['turn_rate']['mean_of_means']:.2f} deg/s\n")
            f.write(f"- OORD转向率标准差: {self.oord_stats['turn_rate']['std']:.2f} deg/s\n")
            f.write(f"- 生成轨迹转向率标准差: {batch_results['summary']['turn_rate']['std_of_means']:.2f} deg/s\n\n")
            
            # 写入KS检验结果
            f.write("## KS检验结果\n\n")
            for i, result in enumerate(batch_results['individual_results']):
                f.write(f"### 轨迹 {i+1}\n")
                f.write("- 速度分布检验:\n")
                f.write(f"  - 统计量: {result['ks_tests']['speed'].statistic:.4f}\n")
                f.write(f"  - p值: {result['ks_tests']['speed'].pvalue:.4f}\n")
                f.write("- 加速度分布检验:\n")
                f.write(f"  - 统计量: {result['ks_tests']['acceleration'].statistic:.4f}\n")
                f.write(f"  - p值: {result['ks_tests']['acceleration'].pvalue:.4f}\n")
                f.write("- 转向率分布检验:\n")
                f.write(f"  - 统计量: {result['ks_tests']['turn_rate'].statistic:.4f}\n")
                f.write(f"  - p值: {result['ks_tests']['turn_rate'].pvalue:.4f}\n\n")
            
            # 写入环境组分析结果
            if any(r['group_results'] for r in batch_results['individual_results']):
                f.write("## 环境组分析\n\n")
                for i, result in enumerate(batch_results['individual_results']):
                    if result['group_results']:
                        f.write(f"### 轨迹 {i+1}\n")
                        for group, stats in result['group_results'].items():
                            f.write(f"#### {group}\n")
                            f.write(f"- 平均速度: {stats['speed']['mean']:.2f} m/s\n")
                            f.write(f"- 速度标准差: {stats['speed']['std']:.2f} m/s\n")
                            f.write("- KS检验结果:\n")
                            f.write(f"  - 统计量: {stats['speed']['ks_test'].statistic:.4f}\n")
                            f.write(f"  - p值: {stats['speed']['ks_test'].pvalue:.4f}\n\n") 
```

### src/generation/__init__.py
```python

```

### src/generator/__init__.py
```python
"""
轨迹生成器模块
"""

from .trajectory_generator import TrajectoryGenerator

__all__ = ['TrajectoryGenerator'] 
```

### src/generator/batch_generator.py
```python
"""批量轨迹生成器主控脚本

负责协调各个模块，完成从地形分析到轨迹生成的全流程。

输入:
- 配置文件
- GIS数据
- OORD数据

输出:
- 批量生成的轨迹
- 评估报告
"""

import logging
import os
from pathlib import Path
from datetime import datetime
from typing import List, Tuple, Dict
import json

from .terrain_analyzer import TerrainAnalyzer
from .environment_mapper import EnvironmentMapper
from .point_selector import PointSelector
from .path_planner import PathPlanner
from .motion_simulator import MotionSimulator, EnvironmentParams
from .evaluator import Evaluator

# 配置日志
logging.basicConfig(level=logging.INFO,
                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class BatchGenerator:
    """批量轨迹生成器类"""

    def __init__(self, config_path: str):
        """初始化批量生成器

        Args:
            config_path: 配置文件路径
        """
        # 加载配置
        with open(config_path) as f:
            self.config = json.load(f)

        # 创建输出目录
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.batch_dir = Path(self.config['output_dir']) / f"synthetic_batch_{timestamp}"
        self.batch_dir.mkdir(parents=True, exist_ok=True)

        # 保存配置副本
        with open(self.batch_dir / 'config.json', 'w') as f:
            json.dump(self.config, f, indent=4)

        # 初始化组件
        self.terrain_analyzer = TerrainAnalyzer(
            self.config['dem_path'],
            self.config['output_dir']
        )
        self.environment_mapper = EnvironmentMapper(
            self.config,
            self.config['output_dir']
        )
        self.point_selector = PointSelector(self.config)
        self.path_planner = PathPlanner(self.config)
        self.motion_simulator = MotionSimulator()
        self.evaluator = Evaluator(
            self.config,
            self.batch_dir / 'evaluation'
        )

    def generate_batch(self) -> None:
        """执行批量轨迹生成流程"""
        logger.info("开始批量生成轨迹...")

        # 1. 地形分析
        logger.info("步骤1: 地形分析")
        self.terrain_analyzer.calculate_terrain_attributes()

        # 2. 构建环境地图
        logger.info("步骤2: 构建环境地图")
        learned_params = self._load_learned_params()
        self.environment_mapper.build_environment_maps(learned_params)

        # 3. 选择起终点对
        logger.info("步骤3: 选择起终点对")
        generation_pairs = self.point_selector.select_start_end_pairs()
        if not generation_pairs:
            logger.error("未能找到合适的起终点对")
            return

        # 4. 为每对起终点生成轨迹
        logger.info("步骤4: 生成轨迹")
        successful_count = 0
        for i, (start_point, end_point) in enumerate(generation_pairs):
            try:
                # 规划路径
                path = self.path_planner.plan_path(start_point, end_point)
                if not path:
                    logger.warning(f"无法为第 {i+1} 对起终点规划路径")
                    continue

                # 模拟运动
                trajectory = self.motion_simulator.simulate_motion(
                    path,
                    self._get_environment_params
                )

                # 保存轨迹
                self._save_trajectory(trajectory, i + 1)
                successful_count += 1

            except Exception as e:
                logger.error(f"生成第 {i+1} 条轨迹时出错: {str(e)}")
                continue

        logger.info(f"成功生成 {successful_count} 条轨迹")

        # 5. 评估生成的轨迹
        if successful_count > 0:
            logger.info("步骤5: 评估轨迹")
            self.evaluator.evaluate_batch(
                str(self.batch_dir),
                self.config['oord_processed_path']
            )

        logger.info("批量生成完成")

    def _load_learned_params(self) -> Dict:
        """加载学习到的参数

        Returns:
            Dict: 学习到的参数
        """
        params_path = Path(self.config['output_dir']) / 'intermediate/learned_params.json'
        if params_path.exists():
            with open(params_path) as f:
                return json.load(f)
        return {}  # 如果文件不存在，返回空字典

    def _get_environment_params(self, lon: float, lat: float) -> EnvironmentParams:
        """获取指定位置的环境参数

        Args:
            lon: 经度
            lat: 纬度

        Returns:
            EnvironmentParams: 环境参数
        """
        # 从环境地图获取基础参数
        max_speed, typical_speed, speed_stddev = \
            self.environment_mapper.get_environment_params(lon, lat)

        # 获取地形信息
        slope, aspect, _, _ = self.terrain_analyzer.get_terrain_info(lon, lat)

        # 创建环境参数对象
        return EnvironmentParams(
            max_speed=max_speed,
            typical_speed=typical_speed,
            speed_stddev=speed_stddev,
            slope_magnitude=slope,
            slope_aspect=aspect
        )

    def _save_trajectory(self, trajectory: List[Tuple], index: int) -> None:
        """保存轨迹到文件

        Args:
            trajectory: 轨迹点列表
            index: 轨迹索引
        """
        import pandas as pd

        # 创建DataFrame
        df = pd.DataFrame(
            trajectory,
            columns=['timestamp', 'lon', 'lat', 'speed_mps', 'heading_degrees']
        )

        # 保存为CSV
        output_path = self.batch_dir / f'trajectory_{index:04d}.csv'
        df.to_csv(output_path, index=False)
        logger.debug(f"轨迹已保存到: {output_path}")

def main():
    """主函数"""
    import argparse

    parser = argparse.ArgumentParser(description='批量生成轨迹')
    parser.add_argument('config', help='配置文件路径')
    args = parser.parse_args()

    try:
        generator = BatchGenerator(args.config)
        generator.generate_batch()
    except Exception as e:
        logger.error(f"执行过程中出错: {str(e)}")
        raise

if __name__ == '__main__':
    main() 
```

### src/generator/config.py
```python
"""环境地图生成器配置文件

定义环境地图生成所需的常量和参数。
"""

# 坡度相关参数
MAX_SLOPE_THRESHOLD = 45.0  # 最大可通行坡度（度）
SLOPE_SPEED_FACTOR = 0.02   # 坡度对速度的影响因子
MAX_SPEED = 5.0            # 基础最大速度（米/秒）

# 速度相关参数
TYPICAL_SPEED_FACTOR = 0.8  # 典型速度与最大速度的比例
UP_SLOPE_FACTOR = 0.03     # 上坡减速因子
DOWN_SLOPE_FACTOR = 0.01   # 下坡增速因子
CROSS_SLOPE_FACTOR = 0.02  # 横坡减速因子

# 标准差相关参数
BASE_SPEED_STDDEV_FACTOR = 0.2  # 基础速度标准差因子
SLOPE_STDDEV_FACTOR = 0.5       # 坡度对标准差的影响因子
COMPLEX_TERRAIN_STDDEV_FACTOR = 1.5  # 复杂地形标准差增加因子

# 复杂地形代码
COMPLEX_TERRAIN_CODES = [
    21,  # 山地
    22,  # 丘陵
    23,  # 高原
]

# 土地覆盖速度因子
LANDCOVER_SPEED_FACTORS = {
    11: 1.0,   # 平原
    12: 0.9,   # 草地
    13: 0.8,   # 灌木
    21: 0.7,   # 山地
    22: 0.8,   # 丘陵
    23: 0.9,   # 高原
    31: 0.0,   # 水体
    41: 0.0,   # 冰川
    51: 0.6,   # 建筑区
    61: 0.7,   # 农田
    71: 0.8,   # 林地
    81: 0.0,   # 沼泽
    82: 0.0,   # 盐碱地
}

# 土地覆盖成本因子
LANDCOVER_COST_FACTORS = {
    11: 1.0,   # 平原
    12: 1.2,   # 草地
    13: 1.3,   # 灌木
    21: 1.5,   # 山地
    22: 1.3,   # 丘陵
    23: 1.2,   # 高原
    51: 1.4,   # 建筑区
    61: 1.2,   # 农田
    71: 1.3,   # 林地
}

# 不可通行土地覆盖代码
IMPASSABLE_LANDCOVER_CODES = [
    31,  # 水体
    41,  # 冰川
    81,  # 沼泽
    82,  # 盐碱地
]

# 起点选择相关参数
MIN_START_END_DISTANCE_METERS = 1000.0  # 起终点最小距离（米）
MIN_START_POINTS_SPACING = 250.0        # 起点之间的最小间距（米）
MAX_SEARCH_RADIUS = 5000.0             # 最大搜索半径（米）
MAX_SEARCH_ATTEMPTS = 1000             # 最大搜索尝试次数 
```

### src/generator/data_loader.py
```python
"""数据加载器模块

此模块负责加载和预处理OORD轨迹数据，功能包括：
1. 读取轨迹文件(CSV/GPX)
2. 统一坐标系
3. 计算运动参数(速度、朝向、转向率、加速度)
4. 将地理坐标转换为像素坐标

输入:
    - OORD轨迹文件 (CSV/GPX格式)
    - GIS环境数据的地理参考信息

输出:
    - 预处理后的轨迹DataFrame，包含：
        - timestamp: 时间戳
        - row, col: 像素坐标
        - lon, lat: 地理坐标
        - speed_mps: 速度(米/秒)
        - heading_degrees: 朝向(度)
        - turn_rate_dps: 转向率(度/秒)
        - acceleration_mps2: 加速度(米/秒²)
        - trajectory_id: 轨迹ID
"""

import pandas as pd
import numpy as np
import glob
import os
from pathlib import Path
import logging
from typing import List, Tuple, Union
import rasterio
from rasterio.transform import Affine
import gpxpy
from datetime import datetime
import pytz

class DataLoader:
    """数据加载器类"""
    
    def __init__(self, gis_transform: Affine, gis_shape: Tuple[int, int]):
        """初始化数据加载器
        
        Args:
            gis_transform: GIS数据的地理变换矩阵
            gis_shape: GIS数据的形状(height, width)
        """
        self.transform = gis_transform
        self.height, self.width = gis_shape
        self.logger = logging.getLogger(__name__)
    
    def load_trajectory_file(self, file_path: str) -> pd.DataFrame:
        """加载单个轨迹文件
        
        支持CSV和GPX格式。
        CSV格式要求包含timestamp、longitude、latitude列。
        
        Args:
            file_path: 轨迹文件路径
            
        Returns:
            pd.DataFrame: 预处理后的轨迹数据
        """
        # 获取文件扩展名
        ext = Path(file_path).suffix.lower()
        
        # 根据文件类型选择加载方法
        if ext == '.csv':
            df = self._load_csv(file_path)
        elif ext == '.gpx':
            df = self._load_gpx(file_path)
        else:
            raise ValueError(f"不支持的文件格式: {ext}")
        
        # 预处理数据
        df = self._preprocess_trajectory(df)
        
        return df
    
    def load_all_trajectories(self, data_dir: str) -> pd.DataFrame:
        """加载目录下的所有轨迹文件
        
        Args:
            data_dir: 数据目录路径
            
        Returns:
            pd.DataFrame: 合并后的轨迹数据
        """
        # 获取所有轨迹文件
        csv_files = glob.glob(os.path.join(data_dir, "*.csv"))
        gpx_files = glob.glob(os.path.join(data_dir, "*.gpx"))
        all_files = csv_files + gpx_files
        
        if not all_files:
            raise FileNotFoundError(f"在目录 {data_dir} 中未找到轨迹文件")
        
        # 加载所有文件
        dfs = []
        for file_path in all_files:
            try:
                df = self.load_trajectory_file(file_path)
                # 添加轨迹ID
                df['trajectory_id'] = Path(file_path).stem
                dfs.append(df)
            except Exception as e:
                self.logger.error(f"加载文件 {file_path} 失败: {e}")
                continue
        
        # 合并所有数据
        if not dfs:
            raise ValueError("没有成功加载任何轨迹文件")
        
        merged_df = pd.concat(dfs, ignore_index=True)
        return merged_df
    
    def _load_csv(self, file_path: str) -> pd.DataFrame:
        """加载CSV格式的轨迹文件
        
        Args:
            file_path: CSV文件路径
            
        Returns:
            pd.DataFrame: 原始轨迹数据
        """
        try:
            df = pd.read_csv(file_path)
            required_cols = ['timestamp', 'longitude', 'latitude']
            if not all(col in df.columns for col in required_cols):
                raise ValueError(f"CSV文件缺少必需的列: {required_cols}")
            
            # 确保时间戳格式正确
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            
            return df
        except Exception as e:
            raise ValueError(f"加载CSV文件失败: {e}")
    
    def _load_gpx(self, file_path: str) -> pd.DataFrame:
        """加载GPX格式的轨迹文件
        
        Args:
            file_path: GPX文件路径
            
        Returns:
            pd.DataFrame: 原始轨迹数据
        """
        try:
            with open(file_path, 'r') as gpx_file:
                gpx = gpxpy.parse(gpx_file)
            
            data = []
            for track in gpx.tracks:
                for segment in track.segments:
                    for point in segment.points:
                        data.append({
                            'timestamp': point.time.replace(tzinfo=None),
                            'longitude': point.longitude,
                            'latitude': point.latitude
                        })
            
            return pd.DataFrame(data)
        except Exception as e:
            raise ValueError(f"加载GPX文件失败: {e}")
    
    def _preprocess_trajectory(self, df: pd.DataFrame) -> pd.DataFrame:
        """预处理轨迹数据
        
        1. 计算像素坐标
        2. 计算速度
        3. 计算朝向
        4. 计算转向率
        5. 计算加速度
        
        Args:
            df: 原始轨迹数据
            
        Returns:
            pd.DataFrame: 预处理后的轨迹数据
        """
        # 确保时间戳已排序
        df = df.sort_values('timestamp')
        
        # 计算像素坐标
        rows, cols = self._convert_to_pixel_coords(df['latitude'].values, df['longitude'].values)
        df['row'] = rows
        df['col'] = cols
        
        # 计算时间差(秒)
        df['dt'] = df['timestamp'].diff().dt.total_seconds()
        
        # 计算位移和速度
        df['dx'] = df['longitude'].diff() * 111320 * np.cos(np.radians(df['latitude']))  # 米
        df['dy'] = df['latitude'].diff() * 111320  # 米
        df['distance'] = np.sqrt(df['dx']**2 + df['dy']**2)  # 米
        df['speed_mps'] = df['distance'] / df['dt']
        
        # 计算朝向(度)
        df['heading_degrees'] = np.degrees(np.arctan2(df['dx'], df['dy']))
        df['heading_degrees'] = (90 - df['heading_degrees']) % 360  # 转换为北为0
        
        # 计算转向率(度/秒)
        df['heading_change'] = df['heading_degrees'].diff()
        # 处理角度环绕
        df.loc[df['heading_change'] > 180, 'heading_change'] -= 360
        df.loc[df['heading_change'] < -180, 'heading_change'] += 360
        df['turn_rate_dps'] = df['heading_change'] / df['dt']
        
        # 计算加速度(米/秒²)
        df['acceleration_mps2'] = df['speed_mps'].diff() / df['dt']
        
        # 清理临时列和无效值
        df = df.drop(['dx', 'dy', 'distance', 'dt', 'heading_change'], axis=1)
        df = df.fillna(0)  # 第一个点的差分值设为0
        
        # 移除异常值
        df = self._remove_outliers(df)
        
        return df
    
    def _convert_to_pixel_coords(self, lats: np.ndarray, lons: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """将地理坐标转换为像素坐标
        
        Args:
            lats: 纬度数组
            lons: 经度数组
            
        Returns:
            Tuple[np.ndarray, np.ndarray]: (行坐标数组, 列坐标数组)
        """
        # 使用仿射变换矩阵进行转换
        cols, rows = ~self.transform * (lons, lats)
        
        # 确保坐标在有效范围内
        rows = np.clip(rows, 0, self.height - 1)
        cols = np.clip(cols, 0, self.width - 1)
        
        return rows.astype(int), cols.astype(int)
    
    def _remove_outliers(self, df: pd.DataFrame, speed_threshold: float = 50.0,
                        acc_threshold: float = 10.0, turn_rate_threshold: float = 90.0) -> pd.DataFrame:
        """移除异常值
        
        Args:
            df: 轨迹数据
            speed_threshold: 速度阈值(米/秒)
            acc_threshold: 加速度阈值(米/秒²)
            turn_rate_threshold: 转向率阈值(度/秒)
            
        Returns:
            pd.DataFrame: 清理后的数据
        """
        # 创建掩码
        mask = (
            (df['speed_mps'] <= speed_threshold) &
            (abs(df['acceleration_mps2']) <= acc_threshold) &
            (abs(df['turn_rate_dps']) <= turn_rate_threshold)
        )
        
        # 记录被移除的点数
        removed_count = (~mask).sum()
        if removed_count > 0:
            self.logger.warning(f"移除了 {removed_count} 个异常值")
        
        return df[mask].copy() 
```

### src/generator/environment_mapper.py
```python
"""环境地图生成器模块

此模块负责生成环境地图，包括：
1. 最大速度地图：基于坡度大小和土地覆盖类型
2. 典型速度地图：考虑坡度方向对速度的影响
3. 速度标准差地图：反映速度的变化程度
4. 成本地图：用于路径规划

输入:
    - 土地覆盖栅格文件 (.tif)
    - 坡度大小栅格文件 (.tif)
    - 坡度方向栅格文件 (.tif)

输出:
    - 最大速度地图 (max_speed_map.tif)
    - 典型速度地图 (typical_speed_map.tif)
    - 速度标准差地图 (speed_stddev_map.tif)
    - 成本地图 (cost_map.tif)
"""

import numpy as np
import rasterio
from pathlib import Path
import logging
from typing import Tuple, Optional
import os

from src.generator.config import (
    MAX_SPEED, MAX_SLOPE_THRESHOLD, SLOPE_SPEED_FACTOR,
    TYPICAL_SPEED_FACTOR, UP_SLOPE_FACTOR, DOWN_SLOPE_FACTOR, CROSS_SLOPE_FACTOR,
    BASE_SPEED_STDDEV_FACTOR, SLOPE_STDDEV_FACTOR, COMPLEX_TERRAIN_STDDEV_FACTOR,
    COMPLEX_TERRAIN_CODES, LANDCOVER_SPEED_FACTORS, LANDCOVER_COST_FACTORS,
    IMPASSABLE_LANDCOVER_CODES
)

class EnvironmentMapper:
    """环境地图生成器类"""
    
    def __init__(self, landcover_path: str, slope_magnitude_path: str, slope_aspect_path: str):
        """初始化环境地图生成器
        
        Args:
            landcover_path: 土地覆盖栅格文件路径
            slope_magnitude_path: 坡度大小栅格文件路径
            slope_aspect_path: 坡度方向栅格文件路径
        """
        # 检查文件是否存在
        for path in [landcover_path, slope_magnitude_path, slope_aspect_path]:
            if not Path(path).exists():
                raise FileNotFoundError(f"找不到文件: {path}")
        
        # 读取栅格数据
        with rasterio.open(landcover_path) as src:
            self.landcover_data = src.read(1)
            self.transform = src.transform
            self.meta = src.meta.copy()
            self.height = src.height
            self.width = src.width
        
        with rasterio.open(slope_magnitude_path) as src:
            self.slope_magnitude_data = src.read(1)
        
        with rasterio.open(slope_aspect_path) as src:
            self.slope_aspect_data = src.read(1)
        
        # 验证数据形状一致
        if not (self.landcover_data.shape == self.slope_magnitude_data.shape == self.slope_aspect_data.shape):
            raise ValueError("输入数据形状不一致")
        
        # 初始化日志
        self.logger = logging.getLogger(__name__)
    
    def calculate_max_speed_map(self) -> np.ndarray:
        """计算最大速度地图
        
        基于坡度大小和土地覆盖类型计算每个像素的最大可能速度。
        不可通行区域（水体、冰川、陡峭区域）的速度设为0。
        
        Returns:
            np.ndarray: 最大速度地图（米/秒）
        """
        # 初始化最大速度地图
        max_speed = np.full(self.landcover_data.shape, MAX_SPEED, dtype=np.float32)
        
        # 处理不可通行区域
        impassable_mask = np.isin(self.landcover_data, IMPASSABLE_LANDCOVER_CODES)
        steep_mask = self.slope_magnitude_data > MAX_SLOPE_THRESHOLD
        max_speed[impassable_mask | steep_mask] = 0
        
        # 应用坡度影响
        slope_factor = np.clip(1 - SLOPE_SPEED_FACTOR * self.slope_magnitude_data, 0.1, 1.0)
        max_speed *= slope_factor
        
        # 应用土地覆盖影响
        for code, factor in LANDCOVER_SPEED_FACTORS.items():
            landcover_mask = self.landcover_data == code
            max_speed[landcover_mask] *= factor
        
        return max_speed
    
    def calculate_typical_speed_map(self) -> np.ndarray:
        """计算典型速度地图
        
        基于最大速度，考虑坡度方向对速度的影响。
        上坡时速度降低，下坡时速度略有提升，横坡时速度显著降低。
        
        Returns:
            np.ndarray: 典型速度地图（米/秒）
        """
        # 获取基础最大速度
        typical_speed = self.calculate_max_speed_map() * TYPICAL_SPEED_FACTOR
        
        # 处理平地（坡向为-1）
        flat_mask = self.slope_aspect_data == -1
        typical_speed[flat_mask] *= 1.0  # 平地不需要额外调整
        
        # 处理有坡度的区域
        slope_mask = ~flat_mask
        if np.any(slope_mask):
            # 计算不同方向的影响因子
            # 这里假设我们主要考虑南北方向的运动
            # 坡向0度是北向，180度是南向
            north_factor = np.where(
                self.slope_aspect_data < 90,
                1 - UP_SLOPE_FACTOR * self.slope_magnitude_data,
                1.0
            )
            south_factor = np.where(
                self.slope_aspect_data > 90,
                1 + DOWN_SLOPE_FACTOR * self.slope_magnitude_data,
                1.0
            )
            
            # 计算横坡影响（东西方向）
            cross_slope_factor = np.where(
                (self.slope_aspect_data >= 45) & (self.slope_aspect_data <= 135) |
                (self.slope_aspect_data >= 225) & (self.slope_aspect_data <= 315),
                1 - CROSS_SLOPE_FACTOR * self.slope_magnitude_data,
                1.0
            )
            
            # 组合所有影响因子
            combined_factor = np.minimum(north_factor, south_factor) * cross_slope_factor
            combined_factor = np.clip(combined_factor, 0.1, 1.2)  # 限制因子范围
            
            # 应用到典型速度
            typical_speed[slope_mask] *= combined_factor[slope_mask]
        
        return typical_speed
    
    def calculate_speed_stddev_map(self) -> np.ndarray:
        """计算速度标准差地图
        
        基于典型速度和地形复杂度计算速度的标准差。
        复杂地形（如山地）的标准差较大，平坦区域的标准差较小。
        
        Returns:
            np.ndarray: 速度标准差地图（米/秒）
        """
        # 获取典型速度
        typical_speed = self.calculate_typical_speed_map()
        
        # 初始化标准差地图
        speed_stddev = typical_speed * BASE_SPEED_STDDEV_FACTOR
        
        # 处理不可通行区域
        impassable_mask = np.isin(self.landcover_data, IMPASSABLE_LANDCOVER_CODES)
        steep_mask = self.slope_magnitude_data > MAX_SLOPE_THRESHOLD
        speed_stddev[impassable_mask | steep_mask] = 0
        
        # 增加复杂地形的标准差
        complex_mask = np.isin(self.landcover_data, COMPLEX_TERRAIN_CODES)
        speed_stddev[complex_mask] *= COMPLEX_TERRAIN_STDDEV_FACTOR
        
        # 根据坡度增加标准差
        slope_stddev_factor = np.clip(
            1 + SLOPE_STDDEV_FACTOR * (self.slope_magnitude_data / MAX_SLOPE_THRESHOLD),
            1.0,
            2.0
        )
        speed_stddev *= slope_stddev_factor
        
        return speed_stddev
    
    def calculate_cost_map(self) -> np.ndarray:
        """计算成本地图
        
        基于典型速度和土地覆盖类型计算通行成本。
        不可通行区域的成本设为无穷大。
        
        Returns:
            np.ndarray: 成本地图（秒/米）
        """
        # 获取典型速度
        typical_speed = self.calculate_typical_speed_map()
        
        # 初始化成本地图
        cost = np.zeros_like(typical_speed)
        
        # 处理不可通行区域
        impassable_mask = np.isin(self.landcover_data, IMPASSABLE_LANDCOVER_CODES)
        steep_mask = self.slope_magnitude_data > MAX_SLOPE_THRESHOLD
        cost[impassable_mask | steep_mask] = np.inf
        
        # 计算可通行区域的成本
        passable_mask = ~(impassable_mask | steep_mask)
        cost[passable_mask] = 1 / typical_speed[passable_mask]  # 基础成本：单位距离所需时间
        
        # 应用土地覆盖成本因子
        for code, factor in LANDCOVER_COST_FACTORS.items():
            landcover_mask = self.landcover_data == code
            cost[landcover_mask & passable_mask] *= factor
        
        return cost
    
    def save_environment_maps(
        self,
        output_dir: str,
        max_speed_map: np.ndarray,
        typical_speed_map: np.ndarray,
        speed_stddev_map: np.ndarray,
        cost_map: np.ndarray
    ) -> None:
        """保存环境地图
        
        Args:
            output_dir: 输出目录路径
            max_speed_map: 最大速度地图
            typical_speed_map: 典型速度地图
            speed_stddev_map: 速度标准差地图
            cost_map: 成本地图
        """
        # 确保输出目录存在
        os.makedirs(output_dir, exist_ok=True)
        
        # 准备元数据
        meta = self.meta.copy()
        meta.update(dtype=np.float32)
        
        # 保存最大速度地图
        with rasterio.open(os.path.join(output_dir, "max_speed_map.tif"), 'w', **meta) as dst:
            dst.write(max_speed_map.astype(np.float32), 1)
        
        # 保存典型速度地图
        with rasterio.open(os.path.join(output_dir, "typical_speed_map.tif"), 'w', **meta) as dst:
            dst.write(typical_speed_map.astype(np.float32), 1)
        
        # 保存速度标准差地图
        with rasterio.open(os.path.join(output_dir, "speed_stddev_map.tif"), 'w', **meta) as dst:
            dst.write(speed_stddev_map.astype(np.float32), 1)
        
        # 保存成本地图
        with rasterio.open(os.path.join(output_dir, "cost_map.tif"), 'w', **meta) as dst:
            dst.write(cost_map.astype(np.float32), 1)
        
        self.logger.info(f"环境地图已保存到目录: {output_dir}")
    
    def get_environment_params(self, row: int, col: int) -> dict:
        """获取指定位置的环境参数
        
        Args:
            row: 像素行号（从0开始）
            col: 像素列号（从0开始）
            
        Returns:
            包含环境参数的字典：
            {
                'max_speed': 最大速度 (m/s),
                'typical_speed': 典型速度 (m/s),
                'speed_stddev': 速度标准差 (m/s),
                'cost': 移动成本 (s/m),
                'landcover': 土地覆盖类型代码,
                'slope_magnitude': 坡度大小 (度),
                'slope_aspect': 坡向 (度),
                'is_passable': 是否可通行
            }
        
        Raises:
            ValueError: 如果位置超出范围
        """
        # 检查位置是否在有效范围内
        if not (0 <= row < self.height and 0 <= col < self.width):
            raise ValueError(f"位置 ({row}, {col}) 超出范围")
        
        # 获取土地覆盖和坡度信息
        landcover = self.landcover_data[row, col]
        slope_magnitude = self.slope_magnitude_data[row, col]
        slope_aspect = self.slope_aspect_data[row, col]
        
        # 判断是否可通行
        is_passable = (
            landcover not in IMPASSABLE_LANDCOVER_CODES and
            slope_magnitude <= MAX_SLOPE_THRESHOLD
        )
        
        # 获取环境参数
        max_speed = self.calculate_max_speed_map()[row, col]
        typical_speed = self.calculate_typical_speed_map()[row, col]
        speed_stddev = self.calculate_speed_stddev_map()[row, col]
        cost = self.calculate_cost_map()[row, col]
        
        return {
            'max_speed': float(max_speed),
            'typical_speed': float(typical_speed),
            'speed_stddev': float(speed_stddev),
            'cost': float(cost),
            'landcover': int(landcover),
            'slope_magnitude': float(slope_magnitude),
            'slope_aspect': float(slope_aspect),
            'is_passable': bool(is_passable)
        } 
```

### src/generator/evaluator.py
```python
"""轨迹评估器模块

负责评估生成的轨迹与OORD数据的相似度。

输入:
- 生成的轨迹数据
- OORD参考数据
- 环境数据

输出:
- 评估报告（图表和统计数据）
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
from typing import List, Dict, Tuple
import logging
from pathlib import Path
import json

logger = logging.getLogger(__name__)

class Evaluator:
    """轨迹评估器类"""

    def __init__(self, config: dict, output_dir: str):
        """初始化评估器

        Args:
            config: 配置字典
            output_dir: 输出目录路径
        """
        self.config = config
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # 设置图表样式
        plt.style.use('seaborn')
        sns.set_palette("husl")

    def load_synthetic_data(self, batch_dir: str) -> pd.DataFrame:
        """加载生成的轨迹数据

        Args:
            batch_dir: 批处理输出目录

        Returns:
            pd.DataFrame: 包含所有生成轨迹的DataFrame
        """
        logger.info(f"加载生成的轨迹数据: {batch_dir}")
        
        # 读取所有轨迹文件
        trajectories = []
        batch_path = Path(batch_dir)
        for traj_file in batch_path.glob("trajectory_*.csv"):
            df = pd.read_csv(traj_file)
            df['trajectory_id'] = traj_file.stem
            trajectories.append(df)

        # 合并所有轨迹
        if not trajectories:
            raise ValueError(f"在 {batch_dir} 中未找到轨迹文件")
            
        return pd.concat(trajectories, ignore_index=True)

    def load_processed_oord_data(self, oord_path: str) -> pd.DataFrame:
        """加载处理好的OORD数据

        Args:
            oord_path: OORD数据文件路径

        Returns:
            pd.DataFrame: OORD数据
        """
        logger.info(f"加载OORD参考数据: {oord_path}")
        return pd.read_csv(oord_path)

    def compare_global_distributions(self, synthetic_df: pd.DataFrame,
                                  oord_df: pd.DataFrame) -> Dict:
        """比较全局统计分布

        Args:
            synthetic_df: 生成的轨迹数据
            oord_df: OORD参考数据

        Returns:
            Dict: 比较结果
        """
        logger.info("比较全局统计分布...")
        
        results = {}
        
        # 比较速度分布
        self._compare_distribution(
            synthetic_df['speed_mps'],
            oord_df['speed_mps'],
            'speed_distribution.png',
            '速度分布对比 (m/s)',
            results
        )
        
        # 比较加速度分布
        synthetic_acc = synthetic_df.groupby('trajectory_id')['speed_mps'].diff() / \
                       synthetic_df.groupby('trajectory_id')['timestamp'].diff()
        oord_acc = oord_df.groupby('trajectory_id')['speed_mps'].diff() / \
                  oord_df.groupby('trajectory_id')['timestamp'].diff()
        
        self._compare_distribution(
            synthetic_acc,
            oord_acc,
            'acceleration_distribution.png',
            '加速度分布对比 (m/s²)',
            results
        )
        
        # 比较转向率分布
        synthetic_turn = synthetic_df.groupby('trajectory_id')['heading_degrees'].diff() / \
                        synthetic_df.groupby('trajectory_id')['timestamp'].diff()
        oord_turn = oord_df.groupby('trajectory_id')['heading_degrees'].diff() / \
                   oord_df.groupby('trajectory_id')['timestamp'].diff()
        
        self._compare_distribution(
            synthetic_turn,
            oord_turn,
            'turn_rate_distribution.png',
            '转向率分布对比 (度/s)',
            results
        )
        
        return results

    def compare_environment_interaction(self, synthetic_df: pd.DataFrame,
                                     oord_df: pd.DataFrame) -> Dict:
        """比较与环境的交互特征

        Args:
            synthetic_df: 生成的轨迹数据
            oord_df: OORD参考数据

        Returns:
            Dict: 比较结果
        """
        logger.info("比较环境交互特征...")
        
        results = {}
        
        # 按坡度等级分组比较
        slope_bins = self.config['SLOPE_BINS']
        synthetic_df['slope_group'] = pd.cut(synthetic_df['slope_magnitude'],
                                           bins=slope_bins,
                                           labels=[f"{a:.1f}-{b:.1f}" for a, b in 
                                                 zip(slope_bins[:-1], slope_bins[1:])])
        oord_df['slope_group'] = pd.cut(oord_df['slope_magnitude'],
                                       bins=slope_bins,
                                       labels=[f"{a:.1f}-{b:.1f}" for a, b in 
                                             zip(slope_bins[:-1], slope_bins[1:])])
        
        # 绘制不同坡度下的速度箱线图
        plt.figure(figsize=(12, 6))
        plt.subplot(121)
        sns.boxplot(data=synthetic_df, x='slope_group', y='speed_mps')
        plt.title('生成轨迹: 坡度-速度关系')
        plt.xticks(rotation=45)
        
        plt.subplot(122)
        sns.boxplot(data=oord_df, x='slope_group', y='speed_mps')
        plt.title('OORD数据: 坡度-速度关系')
        plt.xticks(rotation=45)
        
        plt.tight_layout()
        plt.savefig(self.output_dir / 'slope_speed_relationship.png')
        plt.close()
        
        # 计算每个坡度组的统计量
        for slope_group in synthetic_df['slope_group'].unique():
            syn_speeds = synthetic_df[synthetic_df['slope_group'] == slope_group]['speed_mps']
            oord_speeds = oord_df[oord_df['slope_group'] == slope_group]['speed_mps']
            
            results[f'slope_group_{slope_group}'] = {
                'synthetic_mean': syn_speeds.mean(),
                'oord_mean': oord_speeds.mean(),
                'synthetic_std': syn_speeds.std(),
                'oord_std': oord_speeds.std(),
                'ks_statistic': stats.ks_2samp(syn_speeds, oord_speeds).statistic
            }
        
        return results

    def _compare_distribution(self, synthetic_data: pd.Series,
                            oord_data: pd.Series,
                            output_filename: str,
                            title: str,
                            results: Dict) -> None:
        """比较两个分布并生成可视化

        Args:
            synthetic_data: 生成的数据
            oord_data: OORD参考数据
            output_filename: 输出文件名
            title: 图表标题
            results: 结果字典
        """
        # 计算统计量
        syn_stats = {
            'mean': synthetic_data.mean(),
            'std': synthetic_data.std(),
            'median': synthetic_data.median(),
            'q1': synthetic_data.quantile(0.25),
            'q3': synthetic_data.quantile(0.75)
        }
        
        oord_stats = {
            'mean': oord_data.mean(),
            'std': oord_data.std(),
            'median': oord_data.median(),
            'q1': oord_data.quantile(0.25),
            'q3': oord_data.quantile(0.75)
        }
        
        # 执行K-S检验
        ks_stat, p_value = stats.ks_2samp(synthetic_data.dropna(),
                                         oord_data.dropna())
        
        # 绘制分布对比图
        plt.figure(figsize=(10, 6))
        sns.kdeplot(data=synthetic_data, label='生成轨迹')
        sns.kdeplot(data=oord_data, label='OORD数据')
        plt.title(title)
        plt.legend()
        plt.grid(True)
        plt.savefig(self.output_dir / output_filename)
        plt.close()
        
        # 保存结果
        metric_name = output_filename.split('.')[0]
        results[metric_name] = {
            'synthetic_stats': syn_stats,
            'oord_stats': oord_stats,
            'ks_test': {
                'statistic': ks_stat,
                'p_value': p_value
            }
        }

    def save_report(self, results: Dict) -> None:
        """保存评估报告

        Args:
            results: 评估结果
        """
        # 保存JSON格式的详细结果
        with open(self.output_dir / 'evaluation_results.json', 'w') as f:
            json.dump(results, f, indent=4)
        
        # 生成文本报告
        report_lines = [
            "轨迹生成评估报告",
            "=" * 50,
            "",
            "1. 全局统计比较",
            "-" * 20
        ]
        
        for metric, data in results.items():
            if metric.endswith('_distribution'):
                report_lines.extend([
                    f"\n{metric.replace('_', ' ').title()}:",
                    f"生成轨迹: 均值={data['synthetic_stats']['mean']:.2f}, "
                    f"标准差={data['synthetic_stats']['std']:.2f}",
                    f"OORD数据: 均值={data['oord_stats']['mean']:.2f}, "
                    f"标准差={data['oord_stats']['std']:.2f}",
                    f"K-S检验: 统计量={data['ks_test']['statistic']:.3f}, "
                    f"p值={data['ks_test']['p_value']:.3f}"
                ])
        
        report_lines.extend([
            "",
            "2. 环境交互分析",
            "-" * 20
        ])
        
        for key, data in results.items():
            if key.startswith('slope_group'):
                report_lines.extend([
                    f"\n{key}:",
                    f"生成轨迹: 均值={data['synthetic_mean']:.2f}, "
                    f"标准差={data['synthetic_std']:.2f}",
                    f"OORD数据: 均值={data['oord_mean']:.2f}, "
                    f"标准差={data['oord_std']:.2f}",
                    f"K-S统计量: {data['ks_statistic']:.3f}"
                ])
        
        # 保存文本报告
        with open(self.output_dir / 'evaluation_report.txt', 'w') as f:
            f.write('\n'.join(report_lines))
        
        logger.info(f"评估报告已保存到: {self.output_dir}")

    def evaluate_batch(self, batch_dir: str, oord_path: str) -> None:
        """评估一批生成的轨迹

        Args:
            batch_dir: 批处理输出目录
            oord_path: OORD数据文件路径
        """
        # 加载数据
        synthetic_df = self.load_synthetic_data(batch_dir)
        oord_df = self.load_processed_oord_data(oord_path)
        
        # 执行评估
        results = {}
        results.update(self.compare_global_distributions(synthetic_df, oord_df))
        results.update(self.compare_environment_interaction(synthetic_df, oord_df))
        
        # 保存报告
        self.save_report(results) 
```

### src/generator/motion_simulator.py
```python
"""运动模拟器模块

负责模拟目标在给定路径上的运动，考虑环境因素（坡度、土地覆盖）对速度和方向的影响。

输入参数:
- 路径点列表
- 环境参数（最大速度、典型速度、速度标准差）
- 运动约束（最大加速度、最大减速度、最大转向率）

输出:
- 轨迹点列表，包含时间戳、位置、速度和朝向
"""

import logging
import numpy as np
from typing import List, Tuple, Dict, Optional
from dataclasses import dataclass

# 配置日志
logger = logging.getLogger(__name__)

@dataclass
class MotionConstraints:
    """运动约束参数"""
    max_acceleration: float = 2.0  # 最大加速度 (m/s^2)
    max_deceleration: float = 4.0  # 最大减速度 (m/s^2)
    max_turn_rate: float = 45.0    # 最大转向率 (度/秒)
    min_speed: float = 0.0         # 最小速度 (m/s)
    time_step: float = 1.0         # 模拟时间步长 (秒)
    max_iterations: int = 10000    # 最大迭代次数
    position_threshold: float = 0.1  # 位置判断阈值 (m)

@dataclass
class EnvironmentParams:
    """环境参数
    
    Attributes:
        max_speed: 最大允许速度 (m/s)
        typical_speed: 典型速度 (m/s)
        speed_stddev: 速度标准差 (m/s)
        slope_magnitude: 坡度大小 (度)
        slope_aspect: 坡向角度 (度，北为0，顺时针)
        landcover_code: 土地覆盖类型编码
    """
    max_speed: float       # 最大允许速度 (m/s)
    typical_speed: float   # 典型速度 (m/s)
    speed_stddev: float   # 速度标准差 (m/s)
    slope_magnitude: float = 0.0  # 坡度大小 (度)
    slope_aspect: float = 0.0     # 坡向角度 (度，北为0，顺时针)
    landcover_code: int = 0       # 土地覆盖类型编码

@dataclass
class TerrainConstraints:
    """地形约束参数"""
    max_uphill_slope: float = 30.0    # 最大上坡坡度 (度)
    max_downhill_slope: float = 35.0  # 最大下坡坡度 (度)
    max_cross_slope: float = 25.0     # 最大横坡坡度 (度)
    k_uphill: float = 0.1             # 上坡减速系数
    k_downhill: float = 0.05          # 下坡加速系数
    k_cross: float = 0.2              # 横坡减速系数
    min_speed_steep_slope: float = 0.5 # 陡坡最小速度 (m/s)

class MotionSimulator:
    """运动模拟器类"""

    def __init__(self, motion_constraints: Optional[MotionConstraints] = None,
                 terrain_constraints: Optional[TerrainConstraints] = None):
        """初始化运动模拟器

        Args:
            motion_constraints: 运动约束参数，如果为None则使用默认值
            terrain_constraints: 地形约束参数，如果为None则使用默认值
        """
        self.motion_constraints = motion_constraints or MotionConstraints()
        self.terrain_constraints = terrain_constraints or TerrainConstraints()
        
        # 用于速度随机性的高斯噪声参数
        self.speed_noise_scale = 0.1  # 速度噪声比例
        self.heading_noise_scale = 2.0  # 朝向噪声（度）

    def _calculate_slope_effects(self, current_heading: float,
                              env_params: EnvironmentParams) -> Tuple[float, float, float]:
        """计算坡度对速度的影响

        Args:
            current_heading: 当前朝向 (度)
            env_params: 环境参数

        Returns:
            Tuple[float, float, float]: (纵向坡度, 横向坡度, 速度调整系数)
        """
        # 如果没有坡度信息，返回默认值
        if env_params.slope_magnitude == 0:
            return 0.0, 0.0, 1.0

        # 计算行驶方向与坡向的夹角
        delta_angle = current_heading - env_params.slope_aspect
        delta_angle_rad = np.radians(delta_angle)

        # 计算纵向坡度（上下坡）和横向坡度
        slope_along_path = env_params.slope_magnitude * np.cos(delta_angle_rad)
        cross_slope = env_params.slope_magnitude * abs(np.sin(delta_angle_rad))

        # 计算速度调整系数
        speed_factor = 1.0

        # 上坡减速
        if slope_along_path > 0:
            if slope_along_path > self.terrain_constraints.max_uphill_slope:
                speed_factor = 0.0  # 超过最大上坡坡度，无法通行
            else:
                reduction = max(0.1, 1 - self.terrain_constraints.k_uphill * slope_along_path)
                speed_factor *= reduction

        # 下坡加速/减速
        else:
            slope_down = -slope_along_path
            if slope_down > self.terrain_constraints.max_downhill_slope:
                speed_factor = 0.0  # 超过最大下坡坡度，无法通行
            else:
                # 下坡时轻微加速，但需要考虑制动限制
                factor = 1 + self.terrain_constraints.k_downhill * slope_down
                speed_factor *= min(factor, 1.2)  # 最多增加20%速度

        # 横坡减速
        if cross_slope > 0:
            if cross_slope > self.terrain_constraints.max_cross_slope:
                speed_factor = 0.0  # 超过最大横坡坡度，无法通行
            else:
                # 使用二次函数使横坡影响更敏感
                reduction = max(0.1, 1 - self.terrain_constraints.k_cross * (cross_slope ** 2))
                speed_factor *= reduction

        # 确保速度不会过低（除非完全无法通行）
        if speed_factor > 0:
            speed_factor = max(speed_factor, 
                             self.terrain_constraints.min_speed_steep_slope / env_params.typical_speed)

        return slope_along_path, cross_slope, speed_factor

    def _calculate_target_speed(self, env_params: EnvironmentParams,
                              current_heading: float) -> float:
        """计算目标速度，考虑环境限制、坡度影响和随机性

        Args:
            env_params: 环境参数
            current_heading: 当前朝向 (度)

        Returns:
            目标速度 (m/s)
        """
        # 基础目标速度是典型速度
        base_speed = env_params.typical_speed
        
        # 计算坡度影响
        _, _, speed_factor = self._calculate_slope_effects(current_heading, env_params)
        
        # 应用坡度影响
        base_speed *= speed_factor
        
        # 添加随机扰动（高斯噪声）
        noise = np.random.normal(0, env_params.speed_stddev * self.speed_noise_scale)
        target_speed = base_speed + noise
        
        # 限制在合理范围内
        target_speed = np.clip(
            target_speed,
            self.motion_constraints.min_speed,
            min(env_params.max_speed, env_params.typical_speed * 1.5)
        )
        
        return target_speed

    def simulate_motion(self, path: List[Tuple[float, float]],
                       env_params_func) -> List[Tuple[float, float, float, float, float]]:
        """模拟目标在给定路径上的运动

        Args:
            path: 路径点列表 [(lon, lat), ...]
            env_params_func: 函数，输入(lon, lat)返回对应位置的EnvironmentParams

        Returns:
            轨迹点列表 [(timestamp, lon, lat, speed, heading), ...]
        """
        if len(path) < 2:
            raise ValueError("路径至少需要包含两个点")

        # 初始化轨迹
        trajectory = []
        current_time = 0.0
        current_pos = path[0]
        current_speed = 0.0
        current_heading = self._calculate_initial_heading(path[0], path[1])
        
        # 添加初始点
        trajectory.append((
            current_time,
            current_pos[0],
            current_pos[1],
            current_speed,
            current_heading
        ))

        # 遍历路径点
        path_index = 1
        iteration_count = 0
        
        while path_index < len(path) and iteration_count < self.motion_constraints.max_iterations:
            # 获取目标点
            target_pos = path[path_index]
            
            # 获取当前位置的环境参数
            env_params = env_params_func(current_pos[0], current_pos[1])
            
            # 计算到目标点的距离和方向
            distance = self._calculate_distance(current_pos, target_pos)
            target_heading = self._calculate_heading(current_pos, target_pos)
            
            # 如果已经接近目标点，移动到下一个目标点
            if distance < self.motion_constraints.position_threshold:
                current_pos = target_pos  # 直接移动到目标点
                path_index += 1
                
                # 更新时间和轨迹点
                current_time += self.motion_constraints.time_step
                trajectory.append((
                    current_time,
                    current_pos[0],
                    current_pos[1],
                    current_speed,
                    current_heading
                ))
                
                if path_index < len(path):
                    target_pos = path[path_index]
                    target_heading = self._calculate_heading(current_pos, target_pos)
                    distance = self._calculate_distance(current_pos, target_pos)
                else:
                    # 到达终点，添加最后一个点并退出
                    current_time += self.motion_constraints.time_step
                    trajectory.append((
                        current_time,
                        current_pos[0],
                        current_pos[1],
                        0.0,  # 终点速度为0
                        current_heading
                    ))
                    break
                continue
            
            # 计算目标速度（考虑环境限制、坡度影响和随机性）
            target_speed = self._calculate_target_speed(env_params, current_heading)
            
            # 调整速度和朝向
            current_speed = self._adjust_speed(
                current_speed, target_speed, self.motion_constraints.time_step)
            current_heading = self._adjust_heading(
                current_heading, target_heading, self.motion_constraints.time_step)
            
            # 计算新位置（使用弧度进行计算）
            heading_rad = np.radians(current_heading)
            movement = current_speed * self.motion_constraints.time_step
            
            # 根据当前位置到目标点的距离来调整移动量
            scale = min(1.0, distance / movement) if movement > 0 else 1.0
            movement *= scale
            
            # 计算位置增量
            dx = movement * np.sin(heading_rad)  # 东西方向
            dy = movement * np.cos(heading_rad)  # 南北方向
            
            # 更新位置
            new_pos = (
                current_pos[0] + dx,
                current_pos[1] + dy
            )
            
            # 更新时间和位置
            current_time += self.motion_constraints.time_step
            current_pos = new_pos
            
            # 添加轨迹点
            trajectory.append((
                current_time,
                current_pos[0],
                current_pos[1],
                current_speed,
                current_heading
            ))
            
            iteration_count += 1

        if iteration_count >= self.motion_constraints.max_iterations:
            logger.warning(f"达到最大迭代次数 {self.motion_constraints.max_iterations}")

        return trajectory

    def _adjust_speed(self, current_speed: float,
                     target_speed: float,
                     dt: float) -> float:
        """调整速度，考虑加速度限制

        Args:
            current_speed: 当前速度 (m/s)
            target_speed: 目标速度 (m/s)
            dt: 时间步长 (秒)

        Returns:
            新的速度 (m/s)
        """
        speed_diff = target_speed - current_speed
        
        # 根据加速或减速选择合适的限制
        max_change = (self.motion_constraints.max_acceleration if speed_diff > 0
                     else self.motion_constraints.max_deceleration) * dt
        
        # 限制速度变化
        actual_change = np.clip(speed_diff, -max_change, max_change)
        new_speed = current_speed + actual_change
        
        return max(new_speed, self.motion_constraints.min_speed)

    def _adjust_heading(self, current_heading: float,
                       target_heading: float,
                       dt: float) -> float:
        """调整朝向，考虑转向率限制

        Args:
            current_heading: 当前朝向 (度)
            target_heading: 目标朝向 (度)
            dt: 时间步长 (秒)

        Returns:
            新的朝向 (度)
        """
        # 计算需要转向的角度（处理角度环绕）
        heading_diff = target_heading - current_heading
        if heading_diff > 180:
            heading_diff -= 360
        elif heading_diff < -180:
            heading_diff += 360
            
        # 添加随机扰动
        noise = np.random.normal(0, self.heading_noise_scale)
        heading_diff += noise
        
        # 限制转向率
        max_turn = self.motion_constraints.max_turn_rate * dt
        actual_turn = np.clip(heading_diff, -max_turn, max_turn)
        
        # 计算新的朝向（保持在0-360度范围内）
        new_heading = (current_heading + actual_turn) % 360
            
        return new_heading

    def _calculate_distance(self, pos1: Tuple[float, float],
                          pos2: Tuple[float, float]) -> float:
        """计算两点之间的欧氏距离"""
        return np.sqrt(
            (pos2[0] - pos1[0]) ** 2 +
            (pos2[1] - pos1[1]) ** 2
        )

    def _calculate_heading(self, pos1: Tuple[float, float],
                         pos2: Tuple[float, float]) -> float:
        """计算从pos1到pos2的朝向角（北为0度，顺时针）

        Args:
            pos1: 起始位置 (lon, lat)
            pos2: 目标位置 (lon, lat)

        Returns:
            朝向角（度）：北为0度，东为90度，南为180度，西为270度
        """
        dx = pos2[0] - pos1[0]  # 经度差（东西方向）
        dy = pos2[1] - pos1[1]  # 纬度差（南北方向）
        
        # 使用arctan2计算角度（弧度）
        # 注意：arctan2(y, x)的参数顺序，我们需要交换dx和dy来得到正确的角度
        angle_rad = np.arctan2(dx, dy)
        
        # 转换为度数并调整为以北为0度，东为90度
        angle_deg = np.degrees(angle_rad)
        # 如果角度为负，加360度使其在[0, 360)范围内
        if angle_deg < 0:
            angle_deg += 360
            
        return float(angle_deg)  # 确保返回Python float类型

    def _calculate_initial_heading(self, start_pos: Tuple[float, float],
                                 next_pos: Tuple[float, float]) -> float:
        """计算初始朝向"""
        return self._calculate_heading(start_pos, next_pos) 
```

### src/generator/oord_analyzer.py
```python
"""OORD数据分析器模块

此模块负责分析OORD轨迹数据中的运动特性与环境交互，功能包括：
1. 关联环境信息（高程、坡度、坡向、土地覆盖）
2. 定义环境分组
3. 分组统计分析
4. 建立环境-运动规则模型

输入:
    - 预处理后的OORD轨迹数据
    - 环境数据（DEM、坡度、坡向、土地覆盖）

输出:
    - 环境-运动规则模型
    - 统计分析结果
"""

import pandas as pd
import numpy as np
from pathlib import Path
import logging
from typing import Dict, List, Tuple, Optional
import json
from dataclasses import dataclass
from sklearn.preprocessing import KBinsDiscretizer

@dataclass
class EnvironmentGroup:
    """环境组数据类"""
    group_label: str  # 环境组标签
    landcover_code: int  # 土地覆盖编码
    slope_bin: int  # 坡度等级
    count: int  # 样本数量
    max_speed: float  # 最大速度
    typical_speed: float  # 典型速度
    speed_stddev: float  # 速度标准差
    max_turn_rate: float  # 最大转向率
    typical_turn_rate: float  # 典型转向率
    max_acceleration: float  # 最大加速度
    typical_acceleration: float  # 典型加速度

class OORDAnalyzer:
    """OORD数据分析器类"""
    
    def __init__(self, slope_bins: List[float], min_samples_per_group: int = 100):
        """初始化分析器
        
        Args:
            slope_bins: 坡度分组边界值列表
            min_samples_per_group: 每个环境组的最小样本数
        """
        self.slope_bins = slope_bins
        self.min_samples_per_group = min_samples_per_group
        self.logger = logging.getLogger(__name__)
        self.environment_groups: Dict[str, EnvironmentGroup] = {}
    
    def add_environment_info(self, df: pd.DataFrame,
                           dem_data: np.ndarray,
                           slope_data: np.ndarray,
                           aspect_data: np.ndarray,
                           landcover_data: np.ndarray) -> pd.DataFrame:
        """添加环境信息到轨迹数据
        
        Args:
            df: 预处理后的轨迹数据
            dem_data: DEM数据
            slope_data: 坡度数据
            aspect_data: 坡向数据
            landcover_data: 土地覆盖数据
            
        Returns:
            pd.DataFrame: 添加环境信息后的数据
            
        Raises:
            ValueError: 当数据缺少必要的列或数据形状不匹配时
        """
        # 检查必要的列
        required_cols = ['row', 'col']
        if 'heading_degrees' in df.columns:
            required_cols.append('heading_degrees')
        
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            raise ValueError(f"数据缺少必要的列: {missing_cols}")
            
        # 检查数据形状是否一致
        shape = dem_data.shape
        if (slope_data.shape != shape or
            aspect_data.shape != shape or
            landcover_data.shape != shape):
            raise ValueError(f"所有环境数据的形状必须一致。DEM形状: {shape}, "
                          f"坡度形状: {slope_data.shape}, "
                          f"坡向形状: {aspect_data.shape}, "
                          f"土地覆盖形状: {landcover_data.shape}")
        
        # 检查像素坐标是否在范围内
        if (df['row'].max() >= shape[0] or
            df['col'].max() >= shape[1] or
            df['row'].min() < 0 or
            df['col'].min() < 0):
            raise ValueError(f"像素坐标超出范围。数据形状: {shape}, "
                          f"行范围: [{df['row'].min()}, {df['row'].max()}], "
                          f"列范围: [{df['col'].min()}, {df['col'].max()}]")
        
        # 使用像素坐标获取环境数据
        df['elevation'] = dem_data[df['row'].values, df['col'].values]
        df['slope_magnitude'] = slope_data[df['row'].values, df['col'].values]
        df['slope_aspect'] = aspect_data[df['row'].values, df['col'].values]
        df['landcover'] = landcover_data[df['row'].values, df['col'].values]
        
        # 如果有朝向数据，计算方向性坡度
        if 'heading_degrees' in df.columns:
            # 计算行驶方向与坡向的关系
            df['delta_angle'] = df['heading_degrees'] - df['slope_aspect']
            # 处理角度环绕
            df.loc[df['delta_angle'] > 180, 'delta_angle'] -= 360
            df.loc[df['delta_angle'] < -180, 'delta_angle'] += 360
            
            # 计算方向性坡度
            df['slope_along_path'] = df['slope_magnitude'] * np.cos(np.radians(df['delta_angle']))
            df['cross_slope'] = df['slope_magnitude'] * np.abs(np.sin(np.radians(df['delta_angle'])))
        
        # 添加坡度等级
        df['slope_bin'] = pd.cut(df['slope_magnitude'],
                               bins=self.slope_bins,
                               labels=range(len(self.slope_bins)-1))
        
        # 创建环境组标签
        df['group_label'] = df.apply(
            lambda x: f"LC{x['landcover']}_S{x['slope_bin']}",
            axis=1
        )
        
        return df
    
    def analyze_groups(self, df: pd.DataFrame) -> None:
        """对每个环境组进行统计分析
        
        Args:
            df: 包含环境信息的轨迹数据
        """
        # 检查必要的列
        required_cols = ['speed_mps', 'turn_rate_dps', 'acceleration_mps2']
        if not all(col in df.columns for col in required_cols):
            raise ValueError(f"数据缺少必要的列: {required_cols}")
        
        # 按环境组分组
        groups = df.groupby('group_label')
        
        # 分析每个组
        for group_label, group_data in groups:
            # 检查样本数量
            if len(group_data) < self.min_samples_per_group:
                self.logger.warning(f"组 {group_label} 样本数量不足，跳过")
                continue
            
            # 提取landcover和slope_bin
            landcover_code = int(group_data['landcover'].iloc[0])  # 转换为Python int
            slope_bin = int(group_data['slope_bin'].iloc[0])  # 转换为Python int
            
            # 创建环境组对象
            self.environment_groups[group_label] = EnvironmentGroup(
                group_label=group_label,
                landcover_code=landcover_code,
                slope_bin=slope_bin,
                count=int(len(group_data)),  # 转换为Python int
                max_speed=float(np.percentile(group_data['speed_mps'], 95)),
                typical_speed=float(group_data['speed_mps'].median()),
                speed_stddev=float(group_data['speed_mps'].std()),
                max_turn_rate=float(np.percentile(abs(group_data['turn_rate_dps']), 95)),
                typical_turn_rate=float(group_data['turn_rate_dps'].median()),
                max_acceleration=float(np.percentile(abs(group_data['acceleration_mps2']), 95)),
                typical_acceleration=float(group_data['acceleration_mps2'].median())
            )
    
    def analyze_slope_direction_effect(self, df: pd.DataFrame) -> Dict:
        """分析坡向对速度的影响
        
        Args:
            df: 包含环境信息的轨迹数据
            
        Returns:
            Dict: 坡向影响系数
        """
        # 检查必要的列
        required_cols = ['slope_along_path', 'cross_slope', 'speed_mps']
        if not all(col in df.columns for col in required_cols):
            raise ValueError(f"数据缺少必要的列: {required_cols}")
        
        # 初始化结果字典
        effect_params = {}
        
        # 按landcover分组分析
        for landcover in df['landcover'].unique():
            lc_data = df[df['landcover'] == landcover]
            
            # 上坡影响（slope_along_path > 0）
            uphill_data = lc_data[lc_data['slope_along_path'] > 0]
            if len(uphill_data) > self.min_samples_per_group:
                # 使用线性回归分析上坡减速效应
                from sklearn.linear_model import LinearRegression
                X = uphill_data['slope_along_path'].values.reshape(-1, 1)
                y = uphill_data['speed_mps'].values
                reg = LinearRegression().fit(X, y)
                k_uphill = max(0.1, abs(reg.coef_[0]))  # 确保上坡减速系数为正
            else:
                k_uphill = 0.1  # 默认值
            
            # 横坡影响
            # 使用二次回归分析横坡减速效应
            from sklearn.preprocessing import PolynomialFeatures
            cross_slope_data = lc_data[lc_data['cross_slope'] > 0]
            if len(cross_slope_data) > self.min_samples_per_group:
                X = cross_slope_data['cross_slope'].values.reshape(-1, 1)
                poly = PolynomialFeatures(degree=2)
                X_poly = poly.fit_transform(X)
                y = cross_slope_data['speed_mps'].values
                reg = LinearRegression().fit(X_poly, y)
                k_cross = max(0.05, abs(reg.coef_[2]))  # 确保横坡减速系数为正
            else:
                k_cross = 0.05  # 默认值
            
            effect_params[str(int(landcover))] = {  # 转换landcover为字符串
                'k_uphill': float(k_uphill),  # 转换为Python float
                'k_cross': float(k_cross),  # 转换为Python float
                'max_cross_slope_degrees': 30.0  # 默认值
            }
        
        return effect_params
    
    def save_analysis_results(self, output_dir: str) -> None:
        """保存分析结果
        
        Args:
            output_dir: 输出目录路径
        """
        # 确保输出目录存在
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # 将环境组数据转换为字典
        groups_dict = {
            label: {
                'landcover_code': group.landcover_code,
                'slope_bin': group.slope_bin,
                'count': group.count,
                'max_speed': group.max_speed,
                'typical_speed': group.typical_speed,
                'speed_stddev': group.speed_stddev,
                'max_turn_rate': group.max_turn_rate,
                'typical_turn_rate': group.typical_turn_rate,
                'max_acceleration': group.max_acceleration,
                'typical_acceleration': group.typical_acceleration
            }
            for label, group in self.environment_groups.items()
        }
        
        # 保存为JSON文件
        with open(output_dir / 'environment_groups.json', 'w') as f:
            json.dump(groups_dict, f, indent=4)
        
        self.logger.info(f"分析结果已保存到: {output_dir}")
    
    def load_analysis_results(self, input_dir: str) -> None:
        """加载分析结果
        
        Args:
            input_dir: 输入目录路径
        """
        input_path = Path(input_dir) / 'environment_groups.json'
        
        if not input_path.exists():
            raise FileNotFoundError(f"找不到分析结果文件: {input_path}")
        
        # 从JSON文件加载数据
        with open(input_path, 'r') as f:
            groups_dict = json.load(f)
        
        # 转换为EnvironmentGroup对象
        self.environment_groups = {
            label: EnvironmentGroup(
                group_label=label,
                **{k: v for k, v in data.items()}
            )
            for label, data in groups_dict.items()
        }
        
        self.logger.info(f"已加载分析结果: {len(self.environment_groups)} 个环境组") 
```

### src/generator/path_planner.py
```python
"""
路径规划器模块
负责使用A*算法进行智能路径规划
"""

import heapq
import logging
import numpy as np
from typing import List, Tuple, Dict, Set, Optional
import rasterio
from pathlib import Path
from dataclasses import dataclass, field
from scipy.interpolate import splprep, splev

from ..data_processing import GISDataLoader
from src.generator.config import (
    LANDCOVER_COST_FACTORS,
    IMPASSABLE_LANDCOVER_CODES,
    MAX_SLOPE_THRESHOLD
)

# 配置日志
logger = logging.getLogger(__name__)

@dataclass(order=True)
class PathNode:
    """路径节点类，用于A*算法"""
    priority: float = field(compare=True)  # f = g + h
    position: Tuple[int, int] = field(compare=False)  # (row, col)
    g_cost: float = field(compare=False)  # 从起点到当前点的实际代价
    h_cost: float = field(compare=False)  # 从当前点到终点的估计代价
    parent: Optional['PathNode'] = field(compare=False, default=None)  # 父节点

class PathPlanner:
    """路径规划器类"""
    
    def __init__(
        self,
        cost_map_path: str,
        smoothness_weight: float = 0.3,
        heuristic_weight: float = 1.1,
        interpolation_points: int = 100
    ):
        """初始化路径规划器
        
        Args:
            cost_map_path: 成本地图文件路径
            smoothness_weight: 平滑度权重，控制路径的平滑程度
            heuristic_weight: 启发式权重，控制A*算法的搜索倾向
            interpolation_points: 插值点数量，控制平滑后路径的精度
        """
        # 检查文件是否存在
        if not Path(cost_map_path).exists():
            raise FileNotFoundError(f"找不到文件: {cost_map_path}")
        
        # 读取成本地图
        with rasterio.open(cost_map_path) as src:
            self.cost_map = src.read(1)
            self.transform = src.transform
            self.height = src.height
            self.width = src.width
        
        # 初始化参数
        self.smoothness_weight = smoothness_weight
        self.heuristic_weight = heuristic_weight
        self.interpolation_points = interpolation_points
        
        # 初始化日志
        self.logger = logging.getLogger(__name__)
        
        # 定义8个方向的偏移量（上、右上、右、右下、下、左下、左、左上）
        self.directions = [
            (-1, 0), (-1, 1), (0, 1), (1, 1),
            (1, 0), (1, -1), (0, -1), (-1, -1)
        ]
        
        # 计算对角线方向的代价系数（√2）
        self.direction_costs = [
            1.0, np.sqrt(2), 1.0, np.sqrt(2),
            1.0, np.sqrt(2), 1.0, np.sqrt(2)
        ]
    
    def is_valid_position(self, position: Tuple[int, int]) -> bool:
        """检查位置是否有效
        
        Args:
            position: 位置坐标 (row, col)
            
        Returns:
            bool: 位置是否有效
        """
        row, col = position
        return (0 <= row < self.height and 
                0 <= col < self.width and 
                self.cost_map[row, col] < float('inf'))
    
    def calculate_heuristic(
        self,
        position: Tuple[int, int],
        goal: Tuple[int, int]
    ) -> float:
        """计算启发式值（使用欧几里得距离）
        
        Args:
            position: 当前位置
            goal: 目标位置
            
        Returns:
            float: 启发式值
        """
        return np.sqrt(
            (position[0] - goal[0])**2 +
            (position[1] - goal[1])**2
        )
    
    def calculate_turn_cost(
        self,
        current: Tuple[int, int],
        next_pos: Tuple[int, int],
        parent: Optional[Tuple[int, int]] = None
    ) -> float:
        """计算转弯代价
        
        Args:
            current: 当前位置
            next_pos: 下一个位置
            parent: 父节点位置
            
        Returns:
            float: 转弯代价
        """
        if parent is None:
            return 0.0
        
        # 计算两个方向向量
        v1 = np.array([current[0] - parent[0], current[1] - parent[1]], dtype=np.float64)
        v2 = np.array([next_pos[0] - current[0], next_pos[1] - current[1]], dtype=np.float64)
        
        # 计算向量的模
        n1 = np.linalg.norm(v1)
        n2 = np.linalg.norm(v2)
        
        # 如果任一向量为零向量，说明路径重叠
        if n1 < 1e-6 or n2 < 1e-6:
            return self.smoothness_weight * np.pi
        
        # 计算夹角的余弦值
        cos_angle = np.dot(v1, v2) / (n1 * n2)
        cos_angle = np.clip(cos_angle, -1.0, 1.0)
        
        # 将余弦值转换为角度（0-180度）
        angle = np.arccos(cos_angle)
        
        # 返回转弯代价（角度越大，代价越高）
        return angle * self.smoothness_weight
    
    def find_path(
        self,
        start: Tuple[int, int],
        goal: Tuple[int, int]
    ) -> List[Tuple[int, int]]:
        """使用A*算法寻找最优路径
        
        Args:
            start: 起点坐标 (row, col)
            goal: 终点坐标 (row, col)
            
        Returns:
            List[Tuple[int, int]]: 路径点列表
        """
        # 检查起终点的有效性
        if not self.is_valid_position(start):
            raise ValueError(f"无效的起点坐标: {start}")
        if not self.is_valid_position(goal):
            raise ValueError(f"无效的终点坐标: {goal}")
        
        # 初始化开放列表和关闭列表
        open_list = []
        closed_set = set()
        
        # 创建起点节点
        start_node = PathNode(
            priority=0,
            position=start,
            g_cost=0,
            h_cost=self.calculate_heuristic(start, goal)
        )
        
        # 将起点加入开放列表
        heapq.heappush(open_list, start_node)
        
        # 开始搜索
        while open_list:
            # 获取f值最小的节点
            current = heapq.heappop(open_list)
            
            # 如果到达目标，构建并返回路径
            if current.position == goal:
                path = []
                while current:
                    path.append(current.position)
                    current = current.parent
                return list(reversed(path))
            
            # 将当前节点加入关闭列表
            closed_set.add(current.position)
            
            # 检查所有相邻节点
            for i, (dy, dx) in enumerate(self.directions):
                next_pos = (
                    current.position[0] + dy,
                    current.position[1] + dx
                )
                
                # 跳过无效或已访问的节点
                if (not self.is_valid_position(next_pos) or
                    next_pos in closed_set):
                    continue
                
                # 计算新的g值（考虑方向代价和转弯代价）
                new_g = (current.g_cost +
                        self.direction_costs[i] * self.cost_map[next_pos] +
                        self.calculate_turn_cost(
                            current.position,
                            next_pos,
                            current.parent.position if current.parent else None
                        ))
                
                # 计算h值
                h = self.calculate_heuristic(next_pos, goal)
                
                # 创建新节点
                neighbor = PathNode(
                    priority=new_g + self.heuristic_weight * h,
                    position=next_pos,
                    g_cost=new_g,
                    h_cost=h,
                    parent=current
                )
                
                # 将新节点加入开放列表
                heapq.heappush(open_list, neighbor)
        
        # 如果没有找到路径，返回空列表
        self.logger.warning(f"未能找到从{start}到{goal}的路径")
        return []
    
    def smooth_path(
        self,
        path: List[Tuple[int, int]]
    ) -> List[Tuple[int, int]]:
        """使用B样条插值平滑路径
        
        Args:
            path: 原始路径点列表
            
        Returns:
            List[Tuple[int, int]]: 平滑后的路径点列表
        """
        if len(path) < 3:
            return path
        
        # 提取路径点的坐标
        points = np.array(path)
        x = points[:, 0]
        y = points[:, 1]
        
        # 计算路径点之间的累积距离作为参数化变量
        t = np.zeros(len(path))
        for i in range(1, len(path)):
            dx = x[i] - x[i-1]
            dy = y[i] - y[i-1]
            t[i] = t[i-1] + np.sqrt(dx*dx + dy*dy)
        
        # 归一化参数化变量
        if t[-1] > 0:
            t = t / t[-1]
        
        # 为了保证起点和终点不变，在两端添加重复点
        x = np.concatenate([[x[0]], x, [x[-1]]])
        y = np.concatenate([[y[0]], y, [y[-1]]])
        t = np.concatenate([[0], t, [1]])
        
        try:
            # 使用B样条插值，设置较小的平滑因子以保持路径形状
            tck, _ = splprep([x, y], u=t, s=len(path) * 0.1, k=min(3, len(path)-1))
            
            # 生成更密集的点
            u = np.linspace(0, 1, self.interpolation_points)
            smooth_points = np.array(splev(u, tck)).T
            
            # 保证起点和终点不变
            smooth_points[0] = points[0]
            smooth_points[-1] = points[-1]
            
        except Exception as e:
            self.logger.warning(f"路径平滑失败: {e}，返回原始路径")
            return path
        
        # 将插值点转换为整数坐标，使用更精确的四舍五入
        smooth_path = []
        prev_point = None
        for p in smooth_points:
            # 对坐标进行四舍五入
            point = (int(round(p[0])), int(round(p[1])))
            
            # 避免重复点
            if point != prev_point:
                smooth_path.append(point)
                prev_point = point
        
        # 验证平滑路径的可行性
        valid_path = []
        for point in smooth_path:
            if self.is_valid_position(point):
                valid_path.append(point)
            else:
                # 如果遇到无效点，尝试找到最近的有效点
                found_valid = False
                for dy in [-1, 0, 1]:
                    for dx in [-1, 0, 1]:
                        new_point = (point[0] + dy, point[1] + dx)
                        if self.is_valid_position(new_point):
                            valid_path.append(new_point)
                            found_valid = True
                            break
                    if found_valid:
                        break
                if not found_valid:
                    self.logger.warning(f"平滑路径点{point}无效，已跳过")
        
        # 确保起点和终点正确
        if valid_path and valid_path[0] != path[0]:
            valid_path[0] = path[0]
        if valid_path and valid_path[-1] != path[-1]:
            valid_path[-1] = path[-1]
        
        # 如果平滑路径无效，返回原始路径
        if not valid_path:
            self.logger.warning("平滑路径无效，返回原始路径")
            return path
        
        return valid_path
    
    def plan(
        self,
        start: Tuple[int, int],
        goal: Tuple[int, int],
        smooth: bool = True
    ) -> List[Tuple[int, int]]:
        """规划路径的主函数
        
        Args:
            start: 起点坐标 (row, col)
            goal: 终点坐标 (row, col)
            smooth: 是否对路径进行平滑处理
            
        Returns:
            List[Tuple[int, int]]: 路径点列表
        """
        # 使用A*算法寻找路径
        path = self.find_path(start, goal)
        
        if not path:
            return []
        
        # 如果需要，对路径进行平滑处理
        if smooth and len(path) > 2:
            path = self.smooth_path(path)
        
        return path 
```

### src/generator/point_selector.py
```python
"""起点选择器模块

此模块负责为给定的终点选择合适的起点。选择过程需要考虑：
1. 起点的可通行性（基于土地覆盖类型和坡度）
2. 起终点之间的最小距离约束
3. 起点的随机性（在满足约束的情况下）

输入:
    - 土地覆盖栅格文件 (.tif)
    - 坡度栅格文件 (.tif)
    - 终点坐标（像素坐标）
    - 约束参数（最小距离等）

输出:
    - 满足约束的起点坐标列表
"""

import numpy as np
import rasterio
from pathlib import Path
import logging
from typing import List, Tuple, Dict, Optional
import random

from src.generator.config import (
    MAX_SLOPE_THRESHOLD, IMPASSABLE_LANDCOVER_CODES,
    MIN_START_END_DISTANCE_METERS, MAX_SEARCH_RADIUS,
    MAX_SEARCH_ATTEMPTS, MIN_START_POINTS_SPACING
)

class PointSelector:
    """起点选择器类"""
    
    def __init__(self, landcover_path: str, slope_path: str):
        """初始化起点选择器
        
        Args:
            landcover_path: 土地覆盖栅格文件路径
            slope_path: 坡度栅格文件路径
        """
        # 检查文件是否存在
        for path in [landcover_path, slope_path]:
            if not Path(path).exists():
                raise FileNotFoundError(f"找不到文件: {path}")
        
        # 读取栅格数据
        with rasterio.open(landcover_path) as src:
            self.landcover_data = src.read(1)
            self.transform = src.transform
            self.meta = src.meta.copy()
            self.height = src.height
            self.width = src.width
        
        with rasterio.open(slope_path) as src:
            self.slope_data = src.read(1)
            if src.transform != self.transform:
                raise ValueError("土地覆盖和坡度数据的空间参考不一致")
        
        # 验证数据形状一致
        if self.landcover_data.shape != self.slope_data.shape:
            raise ValueError("土地覆盖和坡度数据形状不一致")
        
        # 初始化日志
        self.logger = logging.getLogger(__name__)
        
        # 计算像素大小（米）
        self.pixel_size_degrees = abs(self.transform[0])  # 经纬度分辨率（度）
        self.meters_per_degree = 111000  # 1度约等于111km
        self.pixel_size_meters = self.pixel_size_degrees * self.meters_per_degree
    
    def is_point_accessible(self, row: int, col: int) -> bool:
        """判断指定点是否可通行
        
        Args:
            row: 行号
            col: 列号
            
        Returns:
            bool: 是否可通行
        """
        # 检查边界
        if not (0 <= row < self.height and 0 <= col < self.width):
            return False
        
        # 检查土地覆盖类型
        landcover = self.landcover_data[row, col]
        if landcover in IMPASSABLE_LANDCOVER_CODES:
            return False
        
        # 检查坡度
        slope = self.slope_data[row, col]
        if slope > MAX_SLOPE_THRESHOLD:
            return False
        
        return True
    
    def calculate_distance(self, point1: Tuple[int, int], point2: Tuple[int, int]) -> float:
        """计算两点间的像素距离
        
        Args:
            point1: 第一个点的坐标 (row, col)
            point2: 第二个点的坐标 (row, col)
            
        Returns:
            float: 像素距离
        """
        return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)
    
    def calculate_geo_distance(self, point1: Tuple[int, int], point2: Tuple[int, int]) -> float:
        """计算两点间的实际地理距离（米）
        
        Args:
            point1: 第一个点的坐标 (row, col)
            point2: 第二个点的坐标 (row, col)
            
        Returns:
            float: 地理距离（米）
        """
        # 转换为地理坐标
        lon1, lat1 = self.pixel_to_geo(point1)
        lon2, lat2 = self.pixel_to_geo(point2)
        
        # 使用简化的距离计算（平面近似）
        dx = (lon2 - lon1) * self.meters_per_degree * np.cos(np.radians((lat1 + lat2) / 2))
        dy = (lat2 - lat1) * self.meters_per_degree
        
        return np.sqrt(dx * dx + dy * dy)
    
    def select_start_points(
        self,
        end_point: Tuple[int, int],
        num_points: int = 1,
        min_distance: float = MIN_START_END_DISTANCE_METERS,
        max_attempts: int = MAX_SEARCH_ATTEMPTS
    ) -> List[Tuple[int, int]]:
        """为给定终点选择合适的起点
        
        Args:
            end_point: 终点坐标 (row, col)
            num_points: 需要选择的起点数量
            min_distance: 起终点最小距离（米）
            max_attempts: 最大尝试次数
            
        Returns:
            List[Tuple[int, int]]: 选择的起点坐标列表
        """
        selected_points = []
        attempts = 0
        min_pixel_distance = min_distance / self.pixel_size_meters
        min_spacing = MIN_START_POINTS_SPACING / self.pixel_size_meters
        
        # 计算搜索范围
        max_radius = MAX_SEARCH_RADIUS / self.pixel_size_meters
        search_radius = min(int(min_pixel_distance * 2), int(max_radius))
        
        # 创建候选点网格
        y, x = np.meshgrid(
            np.arange(-search_radius, search_radius + 1),
            np.arange(-search_radius, search_radius + 1)
        )
        distances = np.sqrt(x*x + y*y)
        mask = distances >= min_pixel_distance
        candidate_offsets = list(zip(y[mask].flat, x[mask].flat))
        random.shuffle(candidate_offsets)
        
        while len(selected_points) < num_points and attempts < len(candidate_offsets):
            # 获取下一个候选点
            dy, dx = candidate_offsets[attempts]
            row = int(end_point[0] + dy)
            col = int(end_point[1] + dx)
            attempts += 1
            
            # 检查点是否可用
            if self.is_point_accessible(row, col):
                # 检查与已选点的距离
                too_close = False
                for point in selected_points:
                    if self.calculate_distance((row, col), point) < min_spacing:
                        too_close = True
                        break
                
                if not too_close:
                    selected_points.append((row, col))
                    self.logger.debug(f"已选择起点: ({row}, {col})")
        
        if len(selected_points) < num_points:
            self.logger.warning(
                f"未能找到足够的起点（要求{num_points}个，找到{len(selected_points)}个）"
            )
        
        return selected_points
    
    def select_start_points_for_all_ends(
        self,
        end_points: List[Dict],
        points_per_end: int = 3
    ) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:
        """为所有终点选择起点
        
        Args:
            end_points: 终点列表，每个终点是一个字典，包含 'pixel' 和 'coord' 键
            points_per_end: 每个终点需要的起点数量
            
        Returns:
            List[Tuple[Tuple[int, int], Tuple[int, int]]]: 起终点对列表
        """
        start_end_pairs = []
        
        for end_point in end_points:
            # 为当前终点选择起点
            start_points = self.select_start_points(
                end_point['pixel'],
                num_points=points_per_end
            )
            
            # 添加起终点对
            for start_point in start_points:
                start_end_pairs.append((start_point, end_point['pixel']))
        
        self.logger.info(f"共生成{len(start_end_pairs)}对起终点")
        return start_end_pairs
    
    def pixel_to_geo(self, pixel: Tuple[int, int]) -> Tuple[float, float]:
        """将像素坐标转换为地理坐标
        
        Args:
            pixel: 像素坐标 (row, col)
            
        Returns:
            Tuple[float, float]: 地理坐标 (lon, lat)
        """
        # 注意：rasterio的transform期望(x, y)，而我们的输入是(row, col)
        x, y = pixel[1], pixel[0]  # 转换为(x, y)
        # 使用transform的逆变换
        lon = x * self.transform[0] + self.transform[2]
        lat = y * self.transform[4] + self.transform[5]
        return lon, lat
    
    def geo_to_pixel(self, coord: Tuple[float, float]) -> Tuple[int, int]:
        """将地理坐标转换为像素坐标
        
        Args:
            coord: 地理坐标 (lon, lat)
            
        Returns:
            Tuple[int, int]: 像素坐标 (row, col)
        """
        # 使用transform的正变换
        col = int((coord[0] - self.transform[2]) / self.transform[0])
        row = int((coord[1] - self.transform[5]) / self.transform[4])
        return row, col 
```

### src/generator/terrain_analyzer.py
```python
"""地形分析器模块

此模块负责从DEM数据计算地形属性,包括:
1. 坡度大小(度)
2. 坡向(度,北为0,顺时针)

输入:
    - DEM栅格文件 (.tif)

输出:
    - 坡度大小栅格文件 (slope_magnitude_30m_100km.tif)
    - 坡向栅格文件 (slope_aspect_30m_100km.tif)
"""

import numpy as np
import rasterio
from pathlib import Path
import logging
from typing import Tuple
import os

class TerrainAnalyzer:
    """地形分析器类"""
    
    def __init__(self, dem_path: str):
        """初始化地形分析器
        
        Args:
            dem_path: DEM栅格文件路径
        """
        # 检查文件是否存在
        if not Path(dem_path).exists():
            raise FileNotFoundError(f"找不到DEM文件: {dem_path}")
        
        # 读取DEM数据
        with rasterio.open(dem_path) as src:
            self.dem_data = src.read(1)
            self.transform = src.transform
            self.meta = src.meta.copy()
            # 计算实际的像素大小(米)
            self.pixel_width = abs(self.transform[0]) * 111320  # 转换为米
            self.pixel_height = abs(self.transform[4]) * 111320  # 转换为米
        
        # 初始化日志
        self.logger = logging.getLogger(__name__)
    
    def calculate_slope_magnitude(self) -> np.ndarray:
        """计算坡度大小
        
        使用中心差分法计算每个像素的坡度大小(度)。
        边缘像素使用前向或后向差分。
        
        Returns:
            np.ndarray: 坡度大小(度)
        """
        rows, cols = self.dem_data.shape
        
        # 计算x和y方向的高程梯度
        dx = np.zeros_like(self.dem_data)
        dy = np.zeros_like(self.dem_data)
        
        # x方向梯度(中心差分)
        dx[:, 1:-1] = (self.dem_data[:, 2:] - self.dem_data[:, :-2]) / (2 * self.pixel_width)
        # 边缘使用前向/后向差分
        dx[:, 0] = (self.dem_data[:, 1] - self.dem_data[:, 0]) / self.pixel_width
        dx[:, -1] = (self.dem_data[:, -1] - self.dem_data[:, -2]) / self.pixel_width
        
        # y方向梯度(中心差分)
        dy[1:-1, :] = (self.dem_data[2:, :] - self.dem_data[:-2, :]) / (2 * self.pixel_height)
        # 边缘使用前向/后向差分
        dy[0, :] = (self.dem_data[1, :] - self.dem_data[0, :]) / self.pixel_height
        dy[-1, :] = (self.dem_data[-1, :] - self.dem_data[-2, :]) / self.pixel_height
        
        # 计算坡度(度)
        slope = np.degrees(np.arctan(np.sqrt(dx**2 + dy**2)))
        
        # 处理无效值
        slope = np.nan_to_num(slope, 0)  # 将NaN替换为0
        slope = np.clip(slope, 0, 90)  # 限制在0-90度范围内
        
        return slope
    
    def calculate_slope_aspect(self) -> np.ndarray:
        """计算坡向
        
        使用中心差分法计算每个像素的坡向(度,北为0,顺时针)。
        边缘像素使用前向或后向差分。
        平坦区域(坡度<0.1度)的坡向设为-1。
        
        Returns:
            np.ndarray: 坡向(度)
        """
        rows, cols = self.dem_data.shape
        
        # 计算x和y方向的高程梯度
        dx = np.zeros_like(self.dem_data)
        dy = np.zeros_like(self.dem_data)
        
        # x方向梯度(中心差分)
        dx[:, 1:-1] = (self.dem_data[:, 2:] - self.dem_data[:, :-2]) / (2 * self.pixel_width)
        # 边缘使用前向/后向差分
        dx[:, 0] = (self.dem_data[:, 1] - self.dem_data[:, 0]) / self.pixel_width
        dx[:, -1] = (self.dem_data[:, -1] - self.dem_data[:, -2]) / self.pixel_width
        
        # y方向梯度(中心差分)
        dy[1:-1, :] = (self.dem_data[2:, :] - self.dem_data[:-2, :]) / (2 * self.pixel_height)
        # 边缘使用前向/后向差分
        dy[0, :] = (self.dem_data[1, :] - self.dem_data[0, :]) / self.pixel_height
        dy[-1, :] = (self.dem_data[-1, :] - self.dem_data[-2, :]) / self.pixel_height
        
        # 计算坡向(弧度)
        aspect = np.arctan2(dx, dy)  # 使用arctan2确保正确的象限
        
        # 转换为度数并调整为北为0,顺时针
        aspect = np.degrees(aspect)
        aspect = 90.0 - aspect  # 转换为北为0
        aspect = np.where(aspect < 0, aspect + 360, aspect)  # 处理负值
        
        # 计算坡度用于识别平坦区域
        slope = np.degrees(np.arctan(np.sqrt(dx**2 + dy**2)))
        
        # 平坦区域坡向设为-1
        aspect = np.where(slope < 0.1, -1, aspect)
        
        return aspect
    
    def save_terrain_maps(self, output_dir: str) -> Tuple[str, str]:
        """保存地形属性地图
        
        Args:
            output_dir: 输出目录路径
            
        Returns:
            Tuple[str, str]: 坡度和坡向文件的路径
        """
        # 确保输出目录存在
        os.makedirs(output_dir, exist_ok=True)
        
        # 计算坡度和坡向
        slope = self.calculate_slope_magnitude()
        aspect = self.calculate_slope_aspect()
        
        # 准备元数据
        meta = self.meta.copy()
        meta.update(dtype=np.float32)
        
        # 保存坡度地图
        slope_path = os.path.join(output_dir, "slope_magnitude_30m_100km.tif")
        with rasterio.open(slope_path, 'w', **meta) as dst:
            dst.write(slope.astype(np.float32), 1)
        
        # 保存坡向地图
        aspect_path = os.path.join(output_dir, "slope_aspect_30m_100km.tif")
        with rasterio.open(aspect_path, 'w', **meta) as dst:
            dst.write(aspect.astype(np.float32), 1)
        
        self.logger.info(f"地形属性地图已保存到目录: {output_dir}")
        return slope_path, aspect_path 
```

### src/generator/trajectory_generator.py
```python
"""
轨迹生成器模块
负责生成符合环境约束的合成轨迹
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import pandas as pd
from scipy import stats

from ..analysis import EnvironmentAnalyzer
from ..config import TRAJECTORY_COLUMNS
from ..data_processing import GISDataLoader

# 配置日志
logger = logging.getLogger(__name__)

class TrajectoryGenerator:
    """轨迹生成器，用于生成符合环境约束的合成轨迹"""
    
    def __init__(self, 
                 gis_loader: GISDataLoader,
                 env_analyzer: EnvironmentAnalyzer,
                 time_step: float = 1.0):
        """
        初始化轨迹生成器
        
        Args:
            gis_loader: GIS数据加载器实例
            env_analyzer: 环境分析器实例，包含已训练的环境-运动特征模型
            time_step: 轨迹采样时间步长（秒），默认为1秒
        """
        self.gis_loader = gis_loader
        self.env_analyzer = env_analyzer
        self.time_step = time_step
    
    def generate_trajectory(self,
                          start_point: Tuple[float, float],
                          end_point: Tuple[float, float],
                          start_time: pd.Timestamp) -> pd.DataFrame:
        """
        生成一条从起点到终点的合成轨迹
        
        Args:
            start_point: 起点坐标 (longitude, latitude)
            end_point: 终点坐标 (longitude, latitude)
            start_time: 轨迹起始时间
            
        Returns:
            trajectory_df: 生成的轨迹数据，包含时间戳、位置、速度等信息
        """
        # 规划路径
        waypoints = self._plan_path(start_point, end_point)
        
        # 生成运动轨迹
        trajectory_df = self._generate_motion(waypoints, start_time)
        
        return trajectory_df
    
    def generate_trajectories(self,
                            num_trajectories: int,
                            region_bounds: Tuple[float, float, float, float],
                            time_range: Tuple[pd.Timestamp, pd.Timestamp]) -> Dict[str, pd.DataFrame]:
        """
        在指定区域和时间范围内生成多条轨迹
        
        Args:
            num_trajectories: 要生成的轨迹数量
            region_bounds: 区域边界 (min_lon, min_lat, max_lon, max_lat)
            time_range: 时间范围 (start_time, end_time)
            
        Returns:
            trajectories: 生成的轨迹字典，key为轨迹ID
        """
        min_lon, min_lat, max_lon, max_lat = region_bounds
        start_time, end_time = time_range
        time_range_seconds = (end_time - start_time).total_seconds()
        
        trajectories = {}
        for i in range(num_trajectories):
            # 随机生成起点和终点
            start_point = (
                np.random.uniform(min_lon, max_lon),
                np.random.uniform(min_lat, max_lat)
            )
            end_point = (
                np.random.uniform(min_lon, max_lon),
                np.random.uniform(min_lat, max_lat)
            )
            
            # 随机生成起始时间
            start_offset = np.random.uniform(0, time_range_seconds)
            traj_start_time = start_time + pd.Timedelta(seconds=start_offset)
            
            try:
                # 生成轨迹
                trajectory = self.generate_trajectory(
                    start_point=start_point,
                    end_point=end_point,
                    start_time=traj_start_time
                )
                
                # 生成轨迹ID并保存
                traj_id = f"TRAJ_{i+1:04d}"
                trajectories[traj_id] = trajectory
                
                logger.info(f"成功生成轨迹 {traj_id}")
                
            except Exception as e:
                logger.error(f"生成第 {i+1} 条轨迹时出错: {str(e)}")
                continue
        
        return trajectories
    
    def _plan_path(self,
                   start_point: Tuple[float, float],
                   end_point: Tuple[float, float]) -> List[Tuple[float, float]]:
        """
        规划从起点到终点的路径
        
        Args:
            start_point: 起点坐标 (longitude, latitude)
            end_point: 终点坐标 (longitude, latitude)
            
        Returns:
            waypoints: 路径上的关键点列表
        """
        # 计算起点和终点之间的距离
        lon_diff = end_point[0] - start_point[0]
        lat_diff = end_point[1] - start_point[1]
        total_distance = np.sqrt(lon_diff**2 + lat_diff**2)
        
        # 根据总距离确定路径点数量（每0.005度约0.5km）
        num_points = max(2, int(total_distance / 0.005) + 1)
        
        # 生成路径点
        waypoints = []
        for i in range(num_points):
            t = i / (num_points - 1)  # 插值参数，从0到1
            lon = start_point[0] + t * lon_diff
            lat = start_point[1] + t * lat_diff
            
            # 对于最后一个点，使用精确的终点坐标
            if i == num_points - 1:
                lon, lat = end_point
            
            waypoints.append((lon, lat))
        
        return waypoints
    
    def _generate_motion(self,
                        waypoints: List[Tuple[float, float]],
                        start_time: pd.Timestamp) -> pd.DataFrame:
        """
        根据路径点生成符合环境约束的运动轨迹
        
        Args:
            waypoints: 路径关键点列表
            start_time: 起始时间
            
        Returns:
            motion_df: 生成的运动轨迹数据
        """
        # 初始化轨迹数据列表
        timestamps = []
        longitudes = []
        latitudes = []
        elevations = []
        speeds = []
        headings = []
        turn_rates = []
        accelerations = []
        
        current_time = start_time
        current_speed = 0.0
        current_heading = 0.0
        
        # 遍历相邻路径点对
        for i in range(len(waypoints) - 1):
            p1, p2 = waypoints[i], waypoints[i + 1]
            
            # 计算两点之间的距离和方向
            lon_diff = p2[0] - p1[0]
            lat_diff = p2[1] - p1[1]
            segment_distance = np.sqrt(lon_diff**2 + lat_diff**2)
            target_heading = np.degrees(np.arctan2(lat_diff, lon_diff)) % 360
            
            # 获取当前位置的环境信息
            pixel_coords = self.gis_loader.get_pixel_coords(p1[0], p1[1])
            elevation = self.gis_loader.get_elevation(*pixel_coords)
            slope = self.gis_loader.get_slope(*pixel_coords)
            landcover = self.gis_loader.get_landcover(*pixel_coords)
            
            # 根据环境条件采样目标速度
            target_speed = self.env_analyzer.sample_speed(landcover, slope)
            
            # 计算航向角变化
            heading_diff = (target_heading - current_heading + 180) % 360 - 180
            num_steps = max(1, int(segment_distance / (target_speed * self.time_step)))
            heading_step = heading_diff / num_steps
            
            # 生成该段轨迹的运动数据
            for step in range(num_steps):
                t = step / num_steps  # 插值参数
                
                # 更新位置
                if step == num_steps - 1 and i == len(waypoints) - 2:
                    # 最后一个点使用精确的终点坐标
                    lon, lat = p2
                else:
                    lon = p1[0] + t * lon_diff
                    lat = p1[1] + t * lat_diff
                
                # 更新航向
                prev_heading = current_heading
                current_heading = (current_heading + heading_step) % 360
                turn_rate = (current_heading - prev_heading) / self.time_step
                
                # 更新速度
                prev_speed = current_speed
                current_speed = prev_speed + (target_speed - prev_speed) * 0.1  # 平滑加速
                acceleration = (current_speed - prev_speed) / self.time_step
                
                # 记录数据点
                timestamps.append(current_time)
                longitudes.append(lon)
                latitudes.append(lat)
                elevations.append(elevation)
                speeds.append(current_speed)
                headings.append(current_heading)
                turn_rates.append(turn_rate)
                accelerations.append(acceleration)
                
                current_time += pd.Timedelta(seconds=self.time_step)
        
        # 创建DataFrame
        motion_df = pd.DataFrame({
            'timestamp': timestamps,
            'longitude': longitudes,
            'latitude': latitudes,
            'elevation': elevations,
            'speed': speeds,
            'heading': headings,
            'turn_rate': turn_rates,
            'acceleration': accelerations
        })
        
        return motion_df 
```

### src/learning/__init__.py
```python

```

### src/trajectory_generation/environment_based_generator.py
```python
"""
基于环境的轨迹生成器
根据地形特征和环境约束生成合理的轨迹
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import pandas as pd
from scipy.interpolate import CubicSpline

from .trajectory_generator import TrajectoryGenerator
from ..data_processing import TerrainLoader

logger = logging.getLogger(__name__)

class EnvironmentBasedGenerator(TrajectoryGenerator):
    """基于环境的轨迹生成器"""
    
    def __init__(self, terrain_loader: TerrainLoader):
        """
        初始化基于环境的轨迹生成器
        
        Args:
            terrain_loader: 地形数据加载器实例
        """
        super().__init__(terrain_loader)
        
        # 环境相关参数
        self.env_params = {
            # 坡度对速度的影响因子
            'slope_speed_factors': {
                'flat': 1.0,      # 平地 (0-5度)
                'gentle': 0.9,    # 缓坡 (5-15度)
                'moderate': 0.7,  # 中坡 (15-30度)
                'steep': 0.5      # 陡坡 (>30度)
            },
            # 坡向影响参数
            'slope_direction_params': {
                'k_uphill': 0.1,    # 上坡减速系数
                'k_downhill': 0.05,  # 下坡加速系数
                'k_cross': 0.2,      # 横坡减速系数
                'max_cross_slope': 30.0,  # 最大允许横坡角度(度)
                'min_speed_factor': 0.1   # 最小速度因子
            },
            # 地表类型对速度的影响因子
            'landcover_speed_factors': {
                1: 1.0,  # 道路
                2: 0.8,  # 植被
                3: 0.6   # 水体
            },
            'path_smoothness': 0.8,  # 路径平滑度 (0-1)
            'waypoint_spacing': 100   # 路径点间距（米）
        }
    
    def generate_trajectory(
            self,
            start_point: Tuple[float, float],
            end_point: Tuple[float, float],
            params: Optional[Dict] = None
        ) -> pd.DataFrame:
        """
        生成轨迹
        
        Args:
            start_point: 起点坐标（经度, 纬度）
            end_point: 终点坐标（经度, 纬度）
            params: 生成参数，可选
            
        Returns:
            pd.DataFrame: 生成的轨迹数据
        """
        # 更新参数
        if params:
            self.update_params(params)
        
        # 检查地形数据
        self._check_terrain_data()
        
        # 验证起终点
        if not (self._validate_point(*start_point) and self._validate_point(*end_point)):
            raise ValueError("起点或终点超出有效范围")
        
        # 生成路径点
        waypoints = self._generate_waypoints(start_point, end_point)
        
        # 生成轨迹点
        trajectory = self._generate_trajectory_points(waypoints)
        
        # 验证轨迹
        if not self.validate_trajectory(trajectory):
            logger.warning("生成的轨迹不满足约束条件，尝试重新生成")
            return self.generate_trajectory(start_point, end_point, params)
        
        return trajectory
    
    def validate_trajectory(self, trajectory: pd.DataFrame) -> bool:
        """
        验证轨迹是否满足约束条件
        
        Args:
            trajectory: 轨迹数据
            
        Returns:
            bool: 是否有效
        """
        # 检查速度约束
        speed = np.sqrt(
            trajectory['velocity_north_ms']**2 + 
            trajectory['velocity_east_ms']**2
        )
        if not (self.params['min_speed'] <= speed).all() or \
           not (speed <= self.params['max_speed']).all():
            return False
        
        # 检查加速度约束
        acceleration = np.sqrt(
            trajectory['acceleration_x_ms2']**2 + 
            trajectory['acceleration_y_ms2']**2 + 
            trajectory['acceleration_z_ms2']**2
        )
        if not (acceleration <= self.params['max_acceleration']).all():
            return False
        
        # 检查转向率约束
        turn_rate = np.sqrt(
            trajectory['angular_velocity_x_rads']**2 + 
            trajectory['angular_velocity_y_rads']**2 + 
            trajectory['angular_velocity_z_rads']**2
        )
        if not (turn_rate <= np.radians(self.params['max_turn_rate'])).all():
            return False
        
        return True
    
    def _generate_waypoints(
            self,
            start_point: Tuple[float, float],
            end_point: Tuple[float, float]
        ) -> List[Tuple[float, float]]:
        """
        生成路径点
        
        Args:
            start_point: 起点坐标
            end_point: 终点坐标
            
        Returns:
            List[Tuple[float, float]]: 路径点列表
        """
        # 计算直线距离
        distance = self._calculate_distance(start_point, end_point)
        
        # 计算需要的路径点数量
        num_points = max(3, int(distance / self.env_params['waypoint_spacing']))
        
        # 生成初始路径点（直线插值）
        t = np.linspace(0, 1, num_points)
        lon = np.interp(t, [0, 1], [start_point[0], end_point[0]])
        lat = np.interp(t, [0, 1], [start_point[1], end_point[1]])
        
        # 根据地形调整路径点
        waypoints = []
        for i in range(num_points):
            point = self._adjust_point_by_terrain(lon[i], lat[i])
            waypoints.append(point)
        
        return waypoints
    
    def _calculate_speed_factors(
            self,
            slope_magnitude: float,
            slope_aspect: float,
            heading: float,
            landcover: int
        ) -> Tuple[float, float]:
        """
        计算速度影响因子
        
        Args:
            slope_magnitude: 坡度大小(度)
            slope_aspect: 坡向(度,北为0,顺时针)
            heading: 行进方向(度,北为0,顺时针)
            landcover: 地表类型编码
            
        Returns:
            Tuple[float, float]: (最大速度因子, 典型速度因子)
        """
        # 计算坡向影响
        delta_angle = heading - slope_aspect
        # 处理角度环绕
        if delta_angle > 180:
            delta_angle -= 360
        elif delta_angle < -180:
            delta_angle += 360
            
        # 计算沿路径坡度和横向坡度
        slope_along_path = slope_magnitude * np.cos(np.radians(delta_angle))
        cross_slope = slope_magnitude * abs(np.sin(np.radians(delta_angle)))
        
        # 获取坡向参数
        params = self.env_params['slope_direction_params']
        
        # 计算上下坡影响
        if slope_along_path > 0:  # 上坡
            along_factor = max(
                params['min_speed_factor'],
                1 - params['k_uphill'] * slope_along_path
            )
        else:  # 下坡
            along_factor = min(
                1.2,  # 限制下坡最大加速
                1 + params['k_downhill'] * abs(slope_along_path)
            )
        
        # 计算横坡影响
        cross_factor = max(
            params['min_speed_factor'],
            1 - params['k_cross'] * (cross_slope / params['max_cross_slope'])**2
        )
        
        # 如果横坡超过最大允许值,显著降低速度
        if cross_slope > params['max_cross_slope']:
            cross_factor = params['min_speed_factor']
        
        # 获取基础坡度影响因子
        if slope_magnitude <= 5:
            base_factor = self.env_params['slope_speed_factors']['flat']
        elif slope_magnitude <= 15:
            base_factor = self.env_params['slope_speed_factors']['gentle']
        elif slope_magnitude <= 30:
            base_factor = self.env_params['slope_speed_factors']['moderate']
        else:
            base_factor = self.env_params['slope_speed_factors']['steep']
        
        # 获取地表影响因子
        landcover_factor = self.env_params['landcover_speed_factors'].get(
            landcover,
            0.5  # 默认因子
        )
        
        # 综合各种影响
        max_speed_factor = base_factor * along_factor * cross_factor * landcover_factor
        typical_speed_factor = max_speed_factor * 0.8  # 典型速度略低于最大速度
        
        return max_speed_factor, typical_speed_factor
    
    def _generate_trajectory_points(
            self,
            waypoints: List[Tuple[float, float]]
        ) -> pd.DataFrame:
        """
        根据路径点生成轨迹点
        
        Args:
            waypoints: 路径点列表
            
        Returns:
            pd.DataFrame: 轨迹数据
        """
        # 使用三次样条插值生成平滑路径
        t = np.arange(len(waypoints))
        lon = [p[0] for p in waypoints]
        lat = [p[1] for p in waypoints]
        cs_lon = CubicSpline(t, lon)
        cs_lat = CubicSpline(t, lat)
        
        # 生成时间序列
        total_distance = sum(
            self._calculate_distance(waypoints[i], waypoints[i+1])
            for i in range(len(waypoints)-1)
        )
        total_time = total_distance / (self.params['max_speed'] * 0.5)  # 估计总时间
        num_points = int(total_time / self.params['time_step']) + 1
        t_fine = np.linspace(0, len(waypoints)-1, num_points)
        
        # 生成位置序列
        longitude = cs_lon(t_fine)
        latitude = cs_lat(t_fine)
        
        # 初始化数组
        timestamp_ms = np.zeros(num_points, dtype=np.int64)
        altitude = np.zeros(num_points)
        velocity_north = np.zeros(num_points)
        velocity_east = np.zeros(num_points)
        velocity_down = np.zeros(num_points)
        acceleration_x = np.zeros(num_points)
        acceleration_y = np.zeros(num_points)
        acceleration_z = np.zeros(num_points)
        angular_velocity_z = np.zeros(num_points)
        
        # 计算初始航向
        heading = np.degrees(np.arctan2(
            longitude[1] - longitude[0],
            latitude[1] - latitude[0]
        ))
        if heading < 0:
            heading += 360
            
        # 初始速度设为最小速度
        speed = self.params['min_speed']
        
        # 逐点生成轨迹
        for i in range(num_points):
            # 更新时间戳
            timestamp_ms[i] = int(i * self.params['time_step'] * 1000)
            
            # 获取当前位置的环境信息
            terrain_attrs = self.terrain_analyzer.get_terrain_attributes(
                longitude[i],
                latitude[i]
            )
            landcover = self.terrain_loader.get_landcover(
                longitude[i],
                latitude[i]
            )
            
            # 计算速度影响因子
            max_factor, typ_factor = self._calculate_speed_factors(
                terrain_attrs['slope_magnitude'],
                terrain_attrs['slope_aspect'],
                heading,
                landcover
            )
            
            # 计算目标速度
            target_speed = self.params['max_speed'] * typ_factor
            
            # 应用加速度限制
            speed_diff = target_speed - speed
            if speed_diff > 0:
                accel = min(speed_diff / self.params['time_step'],
                          self.params['max_acceleration'])
            else:
                accel = max(speed_diff / self.params['time_step'],
                          self.params['max_deceleration'])
            
            # 更新速度
            speed = speed + accel * self.params['time_step']
            speed = np.clip(speed,
                          self.params['min_speed'],
                          self.params['max_speed'] * max_factor)
            
            # 分解速度到南北和东西方向
            velocity_north[i] = speed * np.cos(np.radians(heading))
            velocity_east[i] = speed * np.sin(np.radians(heading))
            
            # 计算高程变化引起的垂直速度
            if i > 0:
                altitude[i] = self.terrain_loader.get_elevation(
                    longitude[i],
                    latitude[i]
                )
                dz = altitude[i] - altitude[i-1]
                dt = self.params['time_step']
                velocity_down[i] = -dz / dt  # 注意符号：向上为负
            
            # 计算加速度
            if i > 0:
                acceleration_x[i] = (velocity_east[i] - velocity_east[i-1]) / dt
                acceleration_y[i] = (velocity_north[i] - velocity_north[i-1]) / dt
                acceleration_z[i] = (velocity_down[i] - velocity_down[i-1]) / dt
            
            # 如果不是最后一个点，更新航向
            if i < num_points - 1:
                next_heading = np.degrees(np.arctan2(
                    longitude[i+1] - longitude[i],
                    latitude[i+1] - latitude[i]
                ))
                if next_heading < 0:
                    next_heading += 360
                
                # 计算航向变化
                heading_change = next_heading - heading
                if heading_change > 180:
                    heading_change -= 360
                elif heading_change < -180:
                    heading_change += 360
                
                # 应用转向率限制
                max_change = self.params['max_turn_rate'] * self.params['time_step']
                heading_change = np.clip(heading_change, -max_change, max_change)
                
                # 更新航向
                heading = heading + heading_change
                if heading < 0:
                    heading += 360
                elif heading >= 360:
                    heading -= 360
                
                # 计算角速度
                angular_velocity_z[i] = np.radians(heading_change / self.params['time_step'])
        
        # 创建轨迹数据
        data = {
            'timestamp_ms': timestamp_ms,
            'longitude': longitude,
            'latitude': latitude,
            'altitude_m': altitude,
            'velocity_north_ms': velocity_north,
            'velocity_east_ms': velocity_east,
            'velocity_down_ms': velocity_down,
            'acceleration_x_ms2': acceleration_x,
            'acceleration_y_ms2': acceleration_y,
            'acceleration_z_ms2': acceleration_z,
            'angular_velocity_x_rads': np.zeros_like(longitude),
            'angular_velocity_y_rads': np.zeros_like(longitude),
            'angular_velocity_z_rads': angular_velocity_z
        }
        
        return pd.DataFrame(data)
    
    def _adjust_point_by_terrain(
            self,
            lon: float,
            lat: float
        ) -> Tuple[float, float]:
        """
        根据地形特征调整路径点
        
        Args:
            lon: 经度
            lat: 纬度
            
        Returns:
            Tuple[float, float]: 调整后的坐标
        """
        # 获取地形特征
        terrain_attrs = self.terrain_analyzer.get_terrain_attributes(lon, lat)
        slope = terrain_attrs['slope_magnitude']
        
        # 获取地表类型
        landcover = self.terrain_loader.get_landcover(lon, lat)
        
        # 根据坡度和地表类型调整点位置（简单示例）
        if slope > 30:  # 陡坡
            # 尝试在周围找到更平缓的位置
            for offset in [(0.001, 0), (-0.001, 0), (0, 0.001), (0, -0.001)]:
                new_lon = lon + offset[0]
                new_lat = lat + offset[1]
                if self._validate_point(new_lon, new_lat):
                    new_slope = self.terrain_analyzer.get_terrain_attributes(
                        new_lon, new_lat
                    )['slope_magnitude']
                    if new_slope < slope:
                        return new_lon, new_lat
        
        return lon, lat
    
    def _calculate_distance(
            self,
            point1: Tuple[float, float],
            point2: Tuple[float, float]
        ) -> float:
        """
        计算两点间的距离（米）
        
        Args:
            point1: 第一个点的坐标（经度, 纬度）
            point2: 第二个点的坐标（经度, 纬度）
            
        Returns:
            float: 距离（米）
        """
        # 使用简化的距离计算（平面近似）
        lon1, lat1 = point1
        lon2, lat2 = point2
        
        dx = (lon2 - lon1) * 111000 * np.cos(np.radians((lat1 + lat2) / 2))
        dy = (lat2 - lat1) * 111000
        
        return np.sqrt(dx**2 + dy**2) 
```

### src/trajectory_generation/path_planner.py
```python
"""
路径规划器
使用A*算法在环境地图上规划最优路径
"""

import logging
from typing import Dict, List, Optional, Set, Tuple
import heapq
import numpy as np

from ..data_processing import TerrainLoader, EnvironmentMapper

logger = logging.getLogger(__name__)

class PathPlanner:
    """路径规划器"""
    
    def __init__(
            self,
            terrain_loader: TerrainLoader,
            environment_mapper: EnvironmentMapper,
            config: Dict
        ):
        """
        初始化路径规划器
        
        Args:
            terrain_loader: 地形数据加载器实例
            environment_mapper: 环境地图生成器实例
            config: 配置参数字典
        """
        self.terrain_loader = terrain_loader
        self.environment_mapper = environment_mapper
        self.config = config
        
        # 获取成本图和其他环境地图
        self.maps = environment_mapper.get_maps()
        self.cost_map = self.maps['cost_map']
        
        # 定义移动方向（8个方向）
        self.directions = [
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1),           (0, 1),
            (1, -1),  (1, 0),  (1, 1)
        ]
        
        # 对角线移动的距离系数
        self.move_costs = [
            np.sqrt(2), 1, np.sqrt(2),
            1,              1,
            np.sqrt(2), 1, np.sqrt(2)
        ]
    
    def plan_path(
            self,
            start: Tuple[int, int],
            end: Tuple[int, int]
        ) -> Optional[List[Tuple[int, int]]]:
        """
        使用A*算法规划路径
        
        Args:
            start: 起点坐标 (row, col)
            end: 终点坐标 (row, col)
            
        Returns:
            Optional[List[Tuple[int, int]]]: 路径点列表，如果找不到路径则返回None
        """
        logger.info(f"开始规划路径: 从{start}到{end}")
        
        # 验证起终点
        if not self._is_valid_point(start) or not self._is_valid_point(end):
            logger.error("起点或终点无效")
            return None
        
        # A*算法的数据结构
        open_set = []  # 优先队列
        closed_set = set()  # 已访问的节点
        came_from = {}  # 路径追踪
        g_score = {start: 0}  # 从起点到当前点的实际代价
        f_score = {start: self._heuristic(start, end)}  # 估计的总代价
        
        # 将起点加入开放列表
        heapq.heappush(open_set, (f_score[start], start))
        
        while open_set:
            # 获取f值最小的节点
            current = heapq.heappop(open_set)[1]
            
            # 到达终点
            if current == end:
                logger.info("找到路径")
                return self._reconstruct_path(came_from, end)
            
            # 将当前节点加入关闭列表
            closed_set.add(current)
            
            # 检查相邻节点
            for i, (dr, dc) in enumerate(self.directions):
                neighbor = (current[0] + dr, current[1] + dc)
                
                # 检查节点是否有效
                if not self._is_valid_point(neighbor):
                    continue
                
                # 如果节点已在关闭列表中，跳过
                if neighbor in closed_set:
                    continue
                
                # 计算经过当前节点到邻居节点的代价
                move_cost = self.move_costs[i]
                tentative_g_score = (
                    g_score[current] +
                    move_cost * self.cost_map[neighbor]
                )
                
                # 如果找到更好的路径或是新节点
                if (neighbor not in g_score or
                    tentative_g_score < g_score[neighbor]):
                    # 更新路径
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = (
                        g_score[neighbor] +
                        self._heuristic(neighbor, end)
                    )
                    
                    # 将邻居节点加入开放列表
                    heapq.heappush(
                        open_set,
                        (f_score[neighbor], neighbor)
                    )
        
        logger.warning("未找到有效路径")
        return None
    
    def _is_valid_point(self, point: Tuple[int, int]) -> bool:
        """
        检查点是否有效
        
        Args:
            point: 坐标点 (row, col)
            
        Returns:
            bool: 是否有效
        """
        row, col = point
        shape = self.cost_map.shape
        
        # 检查边界
        if not (0 <= row < shape[0] and 0 <= col < shape[1]):
            return False
        
        # 检查是否可通行
        if np.isinf(self.cost_map[row, col]):
            return False
        
        return True
    
    def _heuristic(
            self,
            point: Tuple[int, int],
            goal: Tuple[int, int]
        ) -> float:
        """
        计算启发式值（使用欧几里得距离）
        
        Args:
            point: 当前点
            goal: 目标点
            
        Returns:
            float: 启发式值
        """
        return np.sqrt(
            (point[0] - goal[0])**2 +
            (point[1] - goal[1])**2
        )
    
    def _reconstruct_path(
            self,
            came_from: Dict[Tuple[int, int], Tuple[int, int]],
            end: Tuple[int, int]
        ) -> List[Tuple[int, int]]:
        """
        重建路径
        
        Args:
            came_from: 路径追踪字典
            end: 终点
            
        Returns:
            List[Tuple[int, int]]: 路径点列表
        """
        path = [end]
        current = end
        
        while current in came_from:
            current = came_from[current]
            path.append(current)
        
        path.reverse()
        return path
    
    def smooth_path(
            self,
            path: List[Tuple[int, int]],
            smoothing_factor: float = 0.5
        ) -> List[Tuple[int, int]]:
        """
        使用路径平滑算法优化路径
        
        Args:
            path: 原始路径
            smoothing_factor: 平滑因子 (0-1)
            
        Returns:
            List[Tuple[int, int]]: 平滑后的路径
        """
        if len(path) <= 2:
            return path
        
        smoothed = np.array(path, dtype=float)
        change = True
        while change:
            change = False
            for i in range(1, len(path) - 1):
                old_point = smoothed[i].copy()
                
                # 向前后点移动
                smoothed[i] = (smoothed[i] +
                    smoothing_factor * (
                        smoothed[i-1] +
                        smoothed[i+1] -
                        2 * smoothed[i]
                    )
                )
                
                # 检查新位置是否有效
                new_point = tuple(map(int, smoothed[i]))
                if not self._is_valid_point(new_point):
                    smoothed[i] = old_point
                    continue
                
                # 如果点有显著移动，继续迭代
                if not np.allclose(old_point, smoothed[i]):
                    change = True
        
        return [tuple(map(int, p)) for p in smoothed] 
```

### src/trajectory_generation/point_selector.py
```python
"""
起终点选择器
用于批量选择满足约束条件的起终点对
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import numpy as np
from scipy.spatial.distance import cdist

from ..data_processing import TerrainLoader

logger = logging.getLogger(__name__)

class PointSelector:
    """起终点选择器"""
    
    def __init__(
            self,
            terrain_loader: TerrainLoader,
            config: Dict
        ):
        """
        初始化起终点选择器
        
        Args:
            terrain_loader: 地形数据加载器实例
            config: 配置参数字典，包含：
                - NUM_TRAJECTORIES_TO_GENERATE: 要生成的轨迹总数
                - NUM_END_POINTS: 要选择的固定终点数量
                - MIN_START_END_DISTANCE_METERS: 起终点最小直线距离(米)
                - URBAN_LANDCOVER_CODES: 代表城市/建成区的地物编码列表
                - IMPASSABLE_LANDCOVER_CODES: 代表不可通行的地物编码列表
        """
        self.terrain_loader = terrain_loader
        self.config = config
        
        # 验证配置参数
        self._validate_config()
        
        # 初始化结果列表
        self.selected_end_points = []  # [(row, col), ...]
        self.generation_pairs = []     # [(start_point, end_point), ...]
    
    def _validate_config(self) -> None:
        """验证配置参数"""
        required_params = [
            'NUM_TRAJECTORIES_TO_GENERATE',
            'NUM_END_POINTS',
            'MIN_START_END_DISTANCE_METERS',
            'URBAN_LANDCOVER_CODES',
            'IMPASSABLE_LANDCOVER_CODES'
        ]
        
        for param in required_params:
            if param not in self.config:
                raise ValueError(f"缺少必要的配置参数: {param}")
    
    def select_points(self) -> List[Tuple[Tuple[float, float], Tuple[float, float]]]:
        """
        选择满足约束条件的起终点对
        
        Returns:
            List[Tuple[Tuple[float, float], Tuple[float, float]]]:
            起终点对列表，每个元素为((start_lon, start_lat), (end_lon, end_lat))
        """
        logger.info("开始选择起终点对...")
        
        # 选择终点
        self._select_end_points()
        if not self.selected_end_points:
            raise RuntimeError("未能找到合适的终点")
        
        # 为每个终点选择起点
        trajectories_per_end = self.config['NUM_TRAJECTORIES_TO_GENERATE'] // len(self.selected_end_points)
        remaining = self.config['NUM_TRAJECTORIES_TO_GENERATE'] % len(self.selected_end_points)
        
        for i, end_point in enumerate(self.selected_end_points):
            # 确定当前终点需要的起点数量
            n_starts = trajectories_per_end + (1 if i < remaining else 0)
            
            # 选择起点
            start_points = self._select_start_points(end_point, n_starts)
            
            # 转换为地理坐标
            end_coord = self.terrain_loader.transform_pixel_to_coord(*end_point)
            start_coords = [
                self.terrain_loader.transform_pixel_to_coord(*p)
                for p in start_points
            ]
            
            # 添加到生成对列表
            for start_coord in start_coords:
                self.generation_pairs.append((start_coord, end_coord))
        
        logger.info(f"已选择 {len(self.generation_pairs)} 对起终点")
        return self.generation_pairs
    
    def _select_end_points(self) -> None:
        """选择合适的终点"""
        # 获取城市区域掩码
        urban_mask = np.isin(
            self.terrain_loader.landcover_data,
            self.config['URBAN_LANDCOVER_CODES']
        )
        
        # 获取可通行区域掩码
        passable_mask = ~np.isin(
            self.terrain_loader.landcover_data,
            self.config['IMPASSABLE_LANDCOVER_CODES']
        )
        
        # 获取有效终点候选区域
        valid_mask = urban_mask & passable_mask
        valid_points = np.argwhere(valid_mask)
        
        if len(valid_points) < self.config['NUM_END_POINTS']:
            raise RuntimeError(
                f"可用的终点候选数量({len(valid_points)})少于需要的数量"
                f"({self.config['NUM_END_POINTS']})"
            )
        
        # 随机选择终点
        selected_indices = np.random.choice(
            len(valid_points),
            size=self.config['NUM_END_POINTS'],
            replace=False
        )
        
        self.selected_end_points = [
            tuple(valid_points[i])
            for i in selected_indices
        ]
        
        logger.info(f"已选择 {len(self.selected_end_points)} 个终点")
    
    def _select_start_points(
            self,
            end_point: Tuple[int, int],
            n_points: int
        ) -> List[Tuple[int, int]]:
        """
        为指定终点选择合适的起点
        
        Args:
            end_point: 终点像素坐标 (row, col)
            n_points: 需要选择的起点数量
            
        Returns:
            List[Tuple[int, int]]: 起点列表
        """
        # 获取不可通行区域掩码
        impassable_mask = np.isin(
            self.terrain_loader.landcover_data,
            self.config['IMPASSABLE_LANDCOVER_CODES']
        )
        
        # 计算与终点的距离（米）
        rows, cols = np.indices(self.terrain_loader.dem_data.shape)
        distances = self._calculate_distances(
            rows, cols,
            end_point[0], end_point[1]
        )
        
        # 创建有效起点掩码
        valid_mask = (
            ~impassable_mask &  # 可通行
            (distances >= self.config['MIN_START_END_DISTANCE_METERS'])  # 满足最小距离
        )
        
        valid_points = np.argwhere(valid_mask)
        if len(valid_points) < n_points:
            raise RuntimeError(
                f"可用的起点候选数量({len(valid_points)})少于需要的数量({n_points})"
            )
        
        # 随机选择起点
        selected_indices = np.random.choice(
            len(valid_points),
            size=n_points,
            replace=False
        )
        
        return [
            tuple(valid_points[i])
            for i in selected_indices
        ]
    
    def _calculate_distances(
            self,
            rows: np.ndarray,
            cols: np.ndarray,
            end_row: int,
            end_col: int
        ) -> np.ndarray:
        """
        计算栅格中所有点到终点的距离（米）
        
        Args:
            rows: 行索引数组
            cols: 列索引数组
            end_row: 终点行索引
            end_col: 终点列索引
            
        Returns:
            np.ndarray: 距离数组（米）
        """
        # 将像素距离转换为地理距离（米）
        pixel_distances = np.sqrt(
            (rows - end_row)**2 +
            (cols - end_col)**2
        )
        
        return pixel_distances * self.terrain_loader.resolution
    
    def visualize_points(self, output_file: Optional[str] = None) -> None:
        """
        可视化选择的起终点
        
        Args:
            output_file: 输出文件路径，可选
        """
        import matplotlib.pyplot as plt
        
        plt.figure(figsize=(12, 8))
        
        # 绘制地形
        plt.imshow(self.terrain_loader.dem_data, cmap='terrain')
        plt.colorbar(label='Elevation (m)')
        
        # 绘制终点
        end_points = np.array(self.selected_end_points)
        plt.scatter(
            end_points[:, 1],
            end_points[:, 0],
            c='red',
            marker='^',
            s=100,
            label='End Points'
        )
        
        # 绘制起点
        start_points = []
        for start_coord, _ in self.generation_pairs:
            row, col = self.terrain_loader.transform_coordinates(
                start_coord[0],
                start_coord[1]
            )
            start_points.append((row, col))
        
        start_points = np.array(start_points)
        plt.scatter(
            start_points[:, 1],
            start_points[:, 0],
            c='blue',
            marker='o',
            s=50,
            label='Start Points'
        )
        
        plt.title('Selected Start and End Points')
        plt.legend()
        
        if output_file:
            plt.savefig(output_file)
            logger.info(f"已保存可视化结果到: {output_file}")
        else:
            plt.show()
        
        plt.close() 
```

### src/trajectory_generation/trajectory_generator.py
```python
"""
轨迹生成器
实现轨迹插值和速度规划功能
"""

import logging
from typing import Dict, List, Optional, Tuple
import numpy as np
from scipy.interpolate import CubicSpline
from scipy.spatial.distance import cdist

from ..data_processing import TerrainLoader, EnvironmentMapper

logger = logging.getLogger(__name__)

class TrajectoryGenerator:
    """轨迹生成器基类"""
    
    def __init__(
            self,
            terrain_loader: TerrainLoader,
            environment_mapper: EnvironmentMapper,
            config: Dict
        ):
        """
        初始化轨迹生成器
        
        Args:
            terrain_loader: 地形数据加载器实例
            environment_mapper: 环境地图生成器实例
            config: 配置参数字典，包含：
                - dt: 时间步长（秒）
                - MAX_ACCELERATION: 最大加速度（米/秒²）
                - MAX_DECELERATION: 最大减速度（米/秒²）
                - MAX_SPEED: 最大速度（米/秒）
                - MIN_SPEED: 最小速度（米/秒）
        """
        self.terrain_loader = terrain_loader
        self.environment_mapper = environment_mapper
        self.config = config
        
        # 获取环境地图
        self.maps = environment_mapper.get_maps()
        
        # 验证配置参数
        self._validate_config()
    
    def _validate_config(self) -> None:
        """验证配置参数"""
        required_params = [
            'dt',
            'MAX_ACCELERATION',
            'MAX_DECELERATION',
            'MAX_SPEED',
            'MIN_SPEED'
        ]
        
        for param in required_params:
            if param not in self.config:
                raise ValueError(f"缺少必要的配置参数: {param}")
    
    def generate_trajectory(
            self,
            path_points: List[Tuple[int, int]]
        ) -> Dict:
        """
        生成轨迹
        
        Args:
            path_points: 路径点列表，每个点为 (row, col)
            
        Returns:
            Dict: 轨迹数据，包含：
                - timestamps: 时间戳列表（秒）
                - positions: 位置列表，每个元素为 (row, col)
                - speeds: 速度列表（米/秒）
                - headings: 朝向列表（度）
                - coordinates: 地理坐标列表，每个元素为 (lon, lat)
        """
        # 1. 路径插值
        interpolated_path = self._interpolate_path(path_points)
        
        # 2. 速度规划
        speeds = self._plan_speeds(interpolated_path)
        
        # 3. 时间规划
        timestamps = self._plan_timestamps(interpolated_path, speeds)
        
        # 4. 计算朝向
        headings = self._calculate_headings(interpolated_path)
        
        # 5. 转换为地理坐标
        coordinates = [
            self.terrain_loader.transform_pixel_to_coord(row, col)
            for row, col in interpolated_path
        ]
        
        return {
            'timestamps': timestamps,
            'positions': interpolated_path,
            'speeds': speeds,
            'headings': headings,
            'coordinates': coordinates
        }
    
    def _interpolate_path(
            self,
            path_points: List[Tuple[int, int]]
        ) -> List[Tuple[int, int]]:
        """
        使用三次样条插值平滑路径
        
        Args:
            path_points: 原始路径点列表
            
        Returns:
            List[Tuple[int, int]]: 插值后的路径点列表
        """
        if len(path_points) < 2:
            return path_points
        
        # 转换为数组
        points = np.array(path_points)
        
        # 计算路径长度参数
        t = np.zeros(len(points))
        for i in range(1, len(points)):
            t[i] = t[i-1] + np.sqrt(
                np.sum((points[i] - points[i-1])**2)
            )
        
        # 创建更密集的参数点
        num_points = int(t[-1] / self.config['dt'])
        t_new = np.linspace(0, t[-1], num_points)
        
        # 对行和列分别进行插值
        cs_row = CubicSpline(t, points[:, 0])
        cs_col = CubicSpline(t, points[:, 1])
        
        # 生成插值点
        rows = cs_row(t_new)
        cols = cs_col(t_new)
        
        # 转换为整数坐标
        interpolated = list(zip(
            np.round(rows).astype(int),
            np.round(cols).astype(int)
        ))
        
        # 去除重复点
        return list(dict.fromkeys(interpolated))
    
    def _plan_speeds(
            self,
            path_points: List[Tuple[int, int]]
        ) -> List[float]:
        """
        规划速度曲线
        
        Args:
            path_points: 插值后的路径点列表
            
        Returns:
            List[float]: 速度列表（米/秒）
        """
        if len(path_points) < 2:
            return [0.0] * len(path_points)
        
        # 获取每个点的最大允许速度
        max_speeds = [
            min(
                self.maps['max_speed_map'][row, col],
                self.config['MAX_SPEED']
            )
            for row, col in path_points
        ]
        
        # 初始化速度列表
        speeds = [0.0] * len(path_points)
        speeds[0] = self.config['MIN_SPEED']  # 起点速度
        
        # 前向传播：考虑加速度限制
        for i in range(1, len(path_points)):
            # 计算两点间距离
            dist = np.sqrt(
                sum((a - b)**2 for a, b in
                    zip(path_points[i], path_points[i-1]))
            ) * self.terrain_loader.resolution
            
            # 计算可能的最大速度（考虑加速度限制）
            v_prev = speeds[i-1]
            v_max_acc = np.sqrt(
                v_prev**2 +
                2 * self.config['MAX_ACCELERATION'] * dist
            )
            
            # 取较小值作为当前速度
            speeds[i] = min(v_max_acc, max_speeds[i])
        
        # 后向传播：考虑减速度限制
        for i in range(len(path_points)-2, -1, -1):
            # 计算两点间距离
            dist = np.sqrt(
                sum((a - b)**2 for a, b in
                    zip(path_points[i+1], path_points[i]))
            ) * self.terrain_loader.resolution
            
            # 计算为了安全减速需要的速度
            v_next = speeds[i+1]
            v_max_dec = np.sqrt(
                v_next**2 +
                2 * self.config['MAX_DECELERATION'] * dist
            )
            
            # 更新速度
            speeds[i] = min(speeds[i], v_max_dec)
        
        return speeds
    
    def _plan_timestamps(
            self,
            path_points: List[Tuple[int, int]],
            speeds: List[float]
        ) -> List[float]:
        """
        规划时间戳
        
        Args:
            path_points: 路径点列表
            speeds: 速度列表
            
        Returns:
            List[float]: 时间戳列表（秒）
        """
        timestamps = [0.0]  # 起点时间戳
        
        for i in range(1, len(path_points)):
            # 计算两点间距离
            dist = np.sqrt(
                sum((a - b)**2 for a, b in
                    zip(path_points[i], path_points[i-1]))
            ) * self.terrain_loader.resolution
            
            # 使用平均速度计算时间增量
            avg_speed = (speeds[i] + speeds[i-1]) / 2
            dt = dist / max(avg_speed, self.config['MIN_SPEED'])
            
            # 添加时间戳
            timestamps.append(timestamps[-1] + dt)
        
        return timestamps
    
    def _calculate_headings(
            self,
            path_points: List[Tuple[int, int]]
        ) -> List[float]:
        """
        计算路径点的朝向角度
        
        Args:
            path_points: 路径点列表
            
        Returns:
            List[float]: 朝向角度列表（度，北为0，顺时针为正）
        """
        if len(path_points) < 2:
            return [0.0] * len(path_points)
        
        headings = []
        
        # 计算第一个点的朝向（使用下一个点）
        dx = path_points[1][1] - path_points[0][1]
        dy = path_points[1][0] - path_points[0][0]
        heading = np.degrees(np.arctan2(dx, -dy)) % 360
        headings.append(heading)
        
        # 计算中间点的朝向（使用前后点的平均）
        for i in range(1, len(path_points)-1):
            dx = path_points[i+1][1] - path_points[i-1][1]
            dy = path_points[i+1][0] - path_points[i-1][0]
            heading = np.degrees(np.arctan2(dx, -dy)) % 360
            headings.append(heading)
        
        # 计算最后一个点的朝向（使用前一个点）
        dx = path_points[-1][1] - path_points[-2][1]
        dy = path_points[-1][0] - path_points[-2][0]
        heading = np.degrees(np.arctan2(dx, -dy)) % 360
        headings.append(heading)
        
        return headings 
```

### src/utils/__init__.py
```python

```

### src/utils/config.py
```python
"""
统一配置管理模块
"""

import os
from pathlib import Path
from typing import Dict, List, Optional, Union
from dataclasses import dataclass, field

@dataclass
class PathConfig:
    """路径配置"""
    # 输入数据路径
    INPUT_DIR: Path = Path("data/input")
    GIS_DIR: Path = INPUT_DIR / "gis"
    OORD_DIR: Path = INPUT_DIR / "oord"
    
    # GIS数据文件
    DEM_FILE: Path = GIS_DIR / "dem_30m_100km.tif"
    LANDCOVER_FILE: Path = GIS_DIR / "landcover_30m_100km.tif"
    
    # 输出数据路径
    OUTPUT_DIR: Path = Path("data/output")
    INTERMEDIATE_DIR: Path = OUTPUT_DIR / "intermediate"
    TRAJECTORY_DIR: Path = OUTPUT_DIR / "trajectory_generation"
    EVALUATION_DIR: Path = OUTPUT_DIR / "evaluation"
    
    # 中间文件
    SLOPE_FILE: Path = INTERMEDIATE_DIR / "slope_magnitude_30m_100km.tif"
    ASPECT_FILE: Path = INTERMEDIATE_DIR / "slope_aspect_30m_100km.tif"
    LEARNED_PATTERNS_FILE: Path = INTERMEDIATE_DIR / "learned_patterns.pkl"
    PROCESSED_OORD_FILE: Path = INTERMEDIATE_DIR / "processed_oord_data.csv"

@dataclass
class TerrainConfig:
    """地形配置"""
    # 坡度分级（度）
    SLOPE_BINS: List[float] = field(default_factory=lambda: [0, 5, 10, 15, 20, 25, 30])
    
    # 坡度限制（度）
    MAX_SLOPE: float = 30.0
    
    # 土地覆盖类型代码
    LANDCOVER_CODES: Dict[int, str] = field(default_factory=lambda: {
        0: '未知',
        1: '平地',
        2: '山地',
        3: '丘陵',
        4: '水域',
        5: '建筑区'
    })

@dataclass
class MotionConfig:
    """运动配置"""
    # 速度相关
    DEFAULT_SPEED: float = 5.0   # 默认速度（米/秒）
    MAX_SPEED: float = 10.0      # 最大速度（米/秒）
    MIN_SPEED: float = 2.0       # 最小速度（米/秒）
    SPEED_STDDEV: float = 1.0    # 速度标准差（米/秒）
    
    # 加速度相关
    MAX_ACCELERATION: float = 1.0  # 最大加速度（米/秒²）
    MAX_DECELERATION: float = 2.0  # 最大减速度（米/秒²）
    
    # 转向相关
    MAX_TURN_RATE: float = 30.0  # 最大转向率（度/秒）
    MAX_SLOPE_DEGREES: float = 30.0  # 最大可通行坡度（度）
    
    # 地形影响因子
    SLOPE_SPEED_FACTOR: float = 0.1  # 坡度对速度的影响因子
    CROSS_SLOPE_FACTOR: float = 0.2  # 横向坡度对速度的影响因子
    
    # 路径跟随参数
    WAYPOINT_THRESHOLD: float = 5.0  # 到达路径点的距离阈值（米）

@dataclass
class GenerationConfig:
    """轨迹生成配置"""
    # 生成数量
    NUM_TRAJECTORIES: int = 500
    NUM_END_POINTS: int = 3
    
    # 距离约束（米）
    MIN_START_END_DISTANCE: float = 80000.0
    MAX_START_END_DISTANCE: float = 100000.0
    
    # 环境组标签格式
    GROUP_LABEL_FORMAT: str = "LC{lc}_S{slope}"

@dataclass
class Config:
    """全局配置"""
    # 版本信息
    VERSION: str = "1.2"
    DATE: str = "2024-03-27"
    
    # 子配置
    paths: PathConfig = PathConfig()
    terrain: TerrainConfig = TerrainConfig()
    motion: MotionConfig = MotionConfig()
    generation: GenerationConfig = GenerationConfig()
    
    def __post_init__(self):
        """初始化后处理"""
        # 创建必要的目录
        for path in [
            self.paths.INPUT_DIR,
            self.paths.GIS_DIR,
            self.paths.OORD_DIR,
            self.paths.OUTPUT_DIR,
            self.paths.INTERMEDIATE_DIR,
            self.paths.TRAJECTORY_DIR,
            self.paths.EVALUATION_DIR
        ]:
            path.mkdir(parents=True, exist_ok=True)
    
    @classmethod
    def from_env(cls) -> 'Config':
        """从环境变量加载配置"""
        config = cls()
        
        # 示例：从环境变量覆盖配置
        if 'MAX_SPEED' in os.environ:
            config.motion.MAX_SPEED = float(os.environ['MAX_SPEED'])
        
        return config

# 创建全局配置实例
config = Config()

# 配置文件
config = {
    'terrain': {
        # 坡度分级（度）
        'SLOPE_BINS': [0, 5, 10, 15, 20, 25, 30],
        
        # 坡度限制（度）
        'MAX_SLOPE': 30.0,
        
        # 土地覆盖类型代码
        'LANDCOVER_CODES': {
            0: '未知',
            1: '平地',
            2: '山地',
            3: '丘陵',
            4: '水域',
            5: '建筑区'
        },
        
        # 不可通行的土地覆盖类型
        'IMPASSABLE_LANDCOVER_CODES': [4, 5],
        
        # 土地覆盖类型对速度的影响因子
        'SPEED_FACTORS': {
            0: 1.0,  # 未知
            1: 1.0,  # 平地
            2: 0.7,  # 山地
            3: 0.8,  # 丘陵
            4: 0.0,  # 水域
            5: 0.0   # 建筑区
        }
    },
    
    'motion': {
        # 速度相关
        'DEFAULT_SPEED': 5.0,   # 默认速度（米/秒）
        'MAX_SPEED': 10.0,      # 最大速度（米/秒）
        'MIN_SPEED': 2.0,       # 最小速度（米/秒）
        'SPEED_STDDEV': 1.0,    # 速度标准差（米/秒）
        
        # 加速度相关
        'MAX_ACCELERATION': 1.0,  # 最大加速度（米/秒²）
        'MAX_DECELERATION': 2.0,  # 最大减速度（米/秒²）
        
        # 转向相关
        'MAX_TURN_RATE': 30.0,  # 最大转向率（度/秒）
        'MAX_SLOPE_DEGREES': 30.0,  # 最大可通行坡度（度）
        
        # 地形影响因子
        'SLOPE_SPEED_FACTOR': 0.1,  # 坡度对速度的影响因子
        'CROSS_SLOPE_FACTOR': 0.2,  # 横向坡度对速度的影响因子
        
        # 路径跟随参数
        'WAYPOINT_THRESHOLD': 5.0,  # 到达路径点的距离阈值（米）
    }
} 
```

### src/utils/logging_utils.py
```python
"""
日志工具模块
用于配置和管理日志
"""

import logging
from pathlib import Path
import matplotlib
import PIL
import rasterio
import sklearn

def setup_logging(log_file: str = None, log_level: int = logging.INFO) -> None:
    """
    设置日志配置
    
    Args:
        log_file: 日志文件路径，如果为None则只输出到控制台
        log_level: 日志级别，默认为INFO
    """
    # 创建根日志记录器
    logger = logging.getLogger()
    logger.setLevel(log_level)
    
    # 清除现有的处理器
    logger.handlers.clear()
    
    # 创建格式化器
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # 添加控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    
    # 如果指定了日志文件，添加文件处理器
    if log_file:
        # 确保日志目录存在
        log_path = Path(log_file)
        log_path.parent.mkdir(parents=True, exist_ok=True)
        
        file_handler = logging.FileHandler(log_file)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
    
    # 设置第三方库的日志级别
    logging.getLogger('matplotlib').setLevel(logging.WARNING)
    logging.getLogger('PIL').setLevel(logging.WARNING)
    logging.getLogger('rasterio').setLevel(logging.WARNING)
    logging.getLogger('sklearn').setLevel(logging.WARNING) 
```

### src/utils/visualization.py
```python
"""
可视化工具模块
提供轨迹可视化功能
"""

import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
from typing import List, Tuple, Optional

def plot_trajectory_on_map(
        dem_data: np.ndarray,
        real_path: np.ndarray,
        sim_path: np.ndarray,
        output_file: Path,
        title: str = "轨迹对比"
    ) -> None:
    """
    在DEM地图上绘制轨迹对比图
    
    Args:
        dem_data: DEM高程数据
        real_path: 真实轨迹点坐标 [[row, col], ...]
        sim_path: 模拟轨迹点坐标 [[row, col], ...]
        output_file: 输出文件路径
        title: 图表标题
    """
    plt.figure(figsize=(12, 8))
    
    # 绘制DEM地图作为背景
    plt.imshow(
        dem_data,
        cmap='terrain',
        aspect='equal'
    )
    plt.colorbar(label='高程 (米)')
    
    # 绘制真实轨迹
    plt.plot(
        real_path[:, 1],  # col坐标作为x
        real_path[:, 0],  # row坐标作为y
        'b-',
        linewidth=2,
        label='真实轨迹',
        alpha=0.8
    )
    
    # 绘制模拟轨迹
    plt.plot(
        sim_path[:, 1],
        sim_path[:, 0],
        'r--',
        linewidth=2,
        label='模拟轨迹',
        alpha=0.8
    )
    
    # 标记起点和终点
    plt.plot(
        real_path[0, 1],
        real_path[0, 0],
        'go',
        markersize=10,
        label='起点'
    )
    plt.plot(
        real_path[-1, 1],
        real_path[-1, 0],
        'ro',
        markersize=10,
        label='终点'
    )
    
    plt.title(title)
    plt.xlabel('列坐标')
    plt.ylabel('行坐标')
    plt.legend()
    plt.grid(True)
    
    # 保存图像
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    plt.close()
    
def plot_speed_map(
        speed_map: np.ndarray,
        output_file: Path,
        title: str = "速度地图",
        cmap: str = 'viridis'
    ) -> None:
    """
    绘制速度地图
    
    Args:
        speed_map: 速度地图数据
        output_file: 输出文件路径
        title: 图表标题
        cmap: 颜色映射
    """
    plt.figure(figsize=(10, 8))
    
    im = plt.imshow(speed_map, cmap=cmap)
    plt.colorbar(im, label='速度 (米/秒)')
    
    plt.title(title)
    plt.xlabel('列坐标')
    plt.ylabel('行坐标')
    plt.grid(True)
    
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    plt.close()
    
def plot_terrain_maps(
        dem_data: np.ndarray,
        slope_magnitude: np.ndarray,
        slope_aspect: np.ndarray,
        landcover: Optional[np.ndarray] = None,
        output_dir: Path = None
    ) -> None:
    """
    绘制地形相关的地图
    
    Args:
        dem_data: DEM高程数据
        slope_magnitude: 坡度大小数据
        slope_aspect: 坡向数据
        landcover: 土地覆盖类型数据
        output_dir: 输出目录
    """
    if output_dir is None:
        output_dir = Path('outputs/terrain_maps')
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # 绘制DEM地图
    plt.figure(figsize=(10, 8))
    im = plt.imshow(dem_data, cmap='terrain')
    plt.colorbar(im, label='高程 (米)')
    plt.title('DEM高程图')
    plt.xlabel('列坐标')
    plt.ylabel('行坐标')
    plt.grid(True)
    plt.savefig(
        output_dir / 'dem_map.png',
        dpi=300,
        bbox_inches='tight'
    )
    plt.close()
    
    # 绘制坡度图
    plt.figure(figsize=(10, 8))
    im = plt.imshow(slope_magnitude, cmap='YlOrRd')
    plt.colorbar(im, label='坡度 (度)')
    plt.title('坡度图')
    plt.xlabel('列坐标')
    plt.ylabel('行坐标')
    plt.grid(True)
    plt.savefig(
        output_dir / 'slope_magnitude_map.png',
        dpi=300,
        bbox_inches='tight'
    )
    plt.close()
    
    # 绘制坡向图
    plt.figure(figsize=(10, 8))
    im = plt.imshow(slope_aspect, cmap='hsv')
    plt.colorbar(im, label='坡向 (度)')
    plt.title('坡向图')
    plt.xlabel('列坐标')
    plt.ylabel('行坐标')
    plt.grid(True)
    plt.savefig(
        output_dir / 'slope_aspect_map.png',
        dpi=300,
        bbox_inches='tight'
    )
    plt.close()
    
    # 如果有土地覆盖数据，绘制土地覆盖图
    if landcover is not None:
        plt.figure(figsize=(10, 8))
        im = plt.imshow(landcover, cmap='tab20')
        plt.colorbar(im, label='土地覆盖类型')
        plt.title('土地覆盖图')
        plt.xlabel('列坐标')
        plt.ylabel('行坐标')
        plt.grid(True)
        plt.savefig(
            output_dir / 'landcover_map.png',
            dpi=300,
            bbox_inches='tight'
        )
        plt.close() 
```

### test_plot_style.py
```python
import matplotlib.pyplot as plt
import numpy as np
import plot_style  # 导入样式设置

# 创建测试数据
x = np.linspace(0, 10, 100)
y1 = 1e3 * np.sin(x)
y2 = 1e-3 * np.cos(x)

# 创建图形
fig, ax = plt.subplots()

# 绘制曲线
ax.plot(x, y1, 'b-', label='正弦曲线')
ax.plot(x, y2, 'r--', label='余弦曲线')

# 设置标题和标签
ax.set_title('三角函数测试图')
ax.set_xlabel('时间 (s)')
ax.set_ylabel(r'幅值 ($\times 10^{-3}$)')  # 使用原始字符串

# 添加图例
ax.legend()

# 保存图片
plt.savefig('test_style.png', bbox_inches='tight')
print("图片已保存为 test_style.png") 
```

### tests/__init__.py
```python

```

### tests/conftest.py
```python
"""
测试配置文件
定义测试环境和通用fixture
"""

import os
import sys
from pathlib import Path
import pytest
import numpy as np

# 添加项目根目录到Python路径
PROJECT_ROOT = Path(__file__).parent.parent.absolute()
sys.path.append(str(PROJECT_ROOT))

# 测试数据目录
TEST_DATA_DIR = PROJECT_ROOT / "tests" / "test_data"
TEST_DATA_DIR.mkdir(parents=True, exist_ok=True)

@pytest.fixture
def test_dem_data():
    """生成测试用DEM数据"""
    # 创建一个简单的10x10的DEM数据
    dem = np.array([
        [100, 100, 100, 100, 100, 100, 100, 100, 100, 100],
        [100, 110, 110, 110, 110, 110, 110, 110, 110, 100],
        [100, 110, 120, 120, 120, 120, 120, 120, 110, 100],
        [100, 110, 120, 130, 130, 130, 130, 120, 110, 100],
        [100, 110, 120, 130, 140, 140, 130, 120, 110, 100],
        [100, 110, 120, 130, 140, 140, 130, 120, 110, 100],
        [100, 110, 120, 130, 130, 130, 130, 120, 110, 100],
        [100, 110, 120, 120, 120, 120, 120, 120, 110, 100],
        [100, 110, 110, 110, 110, 110, 110, 110, 110, 100],
        [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]
    ], dtype=np.float32)
    return dem

@pytest.fixture
def test_landcover_data():
    """生成测试用土地覆盖数据"""
    # 创建一个简单的10x10的土地覆盖数据
    landcover = np.array([
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 2, 2, 2, 2, 2, 2, 2, 2, 1],
        [1, 2, 3, 3, 3, 3, 3, 3, 2, 1],
        [1, 2, 3, 4, 4, 4, 4, 3, 2, 1],
        [1, 2, 3, 4, 5, 5, 4, 3, 2, 1],
        [1, 2, 3, 4, 5, 5, 4, 3, 2, 1],
        [1, 2, 3, 4, 4, 4, 4, 3, 2, 1],
        [1, 2, 3, 3, 3, 3, 3, 3, 2, 1],
        [1, 2, 2, 2, 2, 2, 2, 2, 2, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ], dtype=np.int32)
    return landcover

@pytest.fixture
def test_trajectory_data(tmp_path):
    """生成测试用轨迹数据"""
    # 创建一个简单的轨迹CSV文件
    import pandas as pd
    
    # 生成测试数据 - 使用正弦曲线生成更真实的轨迹
    n_points = 20
    timestamps = pd.date_range('2024-03-27', periods=n_points, freq='30s')
    t = np.linspace(0, 2*np.pi, n_points)
    
    # 基准点和振幅
    base_lon, base_lat = 116.0, 39.0
    amp_lon, amp_lat = 0.01, 0.01
    
    data = {
        'timestamp': timestamps,
        'longitude': base_lon + amp_lon * np.sin(t),
        'latitude': base_lat + amp_lat * np.cos(t)
    }
    df = pd.DataFrame(data)
    
    # 保存到临时文件
    test_file = tmp_path / "test_trajectory.csv"
    df.to_csv(test_file, index=False)
    return test_file 
```

### tests/core/terrain/test_analyzer.py
```python
"""
地形分析器单元测试
"""

import unittest
import numpy as np
from pathlib import Path
from unittest.mock import patch, MagicMock

from src.core.terrain import TerrainAnalyzer
from src.utils.config import config

class TestTerrainAnalyzer(unittest.TestCase):
    """地形分析器测试类"""
    
    def setUp(self):
        """测试前准备"""
        self.analyzer = TerrainAnalyzer()
        
        # 创建测试用DEM数据
        self.test_dem = np.array([
            [100, 110, 120],
            [105, 115, 125],
            [110, 120, 130]
        ])
        
        # 模拟rasterio.open
        self.rasterio_mock = MagicMock()
        self.rasterio_mock.read.return_value = self.test_dem
        self.rasterio_mock.transform = [30.0, 0.0, 0.0, 0.0, -30.0, 0.0]
        
    def test_load_dem(self):
        """测试加载DEM数据"""
        with patch('rasterio.open', return_value=self.rasterio_mock):
            self.analyzer.load_dem(Path('test.tif'))
            
        np.testing.assert_array_equal(
            self.analyzer.dem_data,
            self.test_dem
        )
        self.assertEqual(self.analyzer.resolution, 30.0)
        
    def test_calculate_slope_magnitude(self):
        """测试计算坡度大小"""
        self.analyzer.dem_data = self.test_dem
        self.analyzer.resolution = 30.0
        
        self.analyzer.calculate_slope_magnitude()
        
        # 验证坡度计算结果
        self.assertIsNotNone(self.analyzer.slope_magnitude)
        self.assertEqual(
            self.analyzer.slope_magnitude.shape,
            self.test_dem.shape
        )
        
        # 验证梯度计算结果
        self.assertIsNotNone(self.analyzer.dzdx)
        self.assertIsNotNone(self.analyzer.dzdy)
        
    def test_calculate_slope_aspect(self):
        """测试计算坡向"""
        self.analyzer.dem_data = self.test_dem
        self.analyzer.resolution = 30.0
        self.analyzer.calculate_slope_magnitude()
        
        self.analyzer.calculate_slope_aspect()
        
        # 验证坡向计算结果
        self.assertIsNotNone(self.analyzer.slope_aspect)
        self.assertEqual(
            self.analyzer.slope_aspect.shape,
            self.test_dem.shape
        )
        
        # 验证坡向范围
        self.assertTrue(np.all(
            (self.analyzer.slope_aspect >= -1) &
            (self.analyzer.slope_aspect < 360)
        ))
        
    def test_get_terrain_attributes(self):
        """测试获取地形属性"""
        self.analyzer.dem_data = self.test_dem
        self.analyzer.resolution = 30.0
        self.analyzer.calculate_slope_magnitude()
        self.analyzer.calculate_slope_aspect()
        
        slope, aspect = self.analyzer.get_terrain_attributes(1, 1)
        
        self.assertIsInstance(slope, float)
        self.assertIsInstance(aspect, float)
        self.assertTrue(0 <= slope <= 90)
        self.assertTrue(-1 <= aspect < 360)
        
    def test_save_results(self):
        """测试保存计算结果"""
        self.analyzer.dem_data = self.test_dem
        self.analyzer.resolution = 30.0
        self.analyzer.calculate_slope_magnitude()
        self.analyzer.calculate_slope_aspect()
        
        with patch('rasterio.open') as mock_open:
            self.analyzer.save_results()
            
            # 验证是否调用了rasterio.open保存结果
            self.assertEqual(mock_open.call_count, 2)
            
if __name__ == '__main__':
    unittest.main() 
```

### tests/core/terrain/test_loader.py
```python
"""
地形加载器单元测试
"""

import unittest
import numpy as np
from pathlib import Path
from unittest.mock import patch, MagicMock

from src.core.terrain import TerrainLoader
from src.utils.config import config

class TestTerrainLoader(unittest.TestCase):
    """地形加载器测试类"""
    
    def setUp(self):
        """测试前准备"""
        self.loader = TerrainLoader()
        
        # 创建测试数据
        self.test_dem = np.array([
            [100, 110, 120],
            [105, 115, 125],
            [110, 120, 130]
        ])
        self.test_landcover = np.array([
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
        ])
        self.test_slope = np.array([
            [5, 10, 15],
            [7, 12, 17],
            [9, 14, 19]
        ])
        self.test_aspect = np.array([
            [45, 90, 135],
            [60, 120, 180],
            [90, 150, 225]
        ])
        
        # 模拟rasterio.open
        self.rasterio_mock = MagicMock()
        self.rasterio_mock.transform = [30.0, 0.0, 0.0, 0.0, -30.0, 0.0]
        self.rasterio_mock.crs = 'EPSG:4326'
        
    def test_load_dem(self):
        """测试加载DEM数据"""
        self.rasterio_mock.read.return_value = self.test_dem
        
        with patch('rasterio.open', return_value=self.rasterio_mock):
            self.loader.load_dem(Path('test.tif'))
            
        np.testing.assert_array_equal(
            self.loader.dem_data,
            self.test_dem
        )
        self.assertEqual(self.loader.resolution, 30.0)
        self.assertEqual(self.loader.crs, 'EPSG:4326')
        
    def test_load_landcover(self):
        """测试加载土地覆盖数据"""
        self.rasterio_mock.read.return_value = self.test_landcover
        
        with patch('rasterio.open', return_value=self.rasterio_mock):
            self.loader.load_landcover(Path('test.tif'))
            
        np.testing.assert_array_equal(
            self.loader.landcover_data,
            self.test_landcover
        )
        
    def test_load_slope(self):
        """测试加载坡度数据"""
        self.rasterio_mock.read.return_value = self.test_slope
        
        with patch('rasterio.open', return_value=self.rasterio_mock):
            self.loader.load_slope(Path('test.tif'))
            
        np.testing.assert_array_equal(
            self.loader.slope_data,
            self.test_slope
        )
        
    def test_load_aspect(self):
        """测试加载坡向数据"""
        self.rasterio_mock.read.return_value = self.test_aspect
        
        with patch('rasterio.open', return_value=self.rasterio_mock):
            self.loader.load_aspect(Path('test.tif'))
            
        np.testing.assert_array_equal(
            self.loader.aspect_data,
            self.test_aspect
        )
        
    def test_get_terrain_attributes(self):
        """测试获取地形属性"""
        self.loader.dem_data = self.test_dem
        self.loader.landcover_data = self.test_landcover
        self.loader.slope_data = self.test_slope
        self.loader.aspect_data = self.test_aspect
        
        attrs = self.loader.get_terrain_attributes(1, 1)
        
        self.assertEqual(attrs['elevation'], 115.0)
        self.assertEqual(attrs['landcover'], 5)
        self.assertEqual(attrs['slope'], 12.0)
        self.assertEqual(attrs['aspect'], 120.0)
        
    def test_pixel_to_coord(self):
        """测试像素坐标转地理坐标"""
        self.loader.transform = self.rasterio_mock.transform
        
        x, y = self.loader.pixel_to_coord(1, 1)
        
        self.assertEqual(x, 30.0)
        self.assertEqual(y, -30.0)
        
    def test_coord_to_pixel(self):
        """测试地理坐标转像素坐标"""
        self.loader.transform = self.rasterio_mock.transform
        
        row, col = self.loader.coord_to_pixel(30.0, -30.0)
        
        self.assertEqual(row, 1)
        self.assertEqual(col, 1)
        
    def test_is_valid_pixel(self):
        """测试像素坐标有效性检查"""
        self.loader.dem_data = self.test_dem
        
        self.assertTrue(self.loader.is_valid_pixel(1, 1))
        self.assertFalse(self.loader.is_valid_pixel(3, 3))
        self.assertFalse(self.loader.is_valid_pixel(-1, -1))
        
    def test_is_passable(self):
        """测试可通行性检查"""
        self.loader.dem_data = self.test_dem
        self.loader.landcover_data = self.test_landcover
        self.loader.slope_data = self.test_slope
        
        # 设置不可通行的地物编码和最大坡度
        config.terrain.IMPASSABLE_LANDCOVER = [9]
        config.motion.MAX_SLOPE = 15.0
        
        self.assertTrue(self.loader.is_passable(1, 1))  # 可通行
        self.assertFalse(self.loader.is_passable(2, 2))  # 不可通行（地物编码）
        self.assertFalse(self.loader.is_passable(0, 2))  # 不可通行（坡度）
        
if __name__ == '__main__':
    unittest.main() 
```

### tests/core/test_batch_generator.py
```python
"""
批量轨迹生成器单元测试
"""

import unittest
import json
from pathlib import Path
from unittest.mock import MagicMock, patch

from src.core.terrain import TerrainLoader
from src.core.batch_generator import BatchGenerator
from src.utils.config import config

class TestBatchGenerator(unittest.TestCase):
    """批量轨迹生成器测试类"""
    
    def setUp(self):
        """测试前准备"""
        # 创建模拟的地形加载器
        self.terrain_loader = MagicMock(spec=TerrainLoader)
        
        # 创建临时输出目录
        self.test_output_dir = Path('test_output')
        self.test_output_dir.mkdir(exist_ok=True)
        
        # 创建批量生成器
        self.generator = BatchGenerator(
            terrain_loader=self.terrain_loader,
            output_dir=self.test_output_dir,
            num_workers=2
        )
        
        # 模拟配置参数
        config.generation.NUM_TRAJECTORIES_TO_GENERATE = 4
        config.generation.NUM_END_POINTS = 2
        
        # 模拟起终点选择器返回的点对
        self.test_pairs = [
            ((0.0, 0.0), (100.0, 100.0)),
            ((0.0, 100.0), (100.0, 0.0)),
            ((50.0, 0.0), (50.0, 100.0)),
            ((0.0, 50.0), (100.0, 50.0))
        ]
        self.generator.point_selector.select_points = MagicMock(
            return_value=self.test_pairs
        )
        
        # 模拟轨迹生成器返回的轨迹数据
        self.test_trajectory = {
            'timestamp': [0.0, 1.0, 2.0],
            'x': [0.0, 50.0, 100.0],
            'y': [0.0, 50.0, 100.0],
            'speed': [10.0, 10.0, 10.0],
            'orientation': [45.0, 45.0, 45.0]
        }
        self.generator.trajectory_generator.generate_trajectory = MagicMock(
            return_value=self.test_trajectory
        )
        
    def tearDown(self):
        """测试后清理"""
        # 删除测试输出目录
        import shutil
        shutil.rmtree(self.test_output_dir)
        
    def test_init(self):
        """测试初始化"""
        self.assertEqual(self.generator.num_workers, 2)
        self.assertEqual(self.generator.output_dir, self.test_output_dir)
        self.assertTrue(self.test_output_dir.exists())
        
    def test_generate_batch(self):
        """测试批量生成"""
        # 生成轨迹
        trajectory_files = self.generator.generate_batch()
        
        # 验证生成的文件数量
        self.assertEqual(len(trajectory_files), 4)
        
        # 验证文件内容
        for file_path in trajectory_files:
            self.assertTrue(file_path.exists())
            
            with open(file_path) as f:
                trajectory = json.load(f)
                
            # 验证轨迹数据
            self.assertIn('timestamp', trajectory)
            self.assertIn('x', trajectory)
            self.assertIn('y', trajectory)
            self.assertIn('speed', trajectory)
            self.assertIn('orientation', trajectory)
            
            # 验证元数据
            self.assertIn('metadata', trajectory)
            metadata = trajectory['metadata']
            self.assertIn('start_point', metadata)
            self.assertIn('end_point', metadata)
            self.assertIn('index', metadata)
            self.assertIn('generation_time', metadata)
            
    def test_generate_single_trajectory(self):
        """测试单条轨迹生成"""
        start_point = (0.0, 0.0)
        end_point = (100.0, 100.0)
        idx = 0
        
        # 生成轨迹
        trajectory_file = self.generator._generate_single_trajectory(
            start_point,
            end_point,
            idx
        )
        
        # 验证文件是否存在
        self.assertTrue(trajectory_file.exists())
        
        # 验证文件内容
        with open(trajectory_file) as f:
            trajectory = json.load(f)
            
        # 验证轨迹数据
        self.assertEqual(trajectory['x'], self.test_trajectory['x'])
        self.assertEqual(trajectory['y'], self.test_trajectory['y'])
        self.assertEqual(trajectory['speed'], self.test_trajectory['speed'])
        self.assertEqual(
            trajectory['orientation'],
            self.test_trajectory['orientation']
        )
        
        # 验证元数据
        metadata = trajectory['metadata']
        self.assertEqual(metadata['start_point'], list(start_point))
        self.assertEqual(metadata['end_point'], list(end_point))
        self.assertEqual(metadata['index'], idx)
        self.assertIsNotNone(metadata['generation_time'])
        
    def test_save_trajectory(self):
        """测试轨迹保存"""
        trajectory = self.test_trajectory.copy()
        file_path = self.test_output_dir / "test_trajectory.json"
        
        # 保存轨迹
        self.generator._save_trajectory(trajectory, file_path)
        
        # 验证文件是否存在
        self.assertTrue(file_path.exists())
        
        # 验证文件内容
        with open(file_path) as f:
            saved_trajectory = json.load(f)
            
        # 验证数据完整性
        for key in self.test_trajectory:
            self.assertEqual(
                saved_trajectory[key],
                self.test_trajectory[key]
            )
            
    def test_error_handling(self):
        """测试错误处理"""
        # 模拟轨迹生成失败
        self.generator.trajectory_generator.generate_trajectory.side_effect = \
            Exception("测试错误")
            
        # 生成轨迹
        trajectory_files = self.generator.generate_batch()
        
        # 验证返回空列表
        self.assertEqual(len(trajectory_files), 0)
        
if __name__ == '__main__':
    unittest.main() 
```

### tests/core/test_evaluator.py
```python
"""
轨迹评估器单元测试
"""

import unittest
import json
import numpy as np
import pandas as pd
from pathlib import Path
from unittest.mock import patch

from src.core.evaluator import Evaluator

class TestEvaluator(unittest.TestCase):
    """评估器测试类"""
    
    def setUp(self):
        """测试前准备"""
        # 创建临时目录
        self.test_output_dir = Path('test_output')
        self.test_output_dir.mkdir(exist_ok=True)
        
        # 创建评估器
        self.evaluator = Evaluator(output_dir=self.test_output_dir)
        
        # 创建测试数据
        self._create_test_data()
        
    def tearDown(self):
        """测试后清理"""
        # 删除临时目录
        import shutil
        shutil.rmtree(self.test_output_dir)
        
    def _create_test_data(self):
        """创建测试数据"""
        # 创建OORD测试数据
        self.oord_data = pd.DataFrame({
            'timestamp': np.arange(0, 10, 0.1),
            'x': np.linspace(0, 100, 100),
            'y': np.linspace(0, 100, 100),
            'speed': np.random.normal(10, 2, 100),
            'orientation': np.linspace(0, 360, 100),
            'trajectory_id': np.repeat([1, 2], 50),
            'group_label': np.repeat(['A', 'B'], 50)
        })
        
        # 保存OORD数据
        self.oord_file = self.test_output_dir / 'test_oord.csv'
        self.oord_data.to_csv(self.oord_file, index=False)
        
        # 创建合成轨迹测试数据
        self.synthetic_dir = self.test_output_dir / 'synthetic'
        self.synthetic_dir.mkdir(exist_ok=True)
        
        for i in range(2):
            trajectory = {
                'timestamp': list(np.arange(0, 10, 0.1)),
                'x': list(np.linspace(0, 100, 100)),
                'y': list(np.linspace(0, 100, 100)),
                'speed': list(np.random.normal(10, 2, 100)),
                'orientation': list(np.linspace(0, 360, 100)),
                'metadata': {
                    'index': i,
                    'start_point': [0, 0],
                    'end_point': [100, 100]
                }
            }
            
            with open(self.synthetic_dir / f'trajectory_{i+1}.json', 'w') as f:
                json.dump(trajectory, f)
                
    def test_load_data(self):
        """测试数据加载"""
        self.evaluator.load_data(self.oord_file, self.synthetic_dir)
        
        # 验证OORD数据
        self.assertIsNotNone(self.evaluator.oord_data)
        self.assertEqual(len(self.evaluator.oord_data), 100)
        
        # 验证合成数据
        self.assertIsNotNone(self.evaluator.synthetic_data)
        self.assertEqual(len(self.evaluator.synthetic_data), 200)
        
    def test_evaluate(self):
        """测试评估"""
        self.evaluator.load_data(self.oord_file, self.synthetic_dir)
        metrics = self.evaluator.evaluate()
        
        # 验证指标
        self.assertIn('speed_ks_stat', metrics)
        self.assertIn('speed_ks_p_value', metrics)
        self.assertIn('acceleration_ks_stat', metrics)
        self.assertIn('acceleration_ks_p_value', metrics)
        self.assertIn('turn_rate_ks_stat', metrics)
        self.assertIn('turn_rate_ks_p_value', metrics)
        self.assertIn('mean_group_speed_diff', metrics)
        
        # 验证输出文件
        self.assertTrue(
            (self.test_output_dir / 'speed_distribution.png').exists()
        )
        self.assertTrue(
            (self.test_output_dir / 'acceleration_distribution.png').exists()
        )
        self.assertTrue(
            (self.test_output_dir / 'turn_rate_distribution.png').exists()
        )
        self.assertTrue(
            (self.test_output_dir / 'environment_interaction.png').exists()
        )
        self.assertTrue(
            (self.test_output_dir / 'evaluation_report.txt').exists()
        )
        
    def test_compare_speed_distributions(self):
        """测试速度分布比较"""
        self.evaluator.load_data(self.oord_file, self.synthetic_dir)
        metrics = self.evaluator._compare_speed_distributions()
        
        self.assertIn('speed_ks_stat', metrics)
        self.assertIn('speed_ks_p_value', metrics)
        self.assertIn('speed_mean_diff', metrics)
        self.assertIn('speed_std_diff', metrics)
        
    def test_compare_acceleration_distributions(self):
        """测试加速度分布比较"""
        self.evaluator.load_data(self.oord_file, self.synthetic_dir)
        metrics = self.evaluator._compare_acceleration_distributions()
        
        self.assertIn('acceleration_ks_stat', metrics)
        self.assertIn('acceleration_ks_p_value', metrics)
        self.assertIn('acceleration_mean_diff', metrics)
        self.assertIn('acceleration_std_diff', metrics)
        
    def test_compare_turn_rate_distributions(self):
        """测试转向率分布比较"""
        self.evaluator.load_data(self.oord_file, self.synthetic_dir)
        metrics = self.evaluator._compare_turn_rate_distributions()
        
        self.assertIn('turn_rate_ks_stat', metrics)
        self.assertIn('turn_rate_ks_p_value', metrics)
        self.assertIn('turn_rate_mean_diff', metrics)
        self.assertIn('turn_rate_std_diff', metrics)
        
    def test_compare_environment_interaction(self):
        """测试环境交互比较"""
        self.evaluator.load_data(self.oord_file, self.synthetic_dir)
        metrics = self.evaluator._compare_environment_interaction()
        
        self.assertIn('mean_group_speed_diff', metrics)
        self.assertIn('speed_diff_group_A', metrics)
        self.assertIn('speed_diff_group_B', metrics)
        
    def test_error_handling(self):
        """测试错误处理"""
        # 测试未加载数据时评估
        with self.assertRaises(ValueError):
            self.evaluator.evaluate()
            
        # 测试加载不存在的文件
        with self.assertRaises(FileNotFoundError):
            self.evaluator.load_data(
                Path('not_exist.csv'),
                self.synthetic_dir
            )
            
        # 测试加载空目录
        empty_dir = self.test_output_dir / 'empty'
        empty_dir.mkdir()
        with self.assertRaises(ValueError):
            self.evaluator.load_data(self.oord_file, empty_dir)
            
if __name__ == '__main__':
    unittest.main() 
```

### tests/core/test_point_selector.py
```python
"""
起终点选择器单元测试
"""

import unittest
import numpy as np
from unittest.mock import MagicMock

from src.core.terrain import TerrainLoader
from src.core.point_selector import PointSelector
from src.utils.config import config

class TestPointSelector(unittest.TestCase):
    """起终点选择器测试类"""
    
    def setUp(self):
        """测试前准备"""
        # 创建模拟的地形加载器
        self.terrain_loader = MagicMock(spec=TerrainLoader)
        
        # 设置DEM数据形状
        self.dem_shape = (100, 100)
        self.terrain_loader.dem_data = np.zeros(self.dem_shape)
        
        # 设置土地覆盖数据
        self.landcover_data = np.ones(self.dem_shape)
        self.terrain_loader.landcover_data = self.landcover_data
        
        # 设置坐标转换
        self.terrain_loader.pixel_to_coord.side_effect = lambda r, c: (float(c), float(r))
        
        # 设置可通行性检查
        self.terrain_loader.is_passable.return_value = True
        
        # 创建点选择器
        self.selector = PointSelector(
            terrain_loader=self.terrain_loader,
            min_distance=10.0,
            num_end_points=2,
            num_trajectories=4
        )
        
        # 设置城市地物编码
        config.terrain.URBAN_LANDCOVER_CODES = [1]
        
    def test_init(self):
        """测试初始化"""
        self.assertEqual(self.selector.min_distance, 10.0)
        self.assertEqual(self.selector.num_end_points, 2)
        self.assertEqual(self.selector.num_trajectories, 4)
        self.assertEqual(self.selector.starts_per_end, 2)
        
    def test_select_points(self):
        """测试起终点选择"""
        pairs = self.selector.select_points()
        
        # 验证返回的起终点对数量
        self.assertEqual(len(pairs), 4)
        
        # 验证每个起终点对的格式
        for start, end in pairs:
            self.assertIsInstance(start, tuple)
            self.assertIsInstance(end, tuple)
            self.assertEqual(len(start), 2)
            self.assertEqual(len(end), 2)
            
            # 验证起终点距离
            dx = end[0] - start[0]
            dy = end[1] - start[1]
            distance = np.sqrt(dx**2 + dy**2)
            self.assertGreaterEqual(distance, self.selector.min_distance)
            
    def test_select_points_no_urban(self):
        """测试无城市区域情况"""
        # 设置所有地物编码为非城市
        self.landcover_data.fill(0)
        
        # 验证是否抛出异常
        with self.assertRaises(RuntimeError):
            self.selector.select_points()
            
    def test_select_points_impassable(self):
        """测试不可通行情况"""
        # 设置所有点不可通行
        self.terrain_loader.is_passable.return_value = False
        
        # 验证是否抛出异常
        with self.assertRaises(RuntimeError):
            self.selector.select_points()
            
    def test_is_urban_area(self):
        """测试城市区域判断"""
        # 设置部分区域为城市
        self.landcover_data[50:60, 50:60] = 1
        
        # 验证城市区域判断
        self.assertTrue(self.selector._is_urban_area(55, 55))
        self.assertFalse(self.selector._is_urban_area(0, 0))
        
    def test_check_distance(self):
        """测试距离检查"""
        point1 = (0.0, 0.0)
        point2 = (8.0, 6.0)  # 距离为10
        
        self.assertTrue(self.selector._check_distance(point1, point2))
        
        point3 = (3.0, 4.0)  # 距离为5
        self.assertFalse(self.selector._check_distance(point1, point3))
        
    def test_is_too_close_to_points(self):
        """测试点间距检查"""
        points = [(0.0, 0.0), (10.0, 10.0)]
        
        # 测试太近的点
        point1 = (0.1, 0.1)  # 距离约0.14
        self.assertTrue(
            self.selector._is_too_close_to_points(point1, points)
        )
        
        # 测试足够远的点
        point2 = (5.0, 5.0)  # 距离约7.07
        self.assertFalse(
            self.selector._is_too_close_to_points(point2, points)
        )
        
if __name__ == '__main__':
    unittest.main() 
```

### tests/core/trajectory/test_environment_based.py
```python
"""
基于环境的轨迹生成器单元测试
"""

import unittest
import numpy as np
from unittest.mock import MagicMock

from src.core.terrain import TerrainLoader
from src.core.trajectory import EnvironmentBasedGenerator
from src.utils.config import config

class TestEnvironmentBasedGenerator(unittest.TestCase):
    """基于环境的轨迹生成器测试"""
    
    def setUp(self):
        """测试前准备"""
        # 创建模拟的地形加载器
        self.terrain_loader = MagicMock(spec=TerrainLoader)
        self.terrain_loader.get_terrain_attributes.return_value = {
            'slope': 5.0,
            'landcover': 2
        }
        self.terrain_loader.is_valid_pixel.return_value = True
        self.terrain_loader.is_passable.return_value = True
        self.terrain_loader.coord_to_pixel.return_value = (1, 1)
        
        # 创建轨迹生成器
        self.generator = EnvironmentBasedGenerator(
            terrain_loader=self.terrain_loader,
            dt=1.0,
            max_waypoints=5,
            min_waypoint_dist=10.0,
            max_waypoint_dist=50.0
        )
        
    def test_generate_waypoints(self):
        """测试路径点生成"""
        start_point = (0.0, 0.0)
        end_point = (100.0, 100.0)
        
        waypoints = self.generator._generate_waypoints(
            start_point,
            end_point
        )
        
        # 验证路径点数量
        self.assertGreaterEqual(len(waypoints), 2)  # 至少包含起点和终点
        self.assertLessEqual(len(waypoints), 7)     # 不超过max_waypoints+2
        
        # 验证起点和终点
        self.assertEqual(waypoints[0], start_point)
        self.assertEqual(waypoints[-1], end_point)
        
        # 验证中间点的间距
        for i in range(len(waypoints)-1):
            p1 = np.array(waypoints[i])
            p2 = np.array(waypoints[i+1])
            dist = np.sqrt(np.sum((p2 - p1)**2))
            self.assertGreaterEqual(dist, self.generator.min_waypoint_dist)
            self.assertLessEqual(dist, self.generator.max_waypoint_dist)
            
    def test_generate_trajectory(self):
        """测试轨迹生成"""
        start_point = (0.0, 0.0)
        end_point = (100.0, 100.0)
        
        trajectory = self.generator.generate_trajectory(
            start_point,
            end_point
        )
        
        # 验证轨迹数据格式
        self.assertIn('timestamp', trajectory)
        self.assertIn('x', trajectory)
        self.assertIn('y', trajectory)
        self.assertIn('speed', trajectory)
        self.assertIn('orientation', trajectory)
        
        # 验证数据长度一致
        length = len(trajectory['timestamp'])
        self.assertEqual(len(trajectory['x']), length)
        self.assertEqual(len(trajectory['y']), length)
        self.assertEqual(len(trajectory['speed']), length)
        self.assertEqual(len(trajectory['orientation']), length)
        
        # 验证起点和终点
        self.assertAlmostEqual(trajectory['x'][0], start_point[0])
        self.assertAlmostEqual(trajectory['y'][0], start_point[1])
        self.assertAlmostEqual(trajectory['x'][-1], end_point[0])
        self.assertAlmostEqual(trajectory['y'][-1], end_point[1])
        
        # 验证速度范围
        speeds = np.array(trajectory['speed'])
        self.assertTrue(np.all(speeds >= config.motion.MIN_SPEED))
        self.assertTrue(np.all(speeds <= config.motion.MAX_SPEED))
        
        # 验证朝向范围
        orientations = np.array(trajectory['orientation'])
        self.assertTrue(np.all(orientations >= 0))
        self.assertTrue(np.all(orientations < 360))
        
        # 验证时间戳递增
        timestamps = np.array(trajectory['timestamp'])
        self.assertTrue(np.all(np.diff(timestamps) > 0))
        
    def test_invalid_terrain(self):
        """测试无效地形情况"""
        # 模拟无效地形
        self.terrain_loader.is_valid_pixel.return_value = False
        
        start_point = (0.0, 0.0)
        end_point = (100.0, 100.0)
        
        # 验证是否仍能生成轨迹
        trajectory = self.generator.generate_trajectory(
            start_point,
            end_point
        )
        
        self.assertIsNotNone(trajectory)
        self.assertTrue(all(key in trajectory for key in [
            'timestamp', 'x', 'y', 'speed', 'orientation'
        ]))
        
    def test_impassable_terrain(self):
        """测试不可通行地形情况"""
        # 模拟部分地形不可通行
        self.terrain_loader.is_passable.side_effect = [
            True,   # 起点可通行
            False,  # 中间点不可通行
            True    # 终点可通行
        ]
        
        start_point = (0.0, 0.0)
        end_point = (100.0, 100.0)
        
        # 验证是否仍能生成轨迹
        trajectory = self.generator.generate_trajectory(
            start_point,
            end_point
        )
        
        self.assertIsNotNone(trajectory)
        self.assertTrue(all(key in trajectory for key in [
            'timestamp', 'x', 'y', 'speed', 'orientation'
        ]))
        
if __name__ == '__main__':
    unittest.main() 
```

### tests/core/trajectory/test_generator.py
```python
"""
轨迹生成器基类单元测试
"""

import unittest
import numpy as np
from typing import Dict, List, Tuple
from unittest.mock import MagicMock

from src.core.terrain import TerrainLoader
from src.core.trajectory import TrajectoryGenerator
from src.utils.config import config

class TestTrajectoryGenerator(TrajectoryGenerator):
    """用于测试的轨迹生成器实现"""
    
    def generate_trajectory(
            self,
            start_point: Tuple[float, float],
            end_point: Tuple[float, float]
        ) -> Dict[str, List[float]]:
        """测试用轨迹生成方法"""
        waypoints = [start_point, end_point]
        x, y = self._interpolate_path(waypoints)
        orientations = self._calculate_orientations(x, y)
        speeds = self._calculate_speeds(x, y)
        dx = np.diff(x)
        dy = np.diff(y)
        distances = np.sqrt(dx**2 + dy**2)
        timestamps = self._calculate_timestamps(distances, speeds)
        
        return {
            'timestamp': timestamps.tolist(),
            'x': x.tolist(),
            'y': y.tolist(),
            'speed': speeds.tolist(),
            'orientation': orientations.tolist()
        }

class TestTrajectoryGeneratorBase(unittest.TestCase):
    """轨迹生成器基类测试"""
    
    def setUp(self):
        """测试前准备"""
        # 创建模拟的地形加载器
        self.terrain_loader = MagicMock(spec=TerrainLoader)
        self.terrain_loader.get_terrain_attributes.return_value = {
            'slope': 5.0,
            'landcover': 2
        }
        self.terrain_loader.is_valid_pixel.return_value = True
        self.terrain_loader.coord_to_pixel.return_value = (1, 1)
        
        # 创建测试用生成器
        self.generator = TestTrajectoryGenerator(
            self.terrain_loader,
            dt=1.0
        )
        
    def test_interpolate_path(self):
        """测试路径插值"""
        waypoints = [
            (0.0, 0.0),
            (100.0, 100.0)
        ]
        
        x, y = self.generator._interpolate_path(waypoints, num_points=5)
        
        self.assertEqual(len(x), 5)
        self.assertEqual(len(y), 5)
        self.assertEqual(x[0], 0.0)
        self.assertEqual(y[0], 0.0)
        self.assertEqual(x[-1], 100.0)
        self.assertEqual(y[-1], 100.0)
        
    def test_calculate_orientations(self):
        """测试朝向计算"""
        x = np.array([0.0, 100.0, 100.0])
        y = np.array([0.0, 100.0, 200.0])
        
        orientations = self.generator._calculate_orientations(x, y)
        
        self.assertEqual(len(orientations), 3)
        self.assertTrue(np.all(orientations >= 0))
        self.assertTrue(np.all(orientations < 360))
        
    def test_calculate_speeds(self):
        """测试速度计算"""
        x = np.array([0.0, 100.0, 200.0])
        y = np.array([0.0, 100.0, 200.0])
        
        # 测试不考虑地形影响
        speeds = self.generator._calculate_speeds(x, y, terrain_influence=False)
        
        self.assertEqual(len(speeds), 3)
        self.assertTrue(np.all(speeds >= config.motion.MIN_SPEED))
        self.assertTrue(np.all(speeds <= config.motion.MAX_SPEED))
        
        # 测试考虑地形影响
        speeds = self.generator._calculate_speeds(x, y, terrain_influence=True)
        
        self.assertEqual(len(speeds), 3)
        self.assertTrue(np.all(speeds >= config.motion.MIN_SPEED))
        self.assertTrue(np.all(speeds <= config.motion.MAX_SPEED))
        
    def test_calculate_timestamps(self):
        """测试时间戳计算"""
        distances = np.array([100.0, 100.0])
        speeds = np.array([10.0, 10.0, 10.0])
        
        timestamps = self.generator._calculate_timestamps(distances, speeds)
        
        self.assertEqual(len(timestamps), 3)
        self.assertEqual(timestamps[0], 0.0)
        self.assertEqual(timestamps[1], 10.0)
        self.assertEqual(timestamps[2], 20.0)
        
    def test_generate_trajectory(self):
        """测试轨迹生成"""
        start_point = (0.0, 0.0)
        end_point = (100.0, 100.0)
        
        trajectory = self.generator.generate_trajectory(
            start_point,
            end_point
        )
        
        self.assertIn('timestamp', trajectory)
        self.assertIn('x', trajectory)
        self.assertIn('y', trajectory)
        self.assertIn('speed', trajectory)
        self.assertIn('orientation', trajectory)
        
        self.assertEqual(len(trajectory['timestamp']),
                        len(trajectory['x']))
        self.assertEqual(len(trajectory['x']),
                        len(trajectory['y']))
        self.assertEqual(len(trajectory['y']),
                        len(trajectory['speed']))
        self.assertEqual(len(trajectory['speed']),
                        len(trajectory['orientation']))
        
if __name__ == '__main__':
    unittest.main() 
```

### tests/data_processing/test_oord_processor.py
```python
"""
OORD数据处理器测试模块
"""

import os
import sys
from pathlib import Path
import pytest
import numpy as np
import pandas as pd
import rasterio.transform

# 添加项目根目录到Python路径
PROJECT_ROOT = Path(__file__).parent.parent.parent.absolute()
sys.path.append(str(PROJECT_ROOT))

from src.data_processing import TerrainLoader, TerrainAnalyzer, OORDProcessor

@pytest.fixture
def terrain_loader():
    """创建测试用TerrainLoader实例"""
    loader = TerrainLoader()
    # 创建简单的测试数据
    dem_data = np.array([
        [100, 110, 120],
        [110, 120, 130],
        [120, 130, 140]
    ], dtype=np.float32)
    landcover_data = np.array([
        [1, 1, 2],
        [1, 2, 2],
        [2, 2, 3]
    ], dtype=np.int32)
    
    # 设置地理变换矩阵
    # 使用北京附近区域作为测试区域 (116.0E, 39.0N)
    resolution = 30  # 30米分辨率
    transform = rasterio.transform.from_origin(
        west=116.0,     # 左边界经度
        north=39.0,     # 上边界纬度
        xsize=resolution,  # 经度方向分辨率
        ysize=resolution   # 纬度方向分辨率
    )
    
    loader.dem_data = dem_data
    loader.landcover_data = landcover_data
    loader.resolution = resolution
    loader.transform = transform
    return loader

@pytest.fixture
def test_trajectory_data(tmp_path):
    """创建测试用轨迹数据"""
    # 创建测试数据
    data = {
        'timestamp_ms': np.arange(0, 5000, 1000),  # 5个点，每秒一个
        'latitude': [39.0, 39.001, 39.002, 39.003, 39.004],
        'longitude': [116.0, 116.001, 116.002, 116.003, 116.004],
        'altitude_m': [100, 110, 120, 130, 140],
        'velocity_north_ms': [1.0, 1.5, 2.0, 1.5, 1.0],
        'velocity_east_ms': [0.5, 1.0, 1.5, 1.0, 0.5],
        'velocity_down_ms': [0.0, 0.1, 0.2, 0.1, 0.0],
        'acceleration_x_ms2': [0.1, 0.2, 0.1, 0.0, -0.1],
        'acceleration_y_ms2': [0.1, 0.1, 0.0, -0.1, -0.1],
        'acceleration_z_ms2': [0.0, 0.1, 0.0, -0.1, 0.0],
        'angular_velocity_x_rads': [0.01, 0.02, 0.01, 0.0, -0.01],
        'angular_velocity_y_rads': [0.01, 0.01, 0.0, -0.01, -0.01],
        'angular_velocity_z_rads': [0.1, 0.2, 0.1, 0.0, -0.1]
    }
    df = pd.DataFrame(data)
    
    # 保存到临时文件
    test_file = tmp_path / "test_trajectory.csv"
    df.to_csv(test_file, index=False)
    return test_file

def test_oord_processor_init(terrain_loader):
    """测试OORDProcessor初始化"""
    processor = OORDProcessor(terrain_loader)
    assert processor.terrain_loader is terrain_loader
    assert isinstance(processor.trajectories, dict)
    assert isinstance(processor.processed_trajectories, dict)
    assert len(processor.trajectories) == 0
    assert len(processor.processed_trajectories) == 0

def test_load_trajectory(terrain_loader, test_trajectory_data):
    """测试轨迹加载功能"""
    processor = OORDProcessor(terrain_loader)
    df = processor.load_trajectory(test_trajectory_data)
    
    # 验证基本数据结构
    assert isinstance(df, pd.DataFrame)
    assert len(df) == 5  # 测试数据有5个点
    
    # 验证计算的特征
    assert 'speed' in df.columns
    assert 'heading' in df.columns
    assert 'turn_rate' in df.columns
    assert 'acceleration' in df.columns
    
    # 验证速度计算
    expected_speed = np.sqrt(df['velocity_north_ms']**2 + df['velocity_east_ms']**2)
    np.testing.assert_array_almost_equal(df['speed'], expected_speed)
    
    # 验证加速度计算
    expected_accel = np.sqrt(
        df['acceleration_x_ms2']**2 + 
        df['acceleration_y_ms2']**2 + 
        df['acceleration_z_ms2']**2
    )
    np.testing.assert_array_almost_equal(df['acceleration'], expected_accel)
    
    # 验证航向角计算
    expected_heading = np.degrees(np.arctan2(
        df['velocity_east_ms'],
        df['velocity_north_ms']
    )) % 360
    np.testing.assert_array_almost_equal(df['heading'], expected_heading)

def test_process_trajectory(terrain_loader, test_trajectory_data):
    """测试轨迹处理功能"""
    processor = OORDProcessor(terrain_loader)
    processor.load_trajectory(test_trajectory_data)
    trajectory_id = Path(test_trajectory_data).stem
    
    df_processed = processor.process_trajectory(
        trajectory_id,
        max_speed=50.0
    )
    
    # 验证基本处理结果
    assert isinstance(df_processed, pd.DataFrame)
    assert len(df_processed) > 0
    assert all(df_processed['speed'] <= 50.0)
    
    # 验证环境分组
    assert 'slope_group' in df_processed.columns
    assert 'group_label' in df_processed.columns
    assert df_processed['slope_group'].notna().all()
    assert df_processed['group_label'].notna().all()

def test_analyze_environment_interaction(terrain_loader, test_trajectory_data):
    """测试环境交互分析功能"""
    processor = OORDProcessor(terrain_loader)
    processor.load_trajectory(test_trajectory_data)
    trajectory_id = Path(test_trajectory_data).stem
    processor.process_trajectory(trajectory_id)
    
    stats = processor.analyze_environment_interaction()
    
    # 验证统计结果
    assert isinstance(stats, dict)
    assert len(stats) > 0
    
    # 验证统计指标
    for group_stats in stats.values():
        required_stats = [
            'speed_mean', 'speed_std', 'speed_median', 'speed_max',
            'acceleration_std', 'turn_rate_std', 'sample_size'
        ]
        for stat in required_stats:
            assert stat in group_stats
            assert isinstance(group_stats[stat], (int, float))
            assert not np.isnan(group_stats[stat])

def test_calculate_haversine_distance():
    """测试Haversine距离计算"""
    # 使用北京天安门（116.397, 39.916）和上海外滩（121.484, 31.233）的坐标
    lon1, lat1 = 116.397, 39.916  # 北京天安门
    lon2, lat2 = 121.484, 31.233  # 上海外滩
    
    # 计算两点之间的距离
    processor = OORDProcessor()  # 不需要地形数据
    distance = processor.calculate_haversine_distance(
        lon1=lon1, lat1=lat1,
        lon2=lon2, lat2=lat2
    )
    
    # 预期距离约为1067公里
    expected_distance = 1067.0  # 单位：公里
    assert abs(distance - expected_distance) < 5.0  # 允许5公里的误差

def test_calculate_heading():
    """测试航向角计算"""
    processor = OORDProcessor()  # 不需要地形数据
    
    # 测试正北方向
    heading = processor.calculate_heading(
        velocity_north=1.0,
        velocity_east=0.0
    )
    assert abs(heading - 0.0) < 1e-6
    
    # 测试正东方向
    heading = processor.calculate_heading(
        velocity_north=0.0,
        velocity_east=1.0
    )
    assert abs(heading - 90.0) < 1e-6
    
    # 测试正南方向
    heading = processor.calculate_heading(
        velocity_north=-1.0,
        velocity_east=0.0
    )
    assert abs(heading - 180.0) < 1e-6
    
    # 测试正西方向
    heading = processor.calculate_heading(
        velocity_north=0.0,
        velocity_east=-1.0
    )
    assert abs(heading - 270.0) < 1e-6
    
    # 测试东北方向（45度）
    heading = processor.calculate_heading(
        velocity_north=1.0,
        velocity_east=1.0
    )
    assert abs(heading - 45.0) < 1e-6 
```

### tests/data_processing/test_terrain_analyzer.py
```python
"""
TerrainAnalyzer模块的单元测试
"""

import pytest
import numpy as np
import rasterio
from pathlib import Path

from src.data_processing import TerrainAnalyzer

def test_terrain_analyzer_init():
    """测试TerrainAnalyzer的初始化"""
    analyzer = TerrainAnalyzer()
    assert analyzer.dem_data is None
    assert analyzer.slope_magnitude is None
    assert analyzer.slope_aspect is None
    assert analyzer.dzdx is None
    assert analyzer.dzdy is None
    assert analyzer.resolution is None

def test_load_dem(test_dem_data):
    """测试DEM数据加载功能"""
    analyzer = TerrainAnalyzer()
    resolution = (30.0, 30.0)  # 30米分辨率
    analyzer.load_dem(test_dem_data, resolution)
    
    assert analyzer.dem_data is not None
    assert np.array_equal(analyzer.dem_data, test_dem_data)
    assert analyzer.resolution == resolution

def test_calculate_slope_magnitude(test_dem_data):
    """测试坡度大小计算功能"""
    analyzer = TerrainAnalyzer()
    resolution = (30.0, 30.0)
    analyzer.load_dem(test_dem_data, resolution)
    
    slope_magnitude = analyzer.calculate_slope_magnitude()
    
    assert slope_magnitude is not None
    assert slope_magnitude.shape == test_dem_data.shape
    assert np.all(slope_magnitude >= 0)  # 坡度应该非负
    assert analyzer.slope_magnitude is not None
    
    # 检查平地和陡坡
    flat_mask = test_dem_data == test_dem_data[0, 0]  # 找出高度相同的点
    assert np.all(slope_magnitude[flat_mask] < 0.1)  # 平地坡度应接近0

def test_calculate_slope_aspect(test_dem_data):
    """测试坡向计算功能"""
    analyzer = TerrainAnalyzer()
    resolution = (30.0, 30.0)
    analyzer.load_dem(test_dem_data, resolution)
    
    slope_aspect = analyzer.calculate_slope_aspect()
    
    assert slope_aspect is not None
    assert slope_aspect.shape == test_dem_data.shape
    assert analyzer.slope_aspect is not None
    
    # 检查坡向范围
    valid_mask = slope_aspect != -1
    if np.any(valid_mask):
        assert np.all((slope_aspect[valid_mask] >= 0) & (slope_aspect[valid_mask] < 360))
    
    # 检查平地的坡向
    if analyzer.slope_magnitude is not None:
        flat_mask = analyzer.slope_magnitude < 0.1
        assert np.all(slope_aspect[flat_mask] == -1)

def test_calculate_gradients(test_dem_data):
    """测试梯度计算功能"""
    analyzer = TerrainAnalyzer()
    resolution = (30.0, 30.0)
    analyzer.load_dem(test_dem_data, resolution)
    
    dzdx, dzdy = analyzer.calculate_gradients()
    
    assert dzdx is not None
    assert dzdy is not None
    assert dzdx.shape == test_dem_data.shape
    assert dzdy.shape == test_dem_data.shape
    assert analyzer.dzdx is not None
    assert analyzer.dzdy is not None
    
    # 检查平地的梯度
    flat_mask = test_dem_data == test_dem_data[0, 0]
    assert np.all(np.abs(dzdx[flat_mask]) < 1e-6)
    assert np.all(np.abs(dzdy[flat_mask]) < 1e-6)

def test_save_results(test_dem_data, tmp_path):
    """测试结果保存功能"""
    analyzer = TerrainAnalyzer()
    resolution = (30.0, 30.0)
    analyzer.load_dem(test_dem_data, resolution)
    
    # 计算所有地形属性
    analyzer.calculate_slope_magnitude()
    analyzer.calculate_slope_aspect()
    analyzer.calculate_gradients()
    
    # 保存结果
    output_dir = tmp_path / "terrain_results"
    analyzer.save_results(output_dir)
    
    # 验证文件是否创建
    assert (output_dir / "slope_magnitude_30m_100km.tif").exists()
    assert (output_dir / "slope_aspect_30m_100km.tif").exists()
    assert (output_dir / "dzdx_30m_100km.tif").exists()
    assert (output_dir / "dzdy_30m_100km.tif").exists()
    
    # 验证保存的数据是否正确
    with rasterio.open(output_dir / "slope_magnitude_30m_100km.tif") as src:
        saved_slope = src.read(1)
        assert np.array_equal(saved_slope, analyzer.slope_magnitude)

def test_error_handling():
    """测试错误处理"""
    analyzer = TerrainAnalyzer()
    
    # 测试在未加载数据时的错误处理
    with pytest.raises(ValueError):
        analyzer.calculate_slope_magnitude()
    
    with pytest.raises(ValueError):
        analyzer.calculate_slope_aspect()
    
    with pytest.raises(ValueError):
        analyzer.calculate_gradients() 
```

### tests/data_processing/test_terrain_loader.py
```python
"""
TerrainLoader模块的单元测试
"""

import pytest
import numpy as np
import rasterio
from pathlib import Path

from src.data_processing import TerrainLoader

def test_terrain_loader_init():
    """测试TerrainLoader的初始化"""
    loader = TerrainLoader()
    assert loader.dem_data is None
    assert loader.landcover_data is None
    assert loader.transform is None
    assert loader.crs is None
    assert loader.resolution is None
    assert loader.bounds is None

def test_load_dem(test_dem_data, tmp_path):
    """测试DEM数据加载功能"""
    # 准备测试数据
    dem_path = tmp_path / "test_dem.tif"
    with rasterio.open(
        dem_path,
        'w',
        driver='GTiff',
        height=test_dem_data.shape[0],
        width=test_dem_data.shape[1],
        count=1,
        dtype=test_dem_data.dtype,
        crs='+proj=latlong',
        transform=rasterio.transform.from_bounds(
            116.0, 39.0, 116.1, 39.1,
            test_dem_data.shape[1], test_dem_data.shape[0]
        )
    ) as dst:
        dst.write(test_dem_data, 1)
    
    # 测试加载功能
    loader = TerrainLoader()
    dem_array = loader.load_dem(dem_path)
    
    assert dem_array is not None
    assert dem_array.shape == test_dem_data.shape
    assert np.allclose(dem_array, test_dem_data)
    assert loader.transform is not None
    assert loader.crs is not None
    assert loader.resolution is not None
    assert loader.bounds is not None

def test_load_landcover(test_dem_data, test_landcover_data, tmp_path):
    """测试土地覆盖数据加载功能"""
    # 准备DEM测试数据
    dem_path = tmp_path / "test_dem.tif"
    landcover_path = tmp_path / "test_landcover.tif"
    transform = rasterio.transform.from_bounds(
        116.0, 39.0, 116.1, 39.1,
        test_dem_data.shape[1], test_dem_data.shape[0]
    )
    
    # 保存DEM数据
    with rasterio.open(
        dem_path,
        'w',
        driver='GTiff',
        height=test_dem_data.shape[0],
        width=test_dem_data.shape[1],
        count=1,
        dtype=test_dem_data.dtype,
        crs='+proj=latlong',
        transform=transform
    ) as dst:
        dst.write(test_dem_data, 1)
    
    # 保存土地覆盖数据
    with rasterio.open(
        landcover_path,
        'w',
        driver='GTiff',
        height=test_landcover_data.shape[0],
        width=test_landcover_data.shape[1],
        count=1,
        dtype=test_landcover_data.dtype,
        crs='+proj=latlong',
        transform=transform
    ) as dst:
        dst.write(test_landcover_data, 1)
    
    # 测试加载功能
    loader = TerrainLoader()
    loader.load_dem(dem_path)
    landcover_array = loader.load_landcover(landcover_path)
    
    assert landcover_array is not None
    assert landcover_array.shape == test_landcover_data.shape
    assert np.array_equal(landcover_array, test_landcover_data)

def test_coordinate_conversion(tmp_path, test_dem_data):
    """测试坐标转换功能"""
    # 准备测试数据
    dem_path = tmp_path / "test_dem.tif"
    transform = rasterio.transform.from_bounds(
        116.0, 39.0, 116.1, 39.1,
        test_dem_data.shape[1], test_dem_data.shape[0]
    )
    
    with rasterio.open(
        dem_path,
        'w',
        driver='GTiff',
        height=test_dem_data.shape[0],
        width=test_dem_data.shape[1],
        count=1,
        dtype=test_dem_data.dtype,
        crs='+proj=latlong',
        transform=transform
    ) as dst:
        dst.write(test_dem_data, 1)
    
    # 测试坐标转换
    loader = TerrainLoader()
    loader.load_dem(dem_path)
    
    # 测试经纬度到像素坐标的转换
    row, col = loader.get_pixel_coords(116.05, 39.05)
    assert isinstance(row, int)
    assert isinstance(col, int)
    assert 0 <= row < test_dem_data.shape[0]
    assert 0 <= col < test_dem_data.shape[1]
    
    # 测试像素坐标到经纬度的转换
    lon, lat = loader.get_geo_coords(row, col)
    assert isinstance(lon, float)
    assert isinstance(lat, float)
    assert 116.0 <= lon <= 116.1
    assert 39.0 <= lat <= 39.1

def test_get_elevation_and_landcover(tmp_path, test_dem_data, test_landcover_data):
    """测试获取高程和土地覆盖类型功能"""
    # 准备测试数据
    dem_path = tmp_path / "test_dem.tif"
    landcover_path = tmp_path / "test_landcover.tif"
    transform = rasterio.transform.from_bounds(
        116.0, 39.0, 116.1, 39.1,
        test_dem_data.shape[1], test_dem_data.shape[0]
    )
    
    # 保存DEM数据
    with rasterio.open(
        dem_path,
        'w',
        driver='GTiff',
        height=test_dem_data.shape[0],
        width=test_dem_data.shape[1],
        count=1,
        dtype=test_dem_data.dtype,
        crs='+proj=latlong',
        transform=transform
    ) as dst:
        dst.write(test_dem_data, 1)
    
    # 保存土地覆盖数据
    with rasterio.open(
        landcover_path,
        'w',
        driver='GTiff',
        height=test_landcover_data.shape[0],
        width=test_landcover_data.shape[1],
        count=1,
        dtype=test_landcover_data.dtype,
        crs='+proj=latlong',
        transform=transform
    ) as dst:
        dst.write(test_landcover_data, 1)
    
    # 测试获取高程和土地覆盖类型
    loader = TerrainLoader()
    loader.load_dem(dem_path)
    loader.load_landcover(landcover_path)
    
    # 测试中心点的值
    center_lon = 116.05
    center_lat = 39.05
    
    elevation = loader.get_elevation(center_lon, center_lat)
    assert isinstance(elevation, float)
    assert 100 <= elevation <= 140
    
    landcover = loader.get_landcover(center_lon, center_lat)
    assert isinstance(landcover, int)
    assert 1 <= landcover <= 5

def test_error_handling():
    """测试错误处理"""
    loader = TerrainLoader()
    
    # 测试在未加载数据时的错误处理
    with pytest.raises(ValueError):
        loader.get_pixel_coords(116.0, 39.0)
    
    with pytest.raises(ValueError):
        loader.get_geo_coords(0, 0)
    
    with pytest.raises(ValueError):
        loader.get_elevation(116.0, 39.0)
    
    with pytest.raises(ValueError):
        loader.get_landcover(116.0, 39.0) 
```

### tests/trajectory_generation/test_environment_based_generator.py
```python
"""
基于环境的轨迹生成器测试模块
"""

import os
import sys
from pathlib import Path
import pytest
import numpy as np
import pandas as pd
import rasterio.transform

# 添加项目根目录到Python路径
PROJECT_ROOT = Path(__file__).parent.parent.parent.absolute()
sys.path.append(str(PROJECT_ROOT))

from src.data_processing import TerrainLoader
from src.trajectory_generation import EnvironmentBasedGenerator

@pytest.fixture
def terrain_loader():
    """创建测试用TerrainLoader实例"""
    loader = TerrainLoader()
    # 创建简单的测试数据
    dem_data = np.array([
        [100, 110, 120],
        [110, 120, 130],
        [120, 130, 140]
    ], dtype=np.float32)
    landcover_data = np.array([
        [1, 1, 2],
        [1, 2, 2],
        [2, 2, 3]
    ], dtype=np.int32)
    
    # 设置地理变换矩阵
    # 使用北京附近区域作为测试区域 (116.0E, 39.0N)
    resolution = 30  # 30米分辨率
    transform = rasterio.transform.from_origin(
        west=116.0,     # 左边界经度
        north=39.0,     # 上边界纬度
        xsize=resolution,  # 经度方向分辨率
        ysize=resolution   # 纬度方向分辨率
    )
    
    loader.dem_data = dem_data
    loader.landcover_data = landcover_data
    loader.resolution = resolution
    loader.transform = transform
    return loader

def test_environment_based_generator_init(terrain_loader):
    """测试基于环境的轨迹生成器初始化"""
    generator = EnvironmentBasedGenerator(terrain_loader)
    
    # 验证基本属性
    assert generator.terrain_loader is terrain_loader
    assert generator.terrain_analyzer is not None
    assert generator.terrain_analyzer.dem_data is not None
    assert generator.terrain_analyzer.slope_magnitude is not None
    assert generator.terrain_analyzer.slope_aspect is not None
    
    # 验证参数设置
    assert 'min_speed' in generator.params
    assert 'max_speed' in generator.params
    assert 'max_acceleration' in generator.params
    assert 'max_turn_rate' in generator.params
    assert 'time_step' in generator.params
    
    # 验证环境参数
    assert 'slope_speed_factors' in generator.env_params
    assert 'landcover_speed_factors' in generator.env_params
    assert 'path_smoothness' in generator.env_params
    assert 'waypoint_spacing' in generator.env_params

def test_generate_trajectory(terrain_loader):
    """测试轨迹生成功能"""
    generator = EnvironmentBasedGenerator(terrain_loader)
    
    # 设置测试起终点（在测试区域内）
    start_point = (116.001, 39.001)  # 起点
    end_point = (116.002, 39.002)    # 终点
    
    # 生成轨迹
    trajectory = generator.generate_trajectory(start_point, end_point)
    
    # 验证基本数据结构
    assert isinstance(trajectory, pd.DataFrame)
    assert len(trajectory) > 0
    
    # 验证必要的列存在
    required_columns = [
        'timestamp_ms',
        'longitude', 'latitude', 'altitude_m',
        'velocity_north_ms', 'velocity_east_ms', 'velocity_down_ms',
        'acceleration_x_ms2', 'acceleration_y_ms2', 'acceleration_z_ms2',
        'angular_velocity_x_rads', 'angular_velocity_y_rads', 'angular_velocity_z_rads'
    ]
    for col in required_columns:
        assert col in trajectory.columns
    
    # 验证时间戳递增
    assert (np.diff(trajectory['timestamp_ms']) > 0).all()
    
    # 验证位置在合理范围内
    assert trajectory['longitude'].between(116.0, 116.1).all()
    assert trajectory['latitude'].between(39.0, 39.1).all()
    
    # 验证速度约束
    speed = np.sqrt(
        trajectory['velocity_north_ms']**2 + 
        trajectory['velocity_east_ms']**2
    )
    assert speed.between(
        generator.params['min_speed'],
        generator.params['max_speed']
    ).all()
    
    # 验证加速度约束
    acceleration = np.sqrt(
        trajectory['acceleration_x_ms2']**2 + 
        trajectory['acceleration_y_ms2']**2 + 
        trajectory['acceleration_z_ms2']**2
    )
    assert (acceleration <= generator.params['max_acceleration']).all()
    
    # 验证转向率约束
    turn_rate = np.sqrt(
        trajectory['angular_velocity_x_rads']**2 + 
        trajectory['angular_velocity_y_rads']**2 + 
        trajectory['angular_velocity_z_rads']**2
    )
    assert (turn_rate <= np.radians(generator.params['max_turn_rate'])).all()

def test_validate_trajectory(terrain_loader):
    """测试轨迹验证功能"""
    generator = EnvironmentBasedGenerator(terrain_loader)
    
    # 创建有效轨迹数据
    data = {
        'timestamp_ms': np.arange(0, 5000, 1000),
        'longitude': [116.001, 116.002, 116.003, 116.004, 116.005],
        'latitude': [39.001, 39.002, 39.003, 39.004, 39.005],
        'altitude_m': [100, 110, 120, 130, 140],
        'velocity_north_ms': [1.0, 1.5, 2.0, 1.5, 1.0],
        'velocity_east_ms': [0.5, 1.0, 1.5, 1.0, 0.5],
        'velocity_down_ms': [0.0, 0.1, 0.2, 0.1, 0.0],
        'acceleration_x_ms2': [0.1, 0.2, 0.1, 0.0, -0.1],
        'acceleration_y_ms2': [0.1, 0.1, 0.0, -0.1, -0.1],
        'acceleration_z_ms2': [0.0, 0.1, 0.0, -0.1, 0.0],
        'angular_velocity_x_rads': [0.01, 0.02, 0.01, 0.0, -0.01],
        'angular_velocity_y_rads': [0.01, 0.01, 0.0, -0.01, -0.01],
        'angular_velocity_z_rads': [0.1, 0.2, 0.1, 0.0, -0.1]
    }
    valid_trajectory = pd.DataFrame(data)
    
    # 验证有效轨迹
    assert generator.validate_trajectory(valid_trajectory)
    
    # 创建无效轨迹（速度过大）
    invalid_trajectory = valid_trajectory.copy()
    invalid_trajectory['velocity_north_ms'] *= 100
    assert not generator.validate_trajectory(invalid_trajectory)
    
    # 创建无效轨迹（加速度过大）
    invalid_trajectory = valid_trajectory.copy()
    invalid_trajectory['acceleration_x_ms2'] *= 100
    assert not generator.validate_trajectory(invalid_trajectory)
    
    # 创建无效轨迹（转向率过大）
    invalid_trajectory = valid_trajectory.copy()
    invalid_trajectory['angular_velocity_z_rads'] *= 100
    assert not generator.validate_trajectory(invalid_trajectory)

def test_invalid_points(terrain_loader):
    """测试无效点处理"""
    generator = EnvironmentBasedGenerator(terrain_loader)
    
    # 测试超出范围的点
    invalid_point = (150.0, 60.0)  # 超出中国范围
    assert not generator._validate_point(*invalid_point)
    
    # 测试超出地形数据范围的点
    invalid_point = (117.0, 40.0)  # 超出测试数据范围
    assert not generator._validate_point(*invalid_point)
    
    # 测试有效点
    valid_point = (116.001, 39.001)
    assert generator._validate_point(*valid_point)

def test_update_params(terrain_loader):
    """测试参数更新功能"""
    generator = EnvironmentBasedGenerator(terrain_loader)
    
    # 保存原始参数
    original_params = generator.params.copy()
    
    # 更新部分参数
    new_params = {
        'max_speed': 30.0,
        'max_acceleration': 3.0
    }
    generator.update_params(new_params)
    
    # 验证参数更新
    assert generator.params['max_speed'] == new_params['max_speed']
    assert generator.params['max_acceleration'] == new_params['max_acceleration']
    
    # 验证其他参数保持不变
    for key in original_params:
        if key not in new_params:
            assert generator.params[key] == original_params[key] 
```

### tests/unit/__init__.py
```python

```

### tests/unit/test_data_loader.py
```python
"""
数据加载器模块的单元测试
"""

import os
import unittest
from pathlib import Path

import numpy as np
import pytest
from rasterio.errors import RasterioIOError

from src.data_processing.data_loader import GISDataLoader

class TestGISDataLoader(unittest.TestCase):
    """测试GIS数据加载器类"""
    
    def setUp(self):
        """测试前的准备工作"""
        self.loader = GISDataLoader()
        self.test_data_dir = Path(__file__).parent.parent / "test_data"
        os.makedirs(self.test_data_dir, exist_ok=True)
    
    def test_load_dem_file_not_found(self):
        """测试加载不存在的DEM文件时的错误处理"""
        with pytest.raises(RasterioIOError):
            self.loader.load_dem(self.test_data_dir / "not_exists.tif")
    
    def test_get_pixel_coords_without_transform(self):
        """测试在未加载数据时获取像素坐标的错误处理"""
        with pytest.raises(ValueError, match="未加载GIS数据"):
            self.loader.get_pixel_coords(116.0, 40.0)
    
    def test_get_elevation_without_data(self):
        """测试在未加载DEM数据时获取高程值的错误处理"""
        with pytest.raises(ValueError, match="未加载DEM数据"):
            self.loader.get_elevation(0, 0)
    
    def test_get_slope_without_data(self):
        """测试在未加载坡度数据时获取坡度值的错误处理"""
        with pytest.raises(ValueError, match="未加载坡度数据"):
            self.loader.get_slope(0, 0)
    
    def test_get_landcover_without_data(self):
        """测试在未加载土地覆盖数据时获取土地覆盖类型的错误处理"""
        with pytest.raises(ValueError, match="未加载土地覆盖数据"):
            self.loader.get_landcover(0, 0)

if __name__ == '__main__':
    unittest.main() 
```

### tests/unit/test_environment_analyzer.py
```python
"""
环境分析器模块的单元测试
"""

import unittest
from datetime import datetime, timedelta
from pathlib import Path
from unittest.mock import MagicMock, patch

import numpy as np
import pandas as pd
import pytest

from src.analysis.environment_analyzer import EnvironmentAnalyzer
from src.data_processing import GISDataLoader

class TestEnvironmentAnalyzer(unittest.TestCase):
    """测试环境分析器类"""
    
    def setUp(self):
        """测试前的准备工作"""
        # 创建GISDataLoader的Mock对象
        self.mock_gis_loader = MagicMock(spec=GISDataLoader)
        
        # 设置mock返回值
        self.mock_gis_loader.get_pixel_coords.return_value = (100, 100)
        self.mock_gis_loader.get_elevation.return_value = 100.0
        self.mock_gis_loader.get_slope.return_value = 10.0
        self.mock_gis_loader.get_landcover.return_value = 1
        
        # 创建分析器实例
        self.analyzer = EnvironmentAnalyzer(self.mock_gis_loader)
        
        # 创建测试用的轨迹数据
        self.test_trajectory = self.create_test_trajectory()
    
    def create_test_trajectory(self) -> pd.DataFrame:
        """创建用于测试的轨迹数据"""
        timestamps = [
            datetime(2024, 1, 1, 12, 0) + timedelta(seconds=i)
            for i in range(10)
        ]
        
        data = {
            'timestamp': timestamps,
            'longitude': [116.0 + i*0.001 for i in range(10)],
            'latitude': [40.0 + i*0.001 for i in range(10)],
            'speed': [10.0 + i for i in range(10)],
            'heading': [45.0 for _ in range(10)],
            'turn_rate': [0.0 for _ in range(10)],
            'acceleration': [1.0 for _ in range(10)]
        }
        
        return pd.DataFrame(data)
    
    def test_analyze_trajectory(self):
        """测试单条轨迹的环境分析"""
        enriched_df = self.analyzer.analyze_trajectory(self.test_trajectory)
        
        # 验证是否添加了所有环境特征列
        self.assertTrue('elevation' in enriched_df.columns)
        self.assertTrue('slope' in enriched_df.columns)
        self.assertTrue('landcover' in enriched_df.columns)
        self.assertTrue('slope_class' in enriched_df.columns)
        self.assertTrue('environment_group' in enriched_df.columns)
        
        # 验证环境组标签格式
        self.assertTrue(all(enriched_df['environment_group'].str.match(r'LC\d+_SS\d+')))
    
    def test_compute_environment_statistics(self):
        """测试环境统计计算"""
        # 创建测试数据
        enriched_trajectories = {
            'test_traj': self.test_trajectory.assign(
                elevation=100.0,
                slope=10.0,
                landcover=1,
                slope_class='S1',
                environment_group='LC1_SS1'
            )
        }
        
        stats = self.analyzer.compute_environment_statistics(enriched_trajectories)
        
        # 验证统计结果
        self.assertTrue('LC1_SS1' in stats)
        group_stats = stats['LC1_SS1']
        
        # 验证统计量的完整性
        self.assertTrue('speed' in group_stats)
        self.assertTrue('turn_rate' in group_stats)
        self.assertTrue('acceleration' in group_stats)
        self.assertTrue('sample_size' in group_stats)
        
        # 验证速度统计量
        speed_stats = group_stats['speed']
        self.assertTrue(all(key in speed_stats for key in 
                          ['mean', 'std', 'median', 'q25', 'q75', 'max', 'min']))
    
    def test_fit_speed_models(self):
        """测试速度分布模型拟合"""
        # 创建测试数据
        enriched_trajectories = {
            'test_traj': self.test_trajectory.assign(
                elevation=100.0,
                slope=10.0,
                landcover=1,
                slope_class='S1',
                environment_group='LC1_SS1'
            )
        }
        
        models = self.analyzer.fit_speed_models(enriched_trajectories, min_samples=5)
        
        # 验证模型结果
        self.assertTrue('LC1_SS1' in models)
        model = models['LC1_SS1']
        
        # 验证模型参数的完整性
        self.assertTrue('distribution' in model)
        self.assertTrue('parameters' in model)
        self.assertTrue('ks_statistic' in model)
    
    def test_sample_speed(self):
        """测试速度采样"""
        # 设置测试数据
        self.analyzer.environment_stats = {
            'LC1_SS1': {
                'speed': {
                    'mean': 10.0,
                    'std': 2.0,
                    'min': 5.0,
                    'max': 15.0
                }
            }
        }
        
        # 测试速度采样
        speed = self.analyzer.sample_speed(landcover=1, slope=10.0)
        
        # 验证采样结果
        self.assertTrue(isinstance(speed, float))
        self.assertTrue(5.0 <= speed <= 15.0)  # 速度应在合理范围内
    
    def test_get_environment_group_stats(self):
        """测试获取环境组统计信息"""
        # 设置测试数据
        test_stats = {
            'speed': {'mean': 10.0, 'std': 2.0},
            'turn_rate': {'mean': 0.0, 'std': 1.0},
            'acceleration': {'mean': 1.0, 'std': 0.5},
            'sample_size': 100
        }
        self.analyzer.environment_stats = {'LC1_SS1': test_stats}
        
        # 获取统计信息
        stats = self.analyzer.get_environment_group_stats(landcover=1, slope=10.0)
        
        # 验证结果
        self.assertEqual(stats, test_stats)
    
    def test_get_environment_group_stats_missing(self):
        """测试获取不存在的环境组统计信息"""
        stats = self.analyzer.get_environment_group_stats(landcover=999, slope=10.0)
        self.assertIsNone(stats)

if __name__ == '__main__':
    unittest.main() 
```

### tests/unit/test_environment_mapper.py
```python
"""环境地图生成器单元测试"""

import pytest
import numpy as np
import rasterio
import tempfile
import os
from pathlib import Path
from src.generator.environment_mapper import EnvironmentMapper
from src.generator.config import (
    MAX_SPEED, MAX_SLOPE_THRESHOLD, IMPASSABLE_LANDCOVER_CODES,
    COMPLEX_TERRAIN_CODES
)

@pytest.fixture
def test_data():
    """生成测试用的环境数据"""
    size = (10, 10)
    # 创建临时目录
    with tempfile.TemporaryDirectory() as temp_dir:
        # 生成测试数据
        landcover = np.random.randint(1, 5, size, dtype=np.int32)  # 1-4为可通行地物
        landcover[0, 0] = IMPASSABLE_LANDCOVER_CODES[0]  # 添加一个不可通行点
        
        slope_magnitude = np.random.uniform(0, 30, size).astype(np.float32)  # 0-30度
        slope_magnitude[0, 1] = MAX_SLOPE_THRESHOLD + 1  # 添加一个过陡点
        
        slope_aspect = np.random.uniform(0, 360, size).astype(np.float32)  # 0-360度
        slope_aspect[1, 1] = -1  # 添加一个平地点
        
        # 创建测试文件
        meta = {
            'driver': 'GTiff',
            'height': size[0],
            'width': size[1],
            'count': 1,
            'crs': None,
            'transform': None
        }
        
        # 保存landcover数据
        landcover_path = os.path.join(temp_dir, 'landcover.tif')
        meta['dtype'] = np.int32
        with rasterio.open(landcover_path, 'w', **meta) as dst:
            dst.write(landcover, 1)
        
        # 保存slope_magnitude数据
        slope_magnitude_path = os.path.join(temp_dir, 'slope_magnitude.tif')
        meta['dtype'] = np.float32
        with rasterio.open(slope_magnitude_path, 'w', **meta) as dst:
            dst.write(slope_magnitude, 1)
        
        # 保存slope_aspect数据
        slope_aspect_path = os.path.join(temp_dir, 'slope_aspect.tif')
        with rasterio.open(slope_aspect_path, 'w', **meta) as dst:
            dst.write(slope_aspect, 1)
        
        yield {
            'landcover_path': landcover_path,
            'slope_magnitude_path': slope_magnitude_path,
            'slope_aspect_path': slope_aspect_path,
            'landcover_data': landcover,
            'slope_magnitude_data': slope_magnitude,
            'slope_aspect_data': slope_aspect
        }

class TestEnvironmentMapper:
    """环境地图生成器测试类"""
    
    def test_init(self, test_data):
        """测试初始化"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        assert mapper.height == 10
        assert mapper.width == 10
        assert np.array_equal(mapper.landcover_data, test_data['landcover_data'])
        assert np.array_equal(mapper.slope_magnitude_data, test_data['slope_magnitude_data'])
        assert np.array_equal(mapper.slope_aspect_data, test_data['slope_aspect_data'])
    
    def test_calculate_max_speed_map(self, test_data):
        """测试最大速度地图计算"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        max_speed_map = mapper.calculate_max_speed_map()
        
        # 验证不可通行区域
        assert max_speed_map[0, 0] == 0  # 不可通行地物
        assert max_speed_map[0, 1] == 0  # 过陡区域
        
        # 验证可通行区域
        passable_mask = ~np.isin(test_data['landcover_data'], IMPASSABLE_LANDCOVER_CODES)
        passable_mask &= test_data['slope_magnitude_data'] <= MAX_SLOPE_THRESHOLD
        assert np.all(max_speed_map[passable_mask] > 0)
        assert np.all(max_speed_map[passable_mask] <= MAX_SPEED)
    
    def test_calculate_typical_speed_map(self, test_data):
        """测试典型速度地图计算"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        typical_speed_map = mapper.calculate_typical_speed_map()
        
        # 验证平地点
        flat_point = typical_speed_map[1, 1]
        max_speed_at_flat = mapper.calculate_max_speed_map()[1, 1]
        assert flat_point <= max_speed_at_flat
        
        # 验证所有点的速度范围
        assert np.all(typical_speed_map >= 0)
        assert np.all(typical_speed_map <= MAX_SPEED)
    
    def test_calculate_speed_stddev_map(self, test_data):
        """测试速度标准差地图计算"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        speed_stddev_map = mapper.calculate_speed_stddev_map()
        
        # 验证不可通行区域
        assert speed_stddev_map[0, 0] == 0  # 不可通行地物
        assert speed_stddev_map[0, 1] == 0  # 过陡区域
        
        # 验证复杂地形
        complex_mask = np.isin(test_data['landcover_data'], COMPLEX_TERRAIN_CODES)
        if np.any(complex_mask):
            typical_speed = mapper.calculate_typical_speed_map()
            assert np.all(speed_stddev_map[complex_mask] > typical_speed[complex_mask] * 0.1)
    
    def test_calculate_cost_map(self, test_data):
        """测试成本地图计算"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        cost_map = mapper.calculate_cost_map()
        
        # 验证不可通行区域
        assert np.isinf(cost_map[0, 0])  # 不可通行地物
        assert np.isinf(cost_map[0, 1])  # 过陡区域
        
        # 验证可通行区域
        passable_mask = ~np.isin(test_data['landcover_data'], IMPASSABLE_LANDCOVER_CODES)
        passable_mask &= test_data['slope_magnitude_data'] <= MAX_SLOPE_THRESHOLD
        assert np.all(cost_map[passable_mask] > 0)
        assert np.all(np.isfinite(cost_map[passable_mask]))
    
    def test_save_environment_maps(self, test_data):
        """测试环境地图保存"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        
        # 计算所有地图
        max_speed_map = mapper.calculate_max_speed_map()
        typical_speed_map = mapper.calculate_typical_speed_map()
        speed_stddev_map = mapper.calculate_speed_stddev_map()
        cost_map = mapper.calculate_cost_map()
        
        # 创建临时目录并保存
        with tempfile.TemporaryDirectory() as temp_dir:
            mapper.save_environment_maps(
                temp_dir,
                max_speed_map,
                typical_speed_map,
                speed_stddev_map,
                cost_map
            )
            
            # 验证文件是否存在
            assert os.path.exists(os.path.join(temp_dir, 'max_speed_map.tif'))
            assert os.path.exists(os.path.join(temp_dir, 'typical_speed_map.tif'))
            assert os.path.exists(os.path.join(temp_dir, 'speed_stddev_map.tif'))
            assert os.path.exists(os.path.join(temp_dir, 'cost_map.tif'))
            
            # 验证文件内容
            with rasterio.open(os.path.join(temp_dir, 'max_speed_map.tif')) as src:
                saved_max_speed = src.read(1)
                assert np.array_equal(saved_max_speed, max_speed_map)
    
    def test_get_environment_params(self, test_data):
        """测试获取环境参数"""
        mapper = EnvironmentMapper(
            test_data['landcover_path'],
            test_data['slope_magnitude_path'],
            test_data['slope_aspect_path']
        )
        
        # 测试正常点
        params = mapper.get_environment_params(5, 5)
        assert 'max_speed' in params
        assert 'typical_speed' in params
        assert 'speed_stddev' in params
        assert 'cost' in params
        assert 'landcover' in params
        assert 'slope_magnitude' in params
        assert 'slope_aspect' in params
        assert params['max_speed'] >= 0
        assert params['typical_speed'] >= 0
        assert params['speed_stddev'] >= 0
        assert params['cost'] >= 0
        
        # 测试不可通行点
        params = mapper.get_environment_params(0, 0)
        assert params['max_speed'] == 0
        assert params['typical_speed'] == 0
        assert params['speed_stddev'] == 0
        assert np.isinf(params['cost'])
        
        # 测试无效坐标
        with pytest.raises(ValueError):
            mapper.get_environment_params(-1, 0)
        with pytest.raises(ValueError):
            mapper.get_environment_params(10, 0) 
```

### tests/unit/test_motion_simulator.py
```python
"""运动模拟器的单元测试"""

import unittest
import numpy as np
import sys
import os
import pytest

# 添加项目根目录到Python路径
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from src.generator.motion_simulator import (
    MotionSimulator,
    MotionConstraints,
    EnvironmentParams,
    TerrainConstraints
)

class TestMotionSimulator(unittest.TestCase):
    """测试运动模拟器类"""

    def setUp(self):
        """测试前的设置"""
        # 创建一个具有默认约束的模拟器实例
        self.simulator = MotionSimulator()

        # 创建一个简单的测试路径
        self.test_path = [
            (0.0, 0.0),    # 起点
            (1.0, 1.0),    # 对角线上的点
            (2.0, 2.0)     # 终点
        ]

        # 创建一个返回固定环境参数的函数
        def mock_env_params(lon, lat):
            return EnvironmentParams(
                max_speed=10.0,
                typical_speed=5.0,
                speed_stddev=1.0,
                slope_magnitude=0.0,  # 平地
                slope_aspect=0.0
            )
        self.mock_env_params_func = mock_env_params

    def test_simulate_motion(self):
        """测试基本的运动模拟功能"""
        trajectory = self.simulator.simulate_motion(
            self.test_path,
            self.mock_env_params_func
        )

        # 验证轨迹的基本属性
        self.assertGreater(len(trajectory), 0)
        
        # 检查每个轨迹点的合理性
        prev_time = -1
        for point in trajectory:
            time, _, _, speed, heading = point
            # 时间应该递增
            self.assertGreater(time, prev_time)
            prev_time = time
            # 速度应在限制范围内
            self.assertGreaterEqual(speed, self.simulator.motion_constraints.min_speed)
            self.assertLessEqual(speed, 10.0)  # max_speed from mock_env_params
            # 朝向应在0-360度范围内
            self.assertGreaterEqual(heading, 0)
            self.assertLess(heading, 360)

        # 检查加速度约束
        for i in range(1, len(trajectory)):
            dt = trajectory[i][0] - trajectory[i-1][0]
            if dt > 0:  # 避免除以零
                acceleration = (trajectory[i][3] - trajectory[i-1][3]) / dt
                # 加速度应在限制范围内
                self.assertLessEqual(abs(acceleration), 
                                max(self.simulator.motion_constraints.max_acceleration,
                                    self.simulator.motion_constraints.max_deceleration))

    def test_speed_constraints(self):
        """测试速度约束"""
        trajectory = self.simulator.simulate_motion(
            self.test_path,
            self.mock_env_params_func
        )

        # 验证所有速度都在约束范围内
        for point in trajectory:
            _, _, _, speed, _ = point
            self.assertGreaterEqual(speed, self.simulator.motion_constraints.min_speed)
            self.assertLessEqual(speed, 10.0)  # max_speed from mock_env_params

    def test_heading_constraints(self):
        """测试转向约束"""
        trajectory = self.simulator.simulate_motion(
            self.test_path,
            self.mock_env_params_func
        )

        # 检查转向率约束
        for i in range(1, len(trajectory)):
            dt = trajectory[i][0] - trajectory[i-1][0]
            if dt > 0:  # 避免除以零
                # 计算朝向变化（考虑角度环绕）
                heading_change = trajectory[i][4] - trajectory[i-1][4]
                if heading_change > 180:
                    heading_change -= 360
                elif heading_change < -180:
                    heading_change += 360
                    
                turn_rate = abs(heading_change / dt)
                # 转向率应在限制范围内
                self.assertLessEqual(turn_rate, self.simulator.motion_constraints.max_turn_rate * 1.1)  # 允许10%的误差

    def test_invalid_path(self):
        """测试无效路径的处理"""
        # 测试空路径
        with self.assertRaises(ValueError):
            self.simulator.simulate_motion([], self.mock_env_params_func)
            
        # 测试单点路径
        with self.assertRaises(ValueError):
            self.simulator.simulate_motion([(0.0, 0.0)], self.mock_env_params_func)

    def test_calculate_target_speed(self):
        """测试目标速度计算"""
        env_params = EnvironmentParams(
            max_speed=10.0,
            typical_speed=5.0,
            speed_stddev=1.0
        )

        # 多次测试以验证随机性和限制
        for _ in range(100):
            speed = self.simulator._calculate_target_speed(env_params, 0.0)  # 添加朝向参数
            self.assertGreaterEqual(speed, self.simulator.motion_constraints.min_speed)
            self.assertLessEqual(speed, env_params.max_speed)

    def test_heading_calculation(self):
        """测试朝向角计算"""
        # 测试基本方向
        test_cases = [
            # (start_pos, end_pos, expected_heading)
            ((0, 0), (0, 1), 0),    # 正北
            ((0, 0), (1, 0), 90),   # 正东
            ((0, 0), (0, -1), 180), # 正南
            ((0, 0), (-1, 0), 270)  # 正西
        ]
        
        for start_pos, end_pos, expected_heading in test_cases:
            heading = self.simulator._calculate_heading(start_pos, end_pos)
            self.assertAlmostEqual(heading, expected_heading, places=1)

def test_slope_effects_calculation():
    """测试坡度对速度的影响计算"""
    # 初始化模拟器，使用自定义地形约束
    terrain_constraints = TerrainConstraints(
        max_uphill_slope=30.0,
        max_downhill_slope=35.0,
        max_cross_slope=25.0,
        k_uphill=0.1,
        k_downhill=0.05,
        k_cross=0.2,
        min_speed_steep_slope=0.5
    )
    simulator = MotionSimulator(terrain_constraints=terrain_constraints)
    
    # 测试用例1：平地（无坡度）
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=0.0,
        slope_aspect=0.0
    )
    slope_along, cross_slope, speed_factor = simulator._calculate_slope_effects(0.0, env_params)
    assert slope_along == 0.0
    assert cross_slope == 0.0
    assert speed_factor == 1.0

    # 测试用例2：正向上坡
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=20.0,  # 20度坡
        slope_aspect=0.0       # 正北方向
    )
    # 车辆朝向正北（与坡向一致）
    slope_along, cross_slope, speed_factor = simulator._calculate_slope_effects(0.0, env_params)
    assert slope_along == pytest.approx(20.0, abs=0.1)
    assert cross_slope == pytest.approx(0.0, abs=0.1)
    assert speed_factor < 1.0  # 上坡应该减速
    assert speed_factor > 0.0  # 但仍可通行

    # 测试用例3：横坡
    # 车辆朝向东方（与坡向垂直）
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=20.0,
        slope_aspect=0.0       # 正北方向的坡
    )
    slope_along, cross_slope, speed_factor = simulator._calculate_slope_effects(90.0, env_params)
    assert slope_along == pytest.approx(0.0, abs=0.1)
    assert cross_slope == pytest.approx(20.0, abs=0.1)
    assert speed_factor < 1.0  # 横坡应该减速
    assert speed_factor > 0.0  # 但仍可通行

    # 测试用例4：超过最大上坡限制
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=35.0,  # 超过最大上坡限制
        slope_aspect=0.0
    )
    slope_along, cross_slope, speed_factor = simulator._calculate_slope_effects(0.0, env_params)
    assert speed_factor == 0.0  # 无法通行

    # 测试用例5：下坡
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=15.0,
        slope_aspect=0.0
    )
    # 车辆朝向正南（与坡向相反）
    slope_along, cross_slope, speed_factor = simulator._calculate_slope_effects(180.0, env_params)
    assert slope_along == pytest.approx(-15.0, abs=0.1)
    assert cross_slope == pytest.approx(0.0, abs=0.1)
    assert speed_factor > 1.0  # 下坡应该轻微加速
    assert speed_factor <= 1.2  # 但不超过1.2倍速度

def test_target_speed_with_slope():
    """测试目标速度计算（包含坡度影响）"""
    simulator = MotionSimulator()
    
    # 测试平地情况
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=0.0,
        slope_aspect=0.0
    )
    
    # 多次测试以验证随机性
    for _ in range(10):
        speed = simulator._calculate_target_speed(env_params, 0.0)
        assert 3.0 <= speed <= 7.0  # 考虑随机扰动的范围
        
    # 测试上坡情况
    env_params = EnvironmentParams(
        max_speed=10.0,
        typical_speed=5.0,
        speed_stddev=0.5,
        slope_magnitude=20.0,
        slope_aspect=0.0
    )
    
    # 车辆朝向正北（上坡）
    speed_uphill = simulator._calculate_target_speed(env_params, 0.0)
    assert speed_uphill < 5.0  # 上坡速度应该小于典型速度
    
    # 测试下坡情况
    # 车辆朝向正南（下坡）
    speed_downhill = simulator._calculate_target_speed(env_params, 180.0)
    assert speed_downhill > speed_uphill  # 下坡速度应该大于上坡速度

def test_motion_simulation_with_slopes():
    """测试在有坡度的环境下的运动模拟"""
    simulator = MotionSimulator()
    
    # 创建一个简单的路径
    path = [(0.0, 0.0), (0.0, 10.0)]  # 向北的直线路径
    
    # 模拟上坡环境
    def env_params_uphill(lon, lat):
        return EnvironmentParams(
            max_speed=10.0,
            typical_speed=5.0,
            speed_stddev=0.5,
            slope_magnitude=20.0,  # 20度坡
            slope_aspect=0.0       # 正北方向的坡
        )
    
    # 模拟运动
    trajectory_uphill = simulator.simulate_motion(path, env_params_uphill)
    
    # 检查上坡轨迹的特征
    speeds_uphill = [point[3] for point in trajectory_uphill]
    assert max(speeds_uphill) < 5.0  # 上坡最大速度应该小于典型速度
    
    # 模拟下坡环境
    def env_params_downhill(lon, lat):
        return EnvironmentParams(
            max_speed=10.0,
            typical_speed=5.0,
            speed_stddev=0.5,
            slope_magnitude=20.0,
            slope_aspect=180.0     # 正南方向的坡
        )
    
    # 模拟运动
    trajectory_downhill = simulator.simulate_motion(path, env_params_downhill)
    
    # 检查下坡轨迹的特征
    speeds_downhill = [point[3] for point in trajectory_downhill]
    assert max(speeds_downhill) > max(speeds_uphill)  # 下坡最大速度应该大于上坡最大速度

if __name__ == '__main__':
    unittest.main(verbosity=2) 
```

### tests/unit/test_oord_analyzer.py
```python
"""OORD分析器单元测试"""

import pytest
import pandas as pd
import numpy as np
from pathlib import Path
import tempfile
import os
from src.generator.oord_analyzer import OORDAnalyzer

@pytest.fixture
def test_slope_bins():
    """坡度分组边界值"""
    return [0, 5, 10, 15, 20, 90]

@pytest.fixture
def test_trajectory_data():
    """生成测试用的轨迹数据"""
    return pd.DataFrame({
        'timestamp': pd.date_range('2024-01-01', periods=100, freq='s'),
        'row': np.random.randint(0, 10, 100),
        'col': np.random.randint(0, 10, 100),
        'speed_mps': np.random.uniform(0, 10, 100),
        'heading_degrees': np.random.uniform(0, 360, 100),
        'turn_rate_dps': np.random.uniform(-30, 30, 100),
        'acceleration_mps2': np.random.uniform(-2, 2, 100)
    })

@pytest.fixture
def test_environment_data():
    """生成测试用的环境数据"""
    size = (10, 10)
    dem = np.random.uniform(0, 1000, size)
    slope = np.random.uniform(0, 45, size)
    aspect = np.random.uniform(0, 360, size)
    landcover = np.random.randint(1, 5, size)
    return dem, slope, aspect, landcover

class TestOORDAnalyzer:
    """OORD分析器测试类"""
    
    def test_init(self, test_slope_bins):
        """测试初始化"""
        analyzer = OORDAnalyzer(test_slope_bins)
        assert analyzer.slope_bins == test_slope_bins
        assert analyzer.min_samples_per_group == 100
        assert len(analyzer.environment_groups) == 0
    
    def test_add_environment_info(self, test_slope_bins, test_trajectory_data,
                                test_environment_data):
        """测试添加环境信息"""
        analyzer = OORDAnalyzer(test_slope_bins)
        dem, slope, aspect, landcover = test_environment_data
        
        # 添加环境信息
        df = analyzer.add_environment_info(test_trajectory_data, dem, slope,
                                         aspect, landcover)
        
        # 验证新增列
        assert 'elevation' in df.columns
        assert 'slope_magnitude' in df.columns
        assert 'slope_aspect' in df.columns
        assert 'landcover' in df.columns
        assert 'delta_angle' in df.columns
        assert 'slope_along_path' in df.columns
        assert 'cross_slope' in df.columns
        assert 'slope_bin' in df.columns
        assert 'group_label' in df.columns
        
        # 验证数值范围
        assert df['elevation'].min() >= 0
        assert df['slope_magnitude'].min() >= 0
        assert df['slope_magnitude'].max() <= 45
        assert df['slope_aspect'].min() >= 0
        assert df['slope_aspect'].max() <= 360
        assert df['landcover'].min() >= 1
        assert df['landcover'].max() <= 4
    
    def test_analyze_groups(self, test_slope_bins, test_trajectory_data,
                          test_environment_data):
        """测试环境组分析"""
        analyzer = OORDAnalyzer(test_slope_bins, min_samples_per_group=10)
        dem, slope, aspect, landcover = test_environment_data
        
        # 添加环境信息并分析
        df = analyzer.add_environment_info(test_trajectory_data, dem, slope,
                                         aspect, landcover)
        analyzer.analyze_groups(df)
        
        # 验证环境组
        assert len(analyzer.environment_groups) > 0
        for group in analyzer.environment_groups.values():
            assert group.count >= 10
            assert 0 <= group.max_speed <= 10
            assert 0 <= group.typical_speed <= 10
            assert group.speed_stddev >= 0
            assert -30 <= group.typical_turn_rate <= 30
            assert -2 <= group.typical_acceleration <= 2
    
    def test_analyze_slope_direction_effect(self, test_slope_bins,
                                          test_trajectory_data,
                                          test_environment_data):
        """测试坡向影响分析"""
        analyzer = OORDAnalyzer(test_slope_bins, min_samples_per_group=10)
        dem, slope, aspect, landcover = test_environment_data
        
        # 添加环境信息并分析
        df = analyzer.add_environment_info(test_trajectory_data, dem, slope,
                                         aspect, landcover)
        effect_params = analyzer.analyze_slope_direction_effect(df)
        
        # 验证参数
        for lc_params in effect_params.values():
            assert lc_params['k_uphill'] > 0
            assert lc_params['k_cross'] > 0
            assert lc_params['max_cross_slope_degrees'] > 0
    
    def test_save_and_load_results(self, test_slope_bins, test_trajectory_data,
                                 test_environment_data):
        """测试保存和加载分析结果"""
        analyzer = OORDAnalyzer(test_slope_bins, min_samples_per_group=10)
        dem, slope, aspect, landcover = test_environment_data
        
        # 添加环境信息并分析
        df = analyzer.add_environment_info(test_trajectory_data, dem, slope,
                                         aspect, landcover)
        analyzer.analyze_groups(df)
        
        # 保存结果
        with tempfile.TemporaryDirectory() as temp_dir:
            analyzer.save_analysis_results(temp_dir)
            
            # 创建新的分析器并加载结果
            new_analyzer = OORDAnalyzer(test_slope_bins)
            new_analyzer.load_analysis_results(temp_dir)
            
            # 验证加载的结果
            assert len(new_analyzer.environment_groups) == len(analyzer.environment_groups)
            for label, group in analyzer.environment_groups.items():
                loaded_group = new_analyzer.environment_groups[label]
                assert loaded_group.landcover_code == group.landcover_code
                assert loaded_group.slope_bin == group.slope_bin
                assert loaded_group.count == group.count
                assert loaded_group.max_speed == group.max_speed
                assert loaded_group.typical_speed == group.typical_speed
                assert loaded_group.speed_stddev == group.speed_stddev
    
    def test_invalid_data(self, test_slope_bins):
        """测试无效数据处理"""
        analyzer = OORDAnalyzer(test_slope_bins)
        
        # 测试加载不存在的文件
        with pytest.raises(FileNotFoundError):
            analyzer.load_analysis_results("nonexistent_dir")
        
        # 测试数据形状不匹配
        df = pd.DataFrame({'row': [0], 'col': [0]})
        dem_data = np.zeros((10, 10))
        slope_data = np.zeros((20, 20))  # 形状不匹配
        with pytest.raises(ValueError) as excinfo:
            analyzer.add_environment_info(df, dem_data, slope_data,
                                       np.zeros((10, 10)), np.zeros((10, 10)))
        assert "所有环境数据的形状必须一致" in str(excinfo.value)
        
        # 测试像素坐标超出范围
        df = pd.DataFrame({'row': [15], 'col': [0]})  # 行坐标超出范围
        with pytest.raises(ValueError) as excinfo:
            analyzer.add_environment_info(df, dem_data, dem_data,
                                       dem_data, dem_data)
        assert "像素坐标超出范围" in str(excinfo.value)
        
        # 测试缺少必要的列
        df = pd.DataFrame({'invalid_col': [0]})
        with pytest.raises(ValueError) as excinfo:
            analyzer.add_environment_info(df, dem_data, dem_data,
                                       dem_data, dem_data)
        assert "数据缺少必要的列" in str(excinfo.value) 
```

### tests/unit/test_path_planner.py
```python
"""路径规划器单元测试"""

import pytest
import numpy as np
import rasterio
import tempfile
import os
from pathlib import Path
from src.generator.path_planner import PathPlanner

@pytest.fixture
def test_data():
    """生成测试用的环境数据"""
    size = (100, 100)  # 使用较大的尺寸以便测试路径规划
    # 创建临时目录
    with tempfile.TemporaryDirectory() as temp_dir:
        # 生成测试数据
        cost_map = np.ones(size, dtype=np.float32)  # 默认成本为1
        
        # 添加障碍物（成本无穷大）
        cost_map[0:10, 0:10] = float('inf')  # 左上角障碍物
        cost_map[90:100, 90:100] = float('inf')  # 右下角障碍物
        
        # 添加高成本区域
        cost_map[40:60, 40:60] = 5.0  # 中心区域高成本
        
        # 创建测试文件
        meta = {
            'driver': 'GTiff',
            'height': size[0],
            'width': size[1],
            'count': 1,
            'crs': '+proj=latlong',
            'transform': rasterio.transform.Affine(0.001, 0, 0, 0, 0.001, 0),  # 约111米/像素
            'dtype': np.float32
        }
        
        # 保存成本地图
        cost_map_path = os.path.join(temp_dir, 'cost_map.tif')
        with rasterio.open(cost_map_path, 'w', **meta) as dst:
            dst.write(cost_map, 1)
        
        yield {
            'cost_map_path': cost_map_path,
            'cost_map_data': cost_map,
            'transform': meta['transform']
        }

class TestPathPlanner:
    """路径规划器测试类"""
    
    def test_init(self, test_data):
        """测试初始化"""
        planner = PathPlanner(test_data['cost_map_path'])
        assert planner.height == 100
        assert planner.width == 100
        assert np.array_equal(planner.cost_map, test_data['cost_map_data'])
        assert planner.transform == test_data['transform']
    
    def test_is_valid_position(self, test_data):
        """测试位置有效性检查"""
        planner = PathPlanner(test_data['cost_map_path'])
        
        # 测试正常点
        assert planner.is_valid_position((50, 50)) == True
        
        # 测试障碍物
        assert planner.is_valid_position((5, 5)) == False
        
        # 测试边界外的点
        assert planner.is_valid_position((-1, 0)) == False
        assert planner.is_valid_position((100, 0)) == False
    
    def test_calculate_heuristic(self, test_data):
        """测试启发式函数"""
        planner = PathPlanner(test_data['cost_map_path'])
        
        # 测试水平距离
        assert planner.calculate_heuristic((0, 0), (0, 3)) == 3.0
        
        # 测试垂直距离
        assert planner.calculate_heuristic((0, 0), (4, 0)) == 4.0
        
        # 测试对角线距离
        assert planner.calculate_heuristic((0, 0), (3, 4)) == 5.0
    
    def test_calculate_turn_cost(self, test_data):
        """测试转弯代价计算"""
        planner = PathPlanner(test_data['cost_map_path'])
        
        # 测试直线运动（无转弯）
        cost = planner.calculate_turn_cost(
            (1, 1),
            (1, 2),
            (1, 0)
        )
        assert cost == 0.0
        
        # 测试90度转弯
        cost = planner.calculate_turn_cost(
            (1, 1),
            (2, 1),
            (1, 0)
        )
        assert cost == pytest.approx(planner.smoothness_weight * np.pi/2, rel=1e-6)
        
        # 测试180度转弯
        cost = planner.calculate_turn_cost(
            (1, 1),
            (1, 0),
            (1, 2)
        )
        assert cost == pytest.approx(planner.smoothness_weight * np.pi, rel=1e-6)
    
    def test_find_path(self, test_data):
        """测试路径搜索"""
        planner = PathPlanner(test_data['cost_map_path'])
        
        # 测试简单路径（无障碍）
        start = (20, 20)
        goal = (25, 25)
        path = planner.find_path(start, goal)
        assert len(path) > 0
        assert path[0] == start
        assert path[-1] == goal
        
        # 测试绕过障碍物的路径
        start = (5, 15)  # 靠近左上角障碍物
        goal = (15, 5)
        path = planner.find_path(start, goal)
        assert len(path) > 0
        assert path[0] == start
        assert path[-1] == goal
        # 验证路径上的点都是可通行的
        for point in path:
            assert planner.is_valid_position(point)
        
        # 测试不可能的路径（起点或终点在障碍物中）
        with pytest.raises(ValueError):
            planner.find_path((5, 5), (20, 20))  # 起点在障碍物中
        with pytest.raises(ValueError):
            planner.find_path((20, 20), (95, 95))  # 终点在障碍物中
    
    def test_smooth_path(self, test_data):
        """测试路径平滑"""
        planner = PathPlanner(test_data['cost_map_path'])
        
        # 创建一个锯齿状路径
        original_path = [
            (20, 20), (21, 20), (22, 20), (23, 21),
            (24, 22), (25, 23), (26, 24), (27, 25)
        ]
        
        # 平滑路径
        smooth_path = planner.smooth_path(original_path)
        
        # 验证平滑后的路径
        assert len(smooth_path) > 0
        assert smooth_path[0] == original_path[0]  # 起点应该保持不变
        assert smooth_path[-1] == original_path[-1]  # 终点应该保持不变
        
        # 验证平滑后的路径点都是可通行的
        for point in smooth_path:
            assert planner.is_valid_position(point)
        
        # 验证平滑效果（通过计算路径的总转弯代价）
        original_turn_cost = sum(
            planner.calculate_turn_cost(original_path[i], original_path[i+1], original_path[i-1])
            for i in range(1, len(original_path)-1)
        )
        smooth_turn_cost = sum(
            planner.calculate_turn_cost(smooth_path[i], smooth_path[i+1], smooth_path[i-1])
            for i in range(1, len(smooth_path)-1)
        )
        assert smooth_turn_cost < original_turn_cost
    
    def test_plan(self, test_data):
        """测试完整的路径规划过程"""
        planner = PathPlanner(test_data['cost_map_path'])
        
        # 测试正常规划（包含平滑）
        start = (20, 20)
        goal = (80, 80)
        path = planner.plan(start, goal, smooth=True)
        assert len(path) > 0
        assert path[0] == start
        assert path[-1] == goal
        
        # 测试不进行平滑的规划
        path_no_smooth = planner.plan(start, goal, smooth=False)
        assert len(path_no_smooth) > 0
        assert path_no_smooth[0] == start
        assert path_no_smooth[-1] == goal
        
        # 验证平滑路径的转弯代价更小
        if len(path) > 2 and len(path_no_smooth) > 2:
            smooth_cost = sum(
                planner.calculate_turn_cost(path[i], path[i+1], path[i-1])
                for i in range(1, len(path)-1)
            )
            no_smooth_cost = sum(
                planner.calculate_turn_cost(path_no_smooth[i], path_no_smooth[i+1], path_no_smooth[i-1])
                for i in range(1, len(path_no_smooth)-1)
            )
            assert smooth_cost < no_smooth_cost 
```

### tests/unit/test_point_selector.py
```python
"""起点选择器单元测试"""

import pytest
import numpy as np
import rasterio
import tempfile
import os
from pathlib import Path
from src.generator.point_selector import PointSelector
from src.generator.config import (
    MAX_SLOPE_THRESHOLD, IMPASSABLE_LANDCOVER_CODES,
    MIN_START_END_DISTANCE_METERS
)

@pytest.fixture
def test_data():
    """生成测试用的环境数据"""
    size = (100, 100)  # 使用较大的尺寸以便测试距离约束
    # 创建临时目录
    with tempfile.TemporaryDirectory() as temp_dir:
        # 生成测试数据
        landcover = np.full(size, 11, dtype=np.int32)  # 默认为平原（可通行）
        landcover[0:10, 0:10] = IMPASSABLE_LANDCOVER_CODES[0]  # 添加不可通行区域
        landcover[90:100, 90:100] = IMPASSABLE_LANDCOVER_CODES[0]  # 添加不可通行区域
        
        slope = np.zeros(size, dtype=np.float32)  # 默认为平地
        slope[10:20, 10:20] = MAX_SLOPE_THRESHOLD + 1  # 添加过陡区域
        slope[80:90, 80:90] = MAX_SLOPE_THRESHOLD + 1  # 添加过陡区域
        
        # 创建测试文件
        meta = {
            'driver': 'GTiff',
            'height': size[0],
            'width': size[1],
            'count': 1,
            'crs': '+proj=latlong',
            'transform': rasterio.transform.Affine(0.001, 0, 0, 0, 0.001, 0)  # 约111米/像素
        }
        
        # 保存landcover数据
        landcover_path = os.path.join(temp_dir, 'landcover.tif')
        meta['dtype'] = np.int32
        with rasterio.open(landcover_path, 'w', **meta) as dst:
            dst.write(landcover, 1)
        
        # 保存slope数据
        slope_path = os.path.join(temp_dir, 'slope.tif')
        meta['dtype'] = np.float32
        with rasterio.open(slope_path, 'w', **meta) as dst:
            dst.write(slope, 1)
        
        yield {
            'landcover_path': landcover_path,
            'slope_path': slope_path,
            'landcover_data': landcover,
            'slope_data': slope,
            'transform': meta['transform']
        }

class TestPointSelector:
    """起点选择器测试类"""
    
    def test_init(self, test_data):
        """测试初始化"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        assert selector.height == 100
        assert selector.width == 100
        assert np.array_equal(selector.landcover_data, test_data['landcover_data'])
        assert np.array_equal(selector.slope_data, test_data['slope_data'])
        assert selector.transform == test_data['transform']
        assert selector.pixel_size_meters == pytest.approx(111.0, rel=0.1)  # 约111米/像素
    
    def test_is_point_accessible(self, test_data):
        """测试点可通行性检查"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        
        # 测试正常点
        assert selector.is_point_accessible(50, 50) == True
        
        # 测试不可通行地物
        assert selector.is_point_accessible(5, 5) == False
        
        # 测试过陡区域
        assert selector.is_point_accessible(15, 15) == False
        
        # 测试边界外的点
        assert selector.is_point_accessible(-1, 0) == False
        assert selector.is_point_accessible(100, 0) == False
    
    def test_calculate_distance(self, test_data):
        """测试距离计算"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        
        # 测试水平距离
        assert selector.calculate_distance((0, 0), (0, 3)) == 3.0
        
        # 测试垂直距离
        assert selector.calculate_distance((0, 0), (4, 0)) == 4.0
        
        # 测试对角线距离
        assert selector.calculate_distance((0, 0), (3, 4)) == 5.0
    
    def test_calculate_geo_distance(self, test_data):
        """测试地理距离计算"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        
        # 测试相邻像素
        dist = selector.calculate_geo_distance((0, 0), (0, 1))
        assert dist == pytest.approx(111.0, rel=0.1)  # 约111米
        
        # 测试对角线
        dist = selector.calculate_geo_distance((0, 0), (1, 1))
        assert dist == pytest.approx(157.0, rel=0.1)  # 约157米（111*√2）
    
    def test_select_start_points(self, test_data):
        """测试起点选择"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        
        # 选择一个终点（中心区域）
        end_point = (50, 50)
        
        # 测试单点选择
        start_points = selector.select_start_points(
            end_point,
            num_points=1,
            min_distance=1000  # 1公里
        )
        assert len(start_points) == 1
        start_point = start_points[0]
        
        # 验证起点可通行性
        assert selector.is_point_accessible(*start_point)
        
        # 验证距离约束
        dist = selector.calculate_geo_distance(start_point, end_point)
        assert dist >= 1000
        
        # 测试多点选择
        start_points = selector.select_start_points(
            end_point,
            num_points=5,
            min_distance=1000
        )
        assert len(start_points) == 5
        
        # 验证所有点的可通行性和距离约束
        for point in start_points:
            assert selector.is_point_accessible(*point)
            dist = selector.calculate_geo_distance(point, end_point)
            assert dist >= 1000
        
        # 验证点之间的最小间距
        for i in range(len(start_points)):
            for j in range(i + 1, len(start_points)):
                dist = selector.calculate_geo_distance(start_points[i], start_points[j])
                assert dist >= 250  # 最小间距为最小距离的1/4
    
    def test_select_start_points_for_all_ends(self, test_data):
        """测试为多个终点选择起点"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        
        # 创建测试终点
        end_points = [
            {'pixel': (50, 50), 'coord': (0.05, 0.05)},
            {'pixel': (30, 70), 'coord': (0.07, 0.03)}
        ]
        
        # 为每个终点选择3个起点
        pairs = selector.select_start_points_for_all_ends(end_points, points_per_end=3)
        
        # 验证结果
        assert len(pairs) == 6  # 2个终点 * 3个起点
        
        # 验证每个起终点对
        for start, end in pairs:
            # 验证起点可通行性
            assert selector.is_point_accessible(*start)
            
            # 验证距离约束
            dist = selector.calculate_geo_distance(start, end)
            assert dist >= MIN_START_END_DISTANCE_METERS
    
    def test_coordinate_conversion(self, test_data):
        """测试坐标转换"""
        selector = PointSelector(
            test_data['landcover_path'],
            test_data['slope_path']
        )
        
        # 测试像素到地理坐标的转换
        pixel = (50, 50)
        lon, lat = selector.pixel_to_geo(pixel)
        assert lon == pytest.approx(0.05, rel=1e-6)
        assert lat == pytest.approx(0.05, rel=1e-6)
        
        # 测试地理到像素坐标的转换
        coord = (0.05, 0.05)
        row, col = selector.geo_to_pixel(coord)
        assert row == 50
        assert col == 50
        
        # 测试转换的可逆性
        pixel2 = selector.geo_to_pixel(selector.pixel_to_geo(pixel))
        assert pixel2[0] == pixel[0]
        assert pixel2[1] == pixel[1] 
```

### tests/unit/test_terrain_analyzer.py
```python
"""地形分析器单元测试"""

import pytest
import numpy as np
import rasterio
from pathlib import Path

from src.generator.terrain_analyzer import TerrainAnalyzer

@pytest.fixture
def test_dem_data():
    """创建测试用DEM数据"""
    # 创建3000x3000的测试DEM数据
    dem = np.zeros((3000, 3000), dtype=np.float32)
    
    # 添加一些地形特征
    # 1. 平坦区域(高度=0)
    # 2. 斜坡(线性变化)
    dem[1000:1100, 1000:1100] = np.linspace(0, 100, 100).reshape(-1, 1)
    # 3. 山峰(高斯分布)
    x, y = np.meshgrid(np.linspace(-5, 5, 100), np.linspace(-5, 5, 100))
    mountain = 500 * np.exp(-(x**2 + y**2) / 8)
    dem[2000:2100, 2000:2100] = mountain
    
    return dem

@pytest.fixture
def test_dem_file(tmp_path, test_dem_data):
    """创建测试用DEM文件"""
    # 创建测试用GeoTIFF文件
    dem_path = tmp_path / "test_dem.tif"
    transform = rasterio.transform.from_origin(-6.0, 58.0, 0.001, 0.001)
    
    meta = {
        'driver': 'GTiff',
        'height': 3000,
        'width': 3000,
        'count': 1,
        'dtype': np.float32,
        'crs': '+proj=latlong',
        'transform': transform
    }
    
    with rasterio.open(dem_path, 'w', **meta) as dst:
        dst.write(test_dem_data, 1)
    
    return dem_path

class TestTerrainAnalyzer:
    """地形分析器测试类"""
    
    def test_init(self, test_dem_file):
        """测试初始化"""
        analyzer = TerrainAnalyzer(test_dem_file)
        assert analyzer.dem_data is not None
        assert analyzer.transform is not None
        assert analyzer.meta is not None
        assert analyzer.pixel_width > 0
        assert analyzer.pixel_height > 0
    
    def test_calculate_slope_magnitude(self, test_dem_file):
        """测试坡度大小计算"""
        analyzer = TerrainAnalyzer(test_dem_file)
        slope = analyzer.calculate_slope_magnitude()
        
        # 验证形状
        assert slope.shape == analyzer.dem_data.shape
        
        # 验证平坦区域坡度为0
        assert np.allclose(slope[0:100, 0:100], 0, atol=0.1)
        
        # 验证斜坡区域坡度
        slope_area = slope[1000:1100, 1000:1100]
        assert np.all(slope_area > 0)  # 坡度应该大于0
        assert np.all(slope_area < 90)  # 坡度应该小于90度
        
        # 验证山峰区域坡度变化
        mountain_slope = slope[2000:2100, 2000:2100]
        assert np.all(mountain_slope >= 0)  # 坡度应该非负
        assert np.all(mountain_slope <= 90)  # 坡度应该不超过90度
        # 山顶坡度应该接近0
        assert np.mean(mountain_slope[45:55, 45:55]) < 5
    
    def test_calculate_slope_aspect(self, test_dem_file):
        """测试坡向计算"""
        analyzer = TerrainAnalyzer(test_dem_file)
        aspect = analyzer.calculate_slope_aspect()
        
        # 验证形状
        assert aspect.shape == analyzer.dem_data.shape
        
        # 验证平坦区域坡向为-1
        assert np.all(aspect[0:100, 0:100] == -1)
        
        # 验证斜坡区域坡向
        slope_aspect = aspect[1000:1100, 1000:1100]
        valid_aspect = slope_aspect[slope_aspect != -1]
        assert np.all(valid_aspect >= 0)  # 坡向应该在0-360度之间
        assert np.all(valid_aspect < 360)
        
        # 验证山峰区域坡向变化
        mountain_aspect = aspect[2000:2100, 2000:2100]
        valid_mountain = mountain_aspect[mountain_aspect != -1]
        assert np.all(valid_mountain >= 0)
        assert np.all(valid_mountain < 360)
    
    def test_save_terrain_maps(self, test_dem_file, tmp_path):
        """测试地形属性地图保存"""
        analyzer = TerrainAnalyzer(test_dem_file)
        
        # 保存地图
        slope_path, aspect_path = analyzer.save_terrain_maps(str(tmp_path))
        
        # 验证文件是否存在
        assert Path(slope_path).exists()
        assert Path(aspect_path).exists()
        
        # 验证文件内容
        with rasterio.open(slope_path) as src:
            slope = src.read(1)
            assert slope.shape == analyzer.dem_data.shape
            assert np.all(slope >= 0)
            assert np.all(slope <= 90)
        
        with rasterio.open(aspect_path) as src:
            aspect = src.read(1)
            assert aspect.shape == analyzer.dem_data.shape
            valid_aspect = aspect[aspect != -1]
            assert np.all(valid_aspect >= 0)
            assert np.all(valid_aspect < 360)
    
    def test_invalid_file(self):
        """测试无效文件处理"""
        with pytest.raises(FileNotFoundError):
            TerrainAnalyzer("nonexistent_dem.tif") 
```

### tests/unit/test_trajectory_generator.py
```python
"""
轨迹生成器模块的单元测试
"""

import unittest
from datetime import datetime, timedelta
from unittest.mock import MagicMock, patch

import numpy as np
import pandas as pd

from src.analysis import EnvironmentAnalyzer
from src.data_processing import GISDataLoader
from src.generator import TrajectoryGenerator

class TestTrajectoryGenerator(unittest.TestCase):
    """测试轨迹生成器类"""
    
    def setUp(self):
        """测试前的准备工作"""
        # 创建GISDataLoader的Mock对象
        self.mock_gis_loader = MagicMock(spec=GISDataLoader)
        
        # 创建EnvironmentAnalyzer的Mock对象
        self.mock_env_analyzer = MagicMock(spec=EnvironmentAnalyzer)
        
        # 设置mock返回值
        self.mock_gis_loader.get_pixel_coords.return_value = (100, 100)
        self.mock_gis_loader.get_elevation.return_value = 100.0
        self.mock_gis_loader.get_slope.return_value = 10.0
        self.mock_gis_loader.get_landcover.return_value = 1
        
        self.mock_env_analyzer.sample_speed.return_value = 10.0
        
        # 创建生成器实例
        self.generator = TrajectoryGenerator(
            gis_loader=self.mock_gis_loader,
            env_analyzer=self.mock_env_analyzer
        )
        
        # 设置测试用的时间和坐标
        self.start_time = pd.Timestamp('2024-01-01 12:00:00')
        self.start_point = (116.0, 40.0)
        self.end_point = (116.1, 40.1)
        self.region_bounds = (116.0, 40.0, 116.1, 40.1)
        self.time_range = (
            pd.Timestamp('2024-01-01 12:00:00'),
            pd.Timestamp('2024-01-01 13:00:00')
        )
    
    def test_generate_trajectory(self):
        """测试单条轨迹生成"""
        trajectory = self.generator.generate_trajectory(
            start_point=self.start_point,
            end_point=self.end_point,
            start_time=self.start_time
        )
        
        # 验证轨迹数据格式
        self.assertIsInstance(trajectory, pd.DataFrame)
        required_columns = [
            'timestamp', 'longitude', 'latitude', 'elevation',
            'speed', 'heading', 'turn_rate', 'acceleration'
        ]
        self.assertTrue(all(col in trajectory.columns for col in required_columns))
        
        # 验证轨迹起点和终点
        self.assertAlmostEqual(trajectory.iloc[0]['longitude'], self.start_point[0], places=6)
        self.assertAlmostEqual(trajectory.iloc[0]['latitude'], self.start_point[1], places=6)
        self.assertAlmostEqual(trajectory.iloc[-1]['longitude'], self.end_point[0], places=6)
        self.assertAlmostEqual(trajectory.iloc[-1]['latitude'], self.end_point[1], places=6)
        
        # 验证时间戳
        self.assertEqual(trajectory.iloc[0]['timestamp'], self.start_time)
        self.assertTrue(all(trajectory['timestamp'].diff()[1:] > pd.Timedelta(0)))
    
    def test_generate_trajectories(self):
        """测试批量轨迹生成"""
        num_trajectories = 5
        trajectories = self.generator.generate_trajectories(
            num_trajectories=num_trajectories,
            region_bounds=self.region_bounds,
            time_range=self.time_range
        )
        
        # 验证生成的轨迹数量
        self.assertEqual(len(trajectories), num_trajectories)
        
        # 验证每条轨迹的格式和内容
        for traj_id, trajectory in trajectories.items():
            self.assertIsInstance(trajectory, pd.DataFrame)
            required_columns = [
                'timestamp', 'longitude', 'latitude', 'elevation',
                'speed', 'heading', 'turn_rate', 'acceleration'
            ]
            self.assertTrue(all(col in trajectory.columns for col in required_columns))
            
            # 验证坐标在区域范围内
            self.assertTrue(all(trajectory['longitude'] >= self.region_bounds[0]))
            self.assertTrue(all(trajectory['longitude'] <= self.region_bounds[2]))
            self.assertTrue(all(trajectory['latitude'] >= self.region_bounds[1]))
            self.assertTrue(all(trajectory['latitude'] <= self.region_bounds[3]))
            
            # 验证时间在范围内
            self.assertTrue(all(trajectory['timestamp'] >= self.time_range[0]))
            self.assertTrue(all(trajectory['timestamp'] <= self.time_range[1]))
    
    def test_plan_path(self):
        """测试路径规划"""
        waypoints = self.generator._plan_path(
            start_point=self.start_point,
            end_point=self.end_point
        )
        
        # 验证路径点格式
        self.assertIsInstance(waypoints, list)
        self.assertTrue(all(isinstance(point, tuple) and len(point) == 2
                          for point in waypoints))
        
        # 验证起点和终点
        self.assertEqual(waypoints[0], self.start_point)
        self.assertEqual(waypoints[-1], self.end_point)
        
        # 验证路径点间距合理
        for i in range(len(waypoints) - 1):
            p1, p2 = waypoints[i], waypoints[i + 1]
            distance = np.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
            self.assertLess(distance, 0.01)  # 相邻点间距不超过约1km
    
    def test_generate_motion(self):
        """测试运动生成"""
        waypoints = [
            self.start_point,
            (116.05, 40.05),
            self.end_point
        ]
        
        motion = self.generator._generate_motion(
            waypoints=waypoints,
            start_time=self.start_time
        )
        
        # 验证运动数据格式
        self.assertIsInstance(motion, pd.DataFrame)
        required_columns = [
            'timestamp', 'longitude', 'latitude', 'elevation',
            'speed', 'heading', 'turn_rate', 'acceleration'
        ]
        self.assertTrue(all(col in motion.columns for col in required_columns))
        
        # 验证运动参数合理性
        self.assertTrue(all(motion['speed'] >= 0))  # 速度非负
        self.assertTrue(all(motion['heading'] >= 0) and all(motion['heading'] < 360))  # 航向角在[0,360)范围内
        self.assertTrue(all(abs(motion['turn_rate']) <= 45))  # 转向率不超过45度/秒
        self.assertTrue(all(abs(motion['acceleration']) <= 5))  # 加速度不超过5m/s²

if __name__ == '__main__':
    unittest.main() 
```

### tests/unit/test_trajectory_loader.py
```python
"""
轨迹加载器模块的单元测试
"""

import os
import unittest
from datetime import datetime, timedelta
from pathlib import Path

import numpy as np
import pandas as pd
import pytest

from src.data_processing.trajectory_loader import TrajectoryLoader

class TestTrajectoryLoader(unittest.TestCase):
    """测试轨迹加载器类"""
    
    def setUp(self):
        """测试前的准备工作"""
        self.loader = TrajectoryLoader()
        self.test_data_dir = Path(__file__).parent.parent / "test_data"
        os.makedirs(self.test_data_dir, exist_ok=True)
        
        # 创建测试用的轨迹数据
        self.create_test_trajectory()
    
    def create_test_trajectory(self):
        """创建用于测试的轨迹数据文件"""
        # 生成一个简单的轨迹
        timestamps = [
            datetime(2024, 1, 1, 12, 0) + timedelta(seconds=i)
            for i in range(10)
        ]
        
        data = {
            'timestamp': timestamps,
            'longitude': [116.0 + i*0.001 for i in range(10)],
            'latitude': [40.0 + i*0.001 for i in range(10)]
        }
        
        df = pd.DataFrame(data)
        
        # 保存测试轨迹
        test_file = self.test_data_dir / "test_trajectory.csv"
        df.to_csv(test_file, index=False)
    
    def test_load_trajectory(self):
        """测试加载单个轨迹文件"""
        test_file = self.test_data_dir / "test_trajectory.csv"
        df = self.loader.load_trajectory(test_file)
        
        self.assertEqual(len(df), 10)
        self.assertTrue('timestamp' in df.columns)
        self.assertTrue('longitude' in df.columns)
        self.assertTrue('latitude' in df.columns)
        self.assertTrue(isinstance(df['timestamp'].iloc[0], pd.Timestamp))
    
    def test_load_trajectory_missing_columns(self):
        """测试加载缺少必要列的轨迹文件"""
        # 创建缺少列的数据
        df = pd.DataFrame({
            'timestamp': [datetime.now()],
            'longitude': [116.0]
            # 缺少latitude列
        })
        
        test_file = self.test_data_dir / "invalid_trajectory.csv"
        df.to_csv(test_file, index=False)
        
        with pytest.raises(ValueError, match="轨迹文件缺少必要的列"):
            self.loader.load_trajectory(test_file)
    
    def test_preprocess_trajectory(self):
        """测试轨迹预处理功能"""
        # 先加载测试轨迹
        test_file = self.test_data_dir / "test_trajectory.csv"
        self.loader.load_trajectory(test_file)
        
        # 预处理轨迹
        trajectory_id = "test_trajectory"
        df_processed = self.loader.preprocess_trajectory(trajectory_id)
        
        # 验证计算的特征
        self.assertTrue('speed' in df_processed.columns)
        self.assertTrue('heading' in df_processed.columns)
        self.assertTrue('turn_rate' in df_processed.columns)
        self.assertTrue('acceleration' in df_processed.columns)
        
        # 验证速度计算
        speeds = df_processed['speed'].dropna()
        self.assertTrue(all(speeds >= 0))  # 速度应该非负
    
    def test_haversine_distance(self):
        """测试Haversine距离计算"""
        # 测试已知距离的两点
        point1 = np.array([[116.0, 40.0]])  # 北京附近的点
        point2 = np.array([[116.1, 40.0]])  # 约8.5公里
        
        distance = self.loader._haversine_distance(point1, point2)[0]
        
        # 允许1%的误差
        self.assertAlmostEqual(distance, 8500, delta=85)
    
    def test_calculate_heading(self):
        """测试方向角计算"""
        # 创建一个向正东方向移动的轨迹
        coords = np.array([
            [116.0, 40.0],
            [116.1, 40.0]
        ])
        
        headings = self.loader._calculate_heading(coords)
        
        # 向东移动应该是90度（允许一定误差）
        self.assertAlmostEqual(headings[0], 90.0, delta=1.0)
        self.assertAlmostEqual(headings[1], 90.0, delta=1.0)
    
    def tearDown(self):
        """测试后的清理工作"""
        # 删除测试文件
        for file in self.test_data_dir.glob("*.csv"):
            file.unlink()
        
        # 删除测试目录（如果为空）
        try:
            self.test_data_dir.rmdir()
        except OSError:
            pass  # 目录不为空或其他原因无法删除时忽略

if __name__ == '__main__':
    unittest.main() 
```

### 作图规范.md
```
# Python科学绘图规范

## 1. 字体设置

### 1.1 基本要求
- 中文：宋体 (SimSun)，16号
- 英文和数字：Times New Roman，16号
- 坐标轴刻度：Times New Roman，16号
- 图例：中文使用宋体，英文和数字使用Times New Roman，16号

### 1.2 使用方法
1. 将`plot_style.py`文件放在项目根目录下
2. 在绘图脚本开头导入样式文件：
```python
import plot_style
```
这样就会自动应用统一的字体和样式设置。

## 2. 图形规范

### 2.1 基本设置
- 默认图像大小：8×6 英寸
- 显示分辨率：100 DPI
- 保存分辨率：300 DPI
- 默认显示网格线（灰色虚线，透明度0.3）

### 2.2 次方显示
- 使用上标形式，如：$\times 10^{-3}$
- 在LaTeX模式下书写
- 示例代码：
```python
ax.set_ylabel('速度 ($\\times 10^{-3}$ m/s)')
```

### 2.3 单位标注
- 使用括号括起单位
- 单位使用Times New Roman
- 示例：速度 (m/s)、时间 (s)、温度 (K)

## 3. 示例代码

```python
import matplotlib.pyplot as plt
import numpy as np
import plot_style  # 导入统一样式设置

# 创建数据
x = np.linspace(0, 10, 100)
y = np.sin(x)

# 创建图形
fig, ax = plt.subplots()

# 绘制曲线
ax.plot(x, y, 'b-', label='正弦曲线')

# 设置标题和标签
ax.set_title('正弦函数示例')
ax.set_xlabel('时间 (s)')
ax.set_ylabel('幅值 ($\\times 10^{-3}$)')

# 添加图例
ax.legend()

# 保存图片
plt.savefig('example.png', bbox_inches='tight')
```

## 4. 注意事项

1. 确保系统中已安装所需字体：
   - 宋体：`/usr/share/fonts/truetype/custom/simsun.ttc`
   - Times New Roman：`/usr/share/fonts/truetype/custom/times.ttf`

2. 如果出现字体问题：
   - 检查字体文件是否存在
   - 运行`fc-cache -fv`更新字体缓存
   - 重启Python内核

3. 图像元素的统一性：
   - 所有文字大小保持一致（16号）
   - 保持网格线样式统一
   - 颜色搭配协调

4. 保存图像：
   - 使用`bbox_inches='tight'`参数避免标签被裁剪
   - 建议同时保存`.png`和`.pdf`格式
   - 使用至少300DPI的分辨率

## 5. 常见问题解决

1. 如果中文显示为方块：
   - 检查宋体文件路径是否正确
   - 确认`plot_style.py`中的字体设置正确

2. 如果数学公式显示异常：
   - 使用原始字符串`r'$\times 10^{-3}$'`
   - 确保LaTeX相关包已安装

3. 如果需要修改默认设置：
   - 编辑`plot_style.py`中的参数
   - 重新导入样式文件 
```